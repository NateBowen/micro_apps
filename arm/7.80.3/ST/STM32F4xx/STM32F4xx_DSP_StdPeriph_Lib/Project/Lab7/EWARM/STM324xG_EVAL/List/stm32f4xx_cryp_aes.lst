###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       13/Mar/2017  19:46:56
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
#    Command line =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\List
#        -o
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\List\stm32f4xx_cryp_aes.lst
#    Object file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\Obj\stm32f4xx_cryp_aes.o
#
###############################################################################

C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_cryp_aes.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7            * @brief   This file provides high level functions to encrypt and decrypt an 
      8            *          input message using AES in ECB/CBC/CTR/GCM/CCM modes.
      9            *          It uses the stm32f4xx_cryp.c/.h drivers to access the STM32F4xx CRYP
     10            *          peripheral.
     11            *          AES-ECB/CBC/CTR/GCM/CCM modes are available on STM32F437x Devices.
     12            *          For STM32F41xx Devices, only AES-ECB/CBC/CTR modes are available.
     13            *
     14          @verbatim
     15           ===================================================================
     16                            ##### How to use this driver #####
     17           ===================================================================
     18           [..]
     19             (#) Enable The CRYP controller clock using 
     20                RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
     21            
     22             (#) Encrypt and decrypt using AES in ECB Mode using CRYP_AES_ECB() function.
     23            
     24             (#) Encrypt and decrypt using AES in CBC Mode using CRYP_AES_CBC() function.
     25            
     26             (#) Encrypt and decrypt using AES in CTR Mode using CRYP_AES_CTR() function.
     27          
     28             (#) Encrypt and decrypt using AES in GCM Mode using CRYP_AES_GCM() function.
     29             
     30             (#) Encrypt and decrypt using AES in CCM Mode using CRYP_AES_CCM() function.
     31               
     32          @endverbatim
     33            *
     34            ******************************************************************************
     35            * @attention
     36            *
     37            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     38            *
     39            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     40            * You may not use this file except in compliance with the License.
     41            * You may obtain a copy of the License at:
     42            *
     43            *        http://www.st.com/software_license_agreement_liberty_v2
     44            *
     45            * Unless required by applicable law or agreed to in writing, software 
     46            * distributed under the License is distributed on an "AS IS" BASIS, 
     47            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     48            * See the License for the specific language governing permissions and
     49            * limitations under the License.
     50            *
     51            ******************************************************************************  
     52            */
     53          
     54          /* Includes ------------------------------------------------------------------*/
     55          #include "stm32f4xx_cryp.h"
     56          
     57          /** @addtogroup STM32F4xx_StdPeriph_Driver
     58            * @{
     59            */
     60          
     61          /** @defgroup CRYP 
     62            * @brief CRYP driver modules
     63            * @{
     64            */
     65          
     66          /* Private typedef -----------------------------------------------------------*/
     67          /* Private define ------------------------------------------------------------*/
     68          #define AESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
     69          
     70          /* Private macro -------------------------------------------------------------*/
     71          /* Private variables ---------------------------------------------------------*/
     72          /* Private function prototypes -----------------------------------------------*/
     73          /* Private functions ---------------------------------------------------------*/
     74          
     75          /** @defgroup CRYP_Private_Functions
     76            * @{
     77            */ 
     78          
     79          /** @defgroup CRYP_Group6 High Level AES functions
     80           *  @brief   High Level AES functions 
     81           *
     82          @verbatim   
     83           ===============================================================================
     84                                 ##### High Level AES functions #####
     85           ===============================================================================
     86          
     87          @endverbatim
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Encrypt and decrypt using AES in ECB Mode
     93            * @param  Mode: encryption or decryption Mode.
     94            *          This parameter can be one of the following values:
     95            *            @arg MODE_ENCRYPT: Encryption
     96            *            @arg MODE_DECRYPT: Decryption
     97            * @param  Key: Key used for AES algorithm.
     98            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
     99            * @param  Input: pointer to the Input buffer.
    100            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    101            * @param  Output: pointer to the returned buffer.
    102            * @retval An ErrorStatus enumeration value:
    103            *          - SUCCESS: Operation done
    104            *          - ERROR: Operation failed
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
    107                                   uint8_t* Input, uint32_t Ilength, uint8_t* Output)
    108          {
   \                     CRYP_AES_ECB: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB08E             SUB      SP,SP,#+56
   \   00000006   0x0007             MOVS     R7,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4692             MOV      R10,R2
    109            CRYP_InitTypeDef AES_CRYP_InitStructure;
    110            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    111            __IO uint32_t counter = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    112            uint32_t busystatus = 0;
   \   00000010   0x2000             MOVS     R0,#+0
    113            ErrorStatus status = SUCCESS;
   \   00000012   0x2501             MOVS     R5,#+1
    114            uint32_t keyaddr    = (uint32_t)Key;
    115            uint32_t inputaddr  = (uint32_t)Input;
   \   00000014   0x001C             MOVS     R4,R3
    116            uint32_t outputaddr = (uint32_t)Output;
   \   00000016   0x9E17             LDR      R6,[SP, #+92]
    117            uint32_t i = 0;
   \   00000018   0xF05F 0x0900      MOVS     R9,#+0
    118          
    119            /* Crypto structures initialisation*/
    120            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   0000001C   0xA805             ADD      R0,SP,#+20
   \   0000001E   0x.... 0x....      BL       CRYP_KeyStructInit
    121          
    122            switch(Keysize)
   \   00000022   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000026   0xF1BA 0x0F80      CMP      R10,#+128
   \   0000002A   0xD006             BEQ.N    ??CRYP_AES_ECB_0
   \   0000002C   0xF1BA 0x0FC0      CMP      R10,#+192
   \   00000030   0xD01C             BEQ.N    ??CRYP_AES_ECB_1
   \   00000032   0xF5BA 0x7F80      CMP      R10,#+256
   \   00000036   0xD03F             BEQ.N    ??CRYP_AES_ECB_2
   \   00000038   0xE070             B.N      ??CRYP_AES_ECB_3
    123            {
    124              case 128:
    125              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_ECB_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    126              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000003E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000042   0xBA00             REV      R0,R0
   \   00000044   0x9009             STR      R0,[SP, #+36]
    127              keyaddr+=4;
   \   00000046   0xF118 0x0804      ADDS     R8,R8,#+4
    128              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   0000004A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000004E   0xBA00             REV      R0,R0
   \   00000050   0x900A             STR      R0,[SP, #+40]
    129              keyaddr+=4;
   \   00000052   0xF118 0x0804      ADDS     R8,R8,#+4
    130              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000056   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000005A   0xBA00             REV      R0,R0
   \   0000005C   0x900B             STR      R0,[SP, #+44]
    131              keyaddr+=4;
   \   0000005E   0xF118 0x0804      ADDS     R8,R8,#+4
    132              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000062   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000066   0xBA00             REV      R0,R0
   \   00000068   0x900C             STR      R0,[SP, #+48]
    133              break;
   \   0000006A   0xE057             B.N      ??CRYP_AES_ECB_4
    134              case 192:
    135              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_ECB_1: (+1)
   \   0000006C   0xF44F 0x7080      MOV      R0,#+256
   \   00000070   0x9004             STR      R0,[SP, #+16]
    136              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000072   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000076   0xBA00             REV      R0,R0
   \   00000078   0x9007             STR      R0,[SP, #+28]
    137              keyaddr+=4;
   \   0000007A   0xF118 0x0804      ADDS     R8,R8,#+4
    138              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   0000007E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000082   0xBA00             REV      R0,R0
   \   00000084   0x9008             STR      R0,[SP, #+32]
    139              keyaddr+=4;
   \   00000086   0xF118 0x0804      ADDS     R8,R8,#+4
    140              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000008A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000008E   0xBA00             REV      R0,R0
   \   00000090   0x9009             STR      R0,[SP, #+36]
    141              keyaddr+=4;
   \   00000092   0xF118 0x0804      ADDS     R8,R8,#+4
    142              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000096   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000009A   0xBA00             REV      R0,R0
   \   0000009C   0x900A             STR      R0,[SP, #+40]
    143              keyaddr+=4;
   \   0000009E   0xF118 0x0804      ADDS     R8,R8,#+4
    144              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000A2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000A6   0xBA00             REV      R0,R0
   \   000000A8   0x900B             STR      R0,[SP, #+44]
    145              keyaddr+=4;
   \   000000AA   0xF118 0x0804      ADDS     R8,R8,#+4
    146              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000AE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B2   0xBA00             REV      R0,R0
   \   000000B4   0x900C             STR      R0,[SP, #+48]
    147              break;
   \   000000B6   0xE031             B.N      ??CRYP_AES_ECB_4
    148              case 256:
    149              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_ECB_2: (+1)
   \   000000B8   0xF44F 0x7000      MOV      R0,#+512
   \   000000BC   0x9004             STR      R0,[SP, #+16]
    150              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   000000BE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C2   0xBA00             REV      R0,R0
   \   000000C4   0x9005             STR      R0,[SP, #+20]
    151              keyaddr+=4;
   \   000000C6   0xF118 0x0804      ADDS     R8,R8,#+4
    152              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000000CA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000CE   0xBA00             REV      R0,R0
   \   000000D0   0x9006             STR      R0,[SP, #+24]
    153              keyaddr+=4;
   \   000000D2   0xF118 0x0804      ADDS     R8,R8,#+4
    154              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000D6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000DA   0xBA00             REV      R0,R0
   \   000000DC   0x9007             STR      R0,[SP, #+28]
    155              keyaddr+=4;
   \   000000DE   0xF118 0x0804      ADDS     R8,R8,#+4
    156              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000E2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000E6   0xBA00             REV      R0,R0
   \   000000E8   0x9008             STR      R0,[SP, #+32]
    157              keyaddr+=4;
   \   000000EA   0xF118 0x0804      ADDS     R8,R8,#+4
    158              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000EE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000F2   0xBA00             REV      R0,R0
   \   000000F4   0x9009             STR      R0,[SP, #+36]
    159              keyaddr+=4;
   \   000000F6   0xF118 0x0804      ADDS     R8,R8,#+4
    160              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000FA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000FE   0xBA00             REV      R0,R0
   \   00000100   0x900A             STR      R0,[SP, #+40]
    161              keyaddr+=4;
   \   00000102   0xF118 0x0804      ADDS     R8,R8,#+4
    162              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000106   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000010A   0xBA00             REV      R0,R0
   \   0000010C   0x900B             STR      R0,[SP, #+44]
    163              keyaddr+=4;
   \   0000010E   0xF118 0x0804      ADDS     R8,R8,#+4
    164              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000112   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000116   0xBA00             REV      R0,R0
   \   00000118   0x900C             STR      R0,[SP, #+48]
    165              break;
   \   0000011A   0xE7FF             B.N      ??CRYP_AES_ECB_4
    166              default:
    167              break;
    168            }
    169          
    170            /*------------------ AES Decryption ------------------*/
    171            if(Mode == MODE_DECRYPT) /* AES decryption */
   \                     ??CRYP_AES_ECB_3: (+1)
   \                     ??CRYP_AES_ECB_4: (+1)
   \   0000011C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011E   0x2F00             CMP      R7,#+0
   \   00000120   0xD123             BNE.N    ??CRYP_AES_ECB_5
    172            {
    173              /* Flush IN/OUT FIFOs */
    174              CRYP_FIFOFlush();
   \   00000122   0x.... 0x....      BL       CRYP_FIFOFlush
    175          
    176              /* Crypto Init for Key preparation for decryption process */
    177              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   00000126   0x2004             MOVS     R0,#+4
   \   00000128   0x9001             STR      R0,[SP, #+4]
    178              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
   \   0000012A   0x2038             MOVS     R0,#+56
   \   0000012C   0x9002             STR      R0,[SP, #+8]
    179              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x9003             STR      R0,[SP, #+12]
    180              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000132   0xA801             ADD      R0,SP,#+4
   \   00000134   0x.... 0x....      BL       CRYP_Init
    181          
    182              /* Key Initialisation */
    183              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   00000138   0xA805             ADD      R0,SP,#+20
   \   0000013A   0x.... 0x....      BL       CRYP_KeyInit
    184          
    185              /* Enable Crypto processor */
    186              CRYP_Cmd(ENABLE);
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0x.... 0x....      BL       CRYP_Cmd
    187          
    188              /* wait until the Busy flag is RESET */
    189              do
    190              {
    191                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_ECB_6: (+1)
   \   00000144   0x2010             MOVS     R0,#+16
   \   00000146   0x.... 0x....      BL       CRYP_GetFlagStatus
    192                counter++;
   \   0000014A   0x9900             LDR      R1,[SP, #+0]
   \   0000014C   0x1C49             ADDS     R1,R1,#+1
   \   0000014E   0x9100             STR      R1,[SP, #+0]
    193              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000150   0x9900             LDR      R1,[SP, #+0]
   \   00000152   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000156   0xD001             BEQ.N    ??CRYP_AES_ECB_7
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD1F3             BNE.N    ??CRYP_AES_ECB_6
    194          
    195              if (busystatus != RESET)
   \                     ??CRYP_AES_ECB_7: (+1)
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD001             BEQ.N    ??CRYP_AES_ECB_8
    196             {
    197                 status = ERROR;
   \   00000160   0x2500             MOVS     R5,#+0
   \   00000162   0xE007             B.N      ??CRYP_AES_ECB_9
    198              }
    199              else
    200              {
    201                /* Crypto Init for decryption process */  
    202                AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_AES_ECB_8: (+1)
   \   00000164   0x2004             MOVS     R0,#+4
   \   00000166   0x9001             STR      R0,[SP, #+4]
   \   00000168   0xE004             B.N      ??CRYP_AES_ECB_9
    203              }
    204            }
    205            /*------------------ AES Encryption ------------------*/
    206            else /* AES encryption */
    207            {
    208          
    209              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \                     ??CRYP_AES_ECB_5: (+1)
   \   0000016A   0xA805             ADD      R0,SP,#+20
   \   0000016C   0x.... 0x....      BL       CRYP_KeyInit
    210          
    211              /* Crypto Init for Encryption process */
    212              AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x9001             STR      R0,[SP, #+4]
    213            }
    214          
    215            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
   \                     ??CRYP_AES_ECB_9: (+1)
   \   00000174   0x2020             MOVS     R0,#+32
   \   00000176   0x9002             STR      R0,[SP, #+8]
    216            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000178   0x2080             MOVS     R0,#+128
   \   0000017A   0x9003             STR      R0,[SP, #+12]
    217            CRYP_Init(&AES_CRYP_InitStructure);
   \   0000017C   0xA801             ADD      R0,SP,#+4
   \   0000017E   0x.... 0x....      BL       CRYP_Init
    218          
    219            /* Flush IN/OUT FIFOs */
    220            CRYP_FIFOFlush();
   \   00000182   0x.... 0x....      BL       CRYP_FIFOFlush
    221          
    222            /* Enable Crypto processor */
    223            CRYP_Cmd(ENABLE);
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x.... 0x....      BL       CRYP_Cmd
    224          
    225            if(CRYP_GetCmdStatus() == DISABLE)
   \   0000018C   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xD101             BNE.N    ??CRYP_AES_ECB_10
    226            {
    227              /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    228                 the CRYP peripheral (please check the device sales type. */
    229              return(ERROR);
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0xE041             B.N      ??CRYP_AES_ECB_11
    230            }
    231            
    232            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
   \                     ??CRYP_AES_ECB_10: (+1)
   \   00000198   0xF05F 0x0900      MOVS     R9,#+0
   \   0000019C   0x9F16             LDR      R7,[SP, #+88]
   \   0000019E   0xE011             B.N      ??CRYP_AES_ECB_12
    233            {
    234          
    235              /* Write the Input block in the IN FIFO */
    236              CRYP_DataIn(*(uint32_t*)(inputaddr));
    237              inputaddr+=4;
    238              CRYP_DataIn(*(uint32_t*)(inputaddr));
    239              inputaddr+=4;
    240              CRYP_DataIn(*(uint32_t*)(inputaddr));
    241              inputaddr+=4;
    242              CRYP_DataIn(*(uint32_t*)(inputaddr));
    243              inputaddr+=4;
    244          
    245              /* Wait until the complete message has been processed */
    246              counter = 0;
    247              do
    248              {
    249                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    250                counter++;
    251              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    252          
    253              if (busystatus != RESET)
    254             {
    255                 status = ERROR;
    256              }
    257              else
    258              {
    259          
    260                /* Read the Output block from the Output FIFO */
    261                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_ECB_13: (+1)
   \   000001A0   0x.... 0x....      BL       CRYP_DataOut
   \   000001A4   0x6030             STR      R0,[R6, #+0]
    262                outputaddr+=4;
   \   000001A6   0x1D36             ADDS     R6,R6,#+4
    263                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000001A8   0x.... 0x....      BL       CRYP_DataOut
   \   000001AC   0x6030             STR      R0,[R6, #+0]
    264                outputaddr+=4;
   \   000001AE   0x1D36             ADDS     R6,R6,#+4
    265                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000001B0   0x.... 0x....      BL       CRYP_DataOut
   \   000001B4   0x6030             STR      R0,[R6, #+0]
    266                outputaddr+=4;
   \   000001B6   0x1D36             ADDS     R6,R6,#+4
    267                *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
   \   000001B8   0x.... 0x....      BL       CRYP_DataOut
   \   000001BC   0x6030             STR      R0,[R6, #+0]
    268                outputaddr+=4;
   \   000001BE   0x1D36             ADDS     R6,R6,#+4
    269              }
   \                     ??CRYP_AES_ECB_14: (+1)
   \   000001C0   0xF119 0x0910      ADDS     R9,R9,#+16
   \                     ??CRYP_AES_ECB_12: (+1)
   \   000001C4   0x45B9             CMP      R9,R7
   \   000001C6   0xD224             BCS.N    ??CRYP_AES_ECB_15
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0x2D00             CMP      R5,#+0
   \   000001CC   0xD021             BEQ.N    ??CRYP_AES_ECB_15
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x.... 0x....      BL       CRYP_DataIn
   \   000001D4   0x1D24             ADDS     R4,R4,#+4
   \   000001D6   0x6820             LDR      R0,[R4, #+0]
   \   000001D8   0x.... 0x....      BL       CRYP_DataIn
   \   000001DC   0x1D24             ADDS     R4,R4,#+4
   \   000001DE   0x6820             LDR      R0,[R4, #+0]
   \   000001E0   0x.... 0x....      BL       CRYP_DataIn
   \   000001E4   0x1D24             ADDS     R4,R4,#+4
   \   000001E6   0x6820             LDR      R0,[R4, #+0]
   \   000001E8   0x.... 0x....      BL       CRYP_DataIn
   \   000001EC   0x1D24             ADDS     R4,R4,#+4
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_ECB_16: (+1)
   \   000001F2   0x2010             MOVS     R0,#+16
   \   000001F4   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000001F8   0x9900             LDR      R1,[SP, #+0]
   \   000001FA   0x1C49             ADDS     R1,R1,#+1
   \   000001FC   0x9100             STR      R1,[SP, #+0]
   \   000001FE   0x9900             LDR      R1,[SP, #+0]
   \   00000200   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000204   0xD001             BEQ.N    ??CRYP_AES_ECB_17
   \   00000206   0x2800             CMP      R0,#+0
   \   00000208   0xD1F3             BNE.N    ??CRYP_AES_ECB_16
   \                     ??CRYP_AES_ECB_17: (+1)
   \   0000020A   0x2800             CMP      R0,#+0
   \   0000020C   0xD0C8             BEQ.N    ??CRYP_AES_ECB_13
   \   0000020E   0x2500             MOVS     R5,#+0
   \   00000210   0xE7D6             B.N      ??CRYP_AES_ECB_14
    270            }
    271          
    272            /* Disable Crypto */
    273            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_ECB_15: (+1)
   \   00000212   0x2000             MOVS     R0,#+0
   \   00000214   0x.... 0x....      BL       CRYP_Cmd
    274          
    275            return status; 
   \   00000218   0x0028             MOVS     R0,R5
   \   0000021A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_ECB_11: (+1)
   \   0000021C   0xB00E             ADD      SP,SP,#+56
   \   0000021E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    276          }
    277          
    278          /**
    279            * @brief  Encrypt and decrypt using AES in CBC Mode
    280            * @param  Mode: encryption or decryption Mode.
    281            *          This parameter can be one of the following values:
    282            *            @arg MODE_ENCRYPT: Encryption
    283            *            @arg MODE_DECRYPT: Decryption
    284            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    285            * @param  Key: Key used for AES algorithm.
    286            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    287            * @param  Input: pointer to the Input buffer.
    288            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    289            * @param  Output: pointer to the returned buffer.
    290            * @retval An ErrorStatus enumeration value:
    291            *          - SUCCESS: Operation done
    292            *          - ERROR: Operation failed
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
    295                                   uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
    296                                   uint8_t *Output)
    297          {
   \                     CRYP_AES_CBC: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x469B             MOV      R11,R3
    298            CRYP_InitTypeDef AES_CRYP_InitStructure;
    299            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    300            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    301            __IO uint32_t counter = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    302            uint32_t busystatus = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
    303            ErrorStatus status = SUCCESS;
   \   00000010   0x2601             MOVS     R6,#+1
    304            uint32_t keyaddr    = (uint32_t)Key;
   \   00000012   0x0015             MOVS     R5,R2
    305            uint32_t inputaddr  = (uint32_t)Input;
   \   00000014   0x9F1A             LDR      R7,[SP, #+104]
    306            uint32_t outputaddr = (uint32_t)Output;
   \   00000016   0xF8DD 0x8070      LDR      R8,[SP, #+112]
    307            uint32_t ivaddr = (uint32_t)InitVectors;
   \   0000001A   0x000C             MOVS     R4,R1
    308            uint32_t i = 0;
   \   0000001C   0xF05F 0x0900      MOVS     R9,#+0
    309          
    310            /* Crypto structures initialisation*/
    311            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   00000020   0xA805             ADD      R0,SP,#+20
   \   00000022   0x.... 0x....      BL       CRYP_KeyStructInit
    312          
    313            switch(Keysize)
   \   00000026   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000002A   0xF1BB 0x0F80      CMP      R11,#+128
   \   0000002E   0xD006             BEQ.N    ??CRYP_AES_CBC_0
   \   00000030   0xF1BB 0x0FC0      CMP      R11,#+192
   \   00000034   0xD015             BEQ.N    ??CRYP_AES_CBC_1
   \   00000036   0xF5BB 0x7F80      CMP      R11,#+256
   \   0000003A   0xD02D             BEQ.N    ??CRYP_AES_CBC_2
   \   0000003C   0xE04F             B.N      ??CRYP_AES_CBC_3
    314            {
    315              case 128:
    316              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CBC_0: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9004             STR      R0,[SP, #+16]
    317              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xBA00             REV      R0,R0
   \   00000046   0x9009             STR      R0,[SP, #+36]
    318              keyaddr+=4;
   \   00000048   0x1D2D             ADDS     R5,R5,#+4
    319              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0xBA00             REV      R0,R0
   \   0000004E   0x900A             STR      R0,[SP, #+40]
    320              keyaddr+=4;
   \   00000050   0x1D2D             ADDS     R5,R5,#+4
    321              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000052   0x6828             LDR      R0,[R5, #+0]
   \   00000054   0xBA00             REV      R0,R0
   \   00000056   0x900B             STR      R0,[SP, #+44]
    322              keyaddr+=4;
   \   00000058   0x1D2D             ADDS     R5,R5,#+4
    323              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0xBA00             REV      R0,R0
   \   0000005E   0x900C             STR      R0,[SP, #+48]
    324              break;
   \   00000060   0xE03D             B.N      ??CRYP_AES_CBC_4
    325              case 192:
    326              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CBC_1: (+1)
   \   00000062   0xF44F 0x7080      MOV      R0,#+256
   \   00000066   0x9004             STR      R0,[SP, #+16]
    327              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0xBA00             REV      R0,R0
   \   0000006C   0x9007             STR      R0,[SP, #+28]
    328              keyaddr+=4;
   \   0000006E   0x1D2D             ADDS     R5,R5,#+4
    329              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0xBA00             REV      R0,R0
   \   00000074   0x9008             STR      R0,[SP, #+32]
    330              keyaddr+=4;
   \   00000076   0x1D2D             ADDS     R5,R5,#+4
    331              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0xBA00             REV      R0,R0
   \   0000007C   0x9009             STR      R0,[SP, #+36]
    332              keyaddr+=4;
   \   0000007E   0x1D2D             ADDS     R5,R5,#+4
    333              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0xBA00             REV      R0,R0
   \   00000084   0x900A             STR      R0,[SP, #+40]
    334              keyaddr+=4;
   \   00000086   0x1D2D             ADDS     R5,R5,#+4
    335              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0xBA00             REV      R0,R0
   \   0000008C   0x900B             STR      R0,[SP, #+44]
    336              keyaddr+=4;
   \   0000008E   0x1D2D             ADDS     R5,R5,#+4
    337              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000090   0x6828             LDR      R0,[R5, #+0]
   \   00000092   0xBA00             REV      R0,R0
   \   00000094   0x900C             STR      R0,[SP, #+48]
    338              break;
   \   00000096   0xE022             B.N      ??CRYP_AES_CBC_4
    339              case 256:
    340              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CBC_2: (+1)
   \   00000098   0xF44F 0x7000      MOV      R0,#+512
   \   0000009C   0x9004             STR      R0,[SP, #+16]
    341              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0xBA00             REV      R0,R0
   \   000000A2   0x9005             STR      R0,[SP, #+20]
    342              keyaddr+=4;
   \   000000A4   0x1D2D             ADDS     R5,R5,#+4
    343              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0xBA00             REV      R0,R0
   \   000000AA   0x9006             STR      R0,[SP, #+24]
    344              keyaddr+=4;
   \   000000AC   0x1D2D             ADDS     R5,R5,#+4
    345              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0xBA00             REV      R0,R0
   \   000000B2   0x9007             STR      R0,[SP, #+28]
    346              keyaddr+=4;
   \   000000B4   0x1D2D             ADDS     R5,R5,#+4
    347              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0xBA00             REV      R0,R0
   \   000000BA   0x9008             STR      R0,[SP, #+32]
    348              keyaddr+=4;
   \   000000BC   0x1D2D             ADDS     R5,R5,#+4
    349              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xBA00             REV      R0,R0
   \   000000C2   0x9009             STR      R0,[SP, #+36]
    350              keyaddr+=4;
   \   000000C4   0x1D2D             ADDS     R5,R5,#+4
    351              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000C6   0x6828             LDR      R0,[R5, #+0]
   \   000000C8   0xBA00             REV      R0,R0
   \   000000CA   0x900A             STR      R0,[SP, #+40]
    352              keyaddr+=4;
   \   000000CC   0x1D2D             ADDS     R5,R5,#+4
    353              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0xBA00             REV      R0,R0
   \   000000D2   0x900B             STR      R0,[SP, #+44]
    354              keyaddr+=4;
   \   000000D4   0x1D2D             ADDS     R5,R5,#+4
    355              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0xBA00             REV      R0,R0
   \   000000DA   0x900C             STR      R0,[SP, #+48]
    356              break;
   \   000000DC   0xE7FF             B.N      ??CRYP_AES_CBC_4
    357              default:
    358              break;
    359            }
    360          
    361            /* CRYP Initialization Vectors */
    362            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_CBC_3: (+1)
   \                     ??CRYP_AES_CBC_4: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0xBA00             REV      R0,R0
   \   000000E2   0x900D             STR      R0,[SP, #+52]
    363            ivaddr+=4;
   \   000000E4   0x1D24             ADDS     R4,R4,#+4
    364            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0xBA00             REV      R0,R0
   \   000000EA   0x900E             STR      R0,[SP, #+56]
    365            ivaddr+=4;
   \   000000EC   0x1D24             ADDS     R4,R4,#+4
    366            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0xBA00             REV      R0,R0
   \   000000F2   0x900F             STR      R0,[SP, #+60]
    367            ivaddr+=4;
   \   000000F4   0x1D24             ADDS     R4,R4,#+4
    368            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0xBA00             REV      R0,R0
   \   000000FA   0x9010             STR      R0,[SP, #+64]
    369          
    370          
    371            /*------------------ AES Decryption ------------------*/
    372            if(Mode == MODE_DECRYPT) /* AES decryption */
   \   000000FC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000100   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000104   0xD123             BNE.N    ??CRYP_AES_CBC_5
    373            {
    374              /* Flush IN/OUT FIFOs */
    375              CRYP_FIFOFlush();
   \   00000106   0x.... 0x....      BL       CRYP_FIFOFlush
    376          
    377              /* Crypto Init for Key preparation for decryption process */
    378              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   0000010A   0x2004             MOVS     R0,#+4
   \   0000010C   0x9001             STR      R0,[SP, #+4]
    379              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
   \   0000010E   0x2038             MOVS     R0,#+56
   \   00000110   0x9002             STR      R0,[SP, #+8]
    380              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x9003             STR      R0,[SP, #+12]
    381          
    382              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000116   0xA801             ADD      R0,SP,#+4
   \   00000118   0x.... 0x....      BL       CRYP_Init
    383          
    384              /* Key Initialisation */
    385              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   0000011C   0xA805             ADD      R0,SP,#+20
   \   0000011E   0x.... 0x....      BL       CRYP_KeyInit
    386          
    387              /* Enable Crypto processor */
    388              CRYP_Cmd(ENABLE);
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x.... 0x....      BL       CRYP_Cmd
    389          
    390              /* wait until the Busy flag is RESET */
    391              do
    392              {
    393                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CBC_6: (+1)
   \   00000128   0x2010             MOVS     R0,#+16
   \   0000012A   0x.... 0x....      BL       CRYP_GetFlagStatus
    394                counter++;
   \   0000012E   0x9900             LDR      R1,[SP, #+0]
   \   00000130   0x1C49             ADDS     R1,R1,#+1
   \   00000132   0x9100             STR      R1,[SP, #+0]
    395              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000134   0x9900             LDR      R1,[SP, #+0]
   \   00000136   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000013A   0xD001             BEQ.N    ??CRYP_AES_CBC_7
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD1F3             BNE.N    ??CRYP_AES_CBC_6
    396          
    397              if (busystatus != RESET)
   \                     ??CRYP_AES_CBC_7: (+1)
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD001             BEQ.N    ??CRYP_AES_CBC_8
    398             {
    399                 status = ERROR;
   \   00000144   0x2600             MOVS     R6,#+0
   \   00000146   0xE007             B.N      ??CRYP_AES_CBC_9
    400              }
    401              else
    402              {
    403                /* Crypto Init for decryption process */  
    404                AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_AES_CBC_8: (+1)
   \   00000148   0x2004             MOVS     R0,#+4
   \   0000014A   0x9001             STR      R0,[SP, #+4]
   \   0000014C   0xE004             B.N      ??CRYP_AES_CBC_9
    405              }
    406            }
    407            /*------------------ AES Encryption ------------------*/
    408            else /* AES encryption */
    409            {
    410              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \                     ??CRYP_AES_CBC_5: (+1)
   \   0000014E   0xA805             ADD      R0,SP,#+20
   \   00000150   0x.... 0x....      BL       CRYP_KeyInit
    411          
    412              /* Crypto Init for Encryption process */
    413              AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x9001             STR      R0,[SP, #+4]
    414            }
    415            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
   \                     ??CRYP_AES_CBC_9: (+1)
   \   00000158   0x2028             MOVS     R0,#+40
   \   0000015A   0x9002             STR      R0,[SP, #+8]
    416            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   0000015C   0x2080             MOVS     R0,#+128
   \   0000015E   0x9003             STR      R0,[SP, #+12]
    417            CRYP_Init(&AES_CRYP_InitStructure);
   \   00000160   0xA801             ADD      R0,SP,#+4
   \   00000162   0x.... 0x....      BL       CRYP_Init
    418          
    419            /* CRYP Initialization Vectors */
    420            CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000166   0xA80D             ADD      R0,SP,#+52
   \   00000168   0x.... 0x....      BL       CRYP_IVInit
    421          
    422            /* Flush IN/OUT FIFOs */
    423            CRYP_FIFOFlush();
   \   0000016C   0x.... 0x....      BL       CRYP_FIFOFlush
    424          
    425            /* Enable Crypto processor */
    426            CRYP_Cmd(ENABLE);
   \   00000170   0x2001             MOVS     R0,#+1
   \   00000172   0x.... 0x....      BL       CRYP_Cmd
    427          
    428            if(CRYP_GetCmdStatus() == DISABLE)
   \   00000176   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000017A   0x2800             CMP      R0,#+0
   \   0000017C   0xD101             BNE.N    ??CRYP_AES_CBC_10
    429            {
    430              /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    431                 the CRYP peripheral (please check the device sales type. */
    432              return(ERROR);
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0xE049             B.N      ??CRYP_AES_CBC_11
    433            }
    434            
    435            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
   \                     ??CRYP_AES_CBC_10: (+1)
   \   00000182   0xF05F 0x0900      MOVS     R9,#+0
   \   00000186   0x9C1B             LDR      R4,[SP, #+108]
   \   00000188   0xE019             B.N      ??CRYP_AES_CBC_12
    436            {
    437          
    438              /* Write the Input block in the IN FIFO */
    439              CRYP_DataIn(*(uint32_t*)(inputaddr));
    440              inputaddr+=4;
    441              CRYP_DataIn(*(uint32_t*)(inputaddr));
    442              inputaddr+=4;
    443              CRYP_DataIn(*(uint32_t*)(inputaddr));
    444              inputaddr+=4;
    445              CRYP_DataIn(*(uint32_t*)(inputaddr));
    446              inputaddr+=4;
    447              /* Wait until the complete message has been processed */
    448              counter = 0;
    449              do
    450              {
    451                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    452                counter++;
    453              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    454          
    455              if (busystatus != RESET)
    456             {
    457                 status = ERROR;
    458              }
    459              else
    460              {
    461          
    462                /* Read the Output block from the Output FIFO */
    463                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_CBC_13: (+1)
   \   0000018A   0x.... 0x....      BL       CRYP_DataOut
   \   0000018E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    464                outputaddr+=4;
   \   00000192   0xF118 0x0804      ADDS     R8,R8,#+4
    465                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000196   0x.... 0x....      BL       CRYP_DataOut
   \   0000019A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    466                outputaddr+=4;
   \   0000019E   0xF118 0x0804      ADDS     R8,R8,#+4
    467                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000001A2   0x.... 0x....      BL       CRYP_DataOut
   \   000001A6   0xF8C8 0x0000      STR      R0,[R8, #+0]
    468                outputaddr+=4;
   \   000001AA   0xF118 0x0804      ADDS     R8,R8,#+4
    469                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000001AE   0x.... 0x....      BL       CRYP_DataOut
   \   000001B2   0xF8C8 0x0000      STR      R0,[R8, #+0]
    470                outputaddr+=4;
   \   000001B6   0xF118 0x0804      ADDS     R8,R8,#+4
    471              }
   \                     ??CRYP_AES_CBC_14: (+1)
   \   000001BA   0xF119 0x0910      ADDS     R9,R9,#+16
   \                     ??CRYP_AES_CBC_12: (+1)
   \   000001BE   0x45A1             CMP      R9,R4
   \   000001C0   0xD224             BCS.N    ??CRYP_AES_CBC_15
   \   000001C2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001C4   0x2E00             CMP      R6,#+0
   \   000001C6   0xD021             BEQ.N    ??CRYP_AES_CBC_15
   \   000001C8   0x6838             LDR      R0,[R7, #+0]
   \   000001CA   0x.... 0x....      BL       CRYP_DataIn
   \   000001CE   0x1D3F             ADDS     R7,R7,#+4
   \   000001D0   0x6838             LDR      R0,[R7, #+0]
   \   000001D2   0x.... 0x....      BL       CRYP_DataIn
   \   000001D6   0x1D3F             ADDS     R7,R7,#+4
   \   000001D8   0x6838             LDR      R0,[R7, #+0]
   \   000001DA   0x.... 0x....      BL       CRYP_DataIn
   \   000001DE   0x1D3F             ADDS     R7,R7,#+4
   \   000001E0   0x6838             LDR      R0,[R7, #+0]
   \   000001E2   0x.... 0x....      BL       CRYP_DataIn
   \   000001E6   0x1D3F             ADDS     R7,R7,#+4
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CBC_16: (+1)
   \   000001EC   0x2010             MOVS     R0,#+16
   \   000001EE   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000001F2   0x9900             LDR      R1,[SP, #+0]
   \   000001F4   0x1C49             ADDS     R1,R1,#+1
   \   000001F6   0x9100             STR      R1,[SP, #+0]
   \   000001F8   0x9900             LDR      R1,[SP, #+0]
   \   000001FA   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001FE   0xD001             BEQ.N    ??CRYP_AES_CBC_17
   \   00000200   0x2800             CMP      R0,#+0
   \   00000202   0xD1F3             BNE.N    ??CRYP_AES_CBC_16
   \                     ??CRYP_AES_CBC_17: (+1)
   \   00000204   0x2800             CMP      R0,#+0
   \   00000206   0xD0C0             BEQ.N    ??CRYP_AES_CBC_13
   \   00000208   0x2600             MOVS     R6,#+0
   \   0000020A   0xE7D6             B.N      ??CRYP_AES_CBC_14
    472            }
    473          
    474            /* Disable Crypto */
    475            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_CBC_15: (+1)
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0x.... 0x....      BL       CRYP_Cmd
    476          
    477            return status;
   \   00000212   0x0030             MOVS     R0,R6
   \   00000214   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_CBC_11: (+1)
   \   00000216   0xB011             ADD      SP,SP,#+68
   \   00000218   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    478          }
    479          
    480          /**
    481            * @brief  Encrypt and decrypt using AES in CTR Mode
    482            * @param  Mode: encryption or decryption Mode.
    483            *           This parameter can be one of the following values:
    484            *            @arg MODE_ENCRYPT: Encryption
    485            *            @arg MODE_DECRYPT: Decryption
    486            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    487            * @param  Key: Key used for AES algorithm.
    488            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    489            * @param  Input: pointer to the Input buffer.
    490            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    491            * @param  Output: pointer to the returned buffer.
    492            * @retval An ErrorStatus enumeration value:
    493            *          - SUCCESS: Operation done
    494            *          - ERROR: Operation failed
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
    497                                   uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
    498                                   uint8_t *Output)
    499          {
   \                     CRYP_AES_CTR: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x469B             MOV      R11,R3
    500            CRYP_InitTypeDef AES_CRYP_InitStructure;
    501            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    502            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    503            __IO uint32_t counter = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    504            uint32_t busystatus = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
    505            ErrorStatus status = SUCCESS;
   \   00000010   0x2601             MOVS     R6,#+1
    506            uint32_t keyaddr    = (uint32_t)Key;
   \   00000012   0x0015             MOVS     R5,R2
    507            uint32_t inputaddr  = (uint32_t)Input;
   \   00000014   0x9F1A             LDR      R7,[SP, #+104]
    508            uint32_t outputaddr = (uint32_t)Output;
   \   00000016   0xF8DD 0x8070      LDR      R8,[SP, #+112]
    509            uint32_t ivaddr     = (uint32_t)InitVectors;
   \   0000001A   0x000C             MOVS     R4,R1
    510            uint32_t i = 0;
   \   0000001C   0xF05F 0x0900      MOVS     R9,#+0
    511          
    512            /* Crypto structures initialisation*/
    513            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       CRYP_KeyStructInit
    514          
    515            switch(Keysize)
   \   00000026   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000002A   0xF1BB 0x0F80      CMP      R11,#+128
   \   0000002E   0xD006             BEQ.N    ??CRYP_AES_CTR_0
   \   00000030   0xF1BB 0x0FC0      CMP      R11,#+192
   \   00000034   0xD015             BEQ.N    ??CRYP_AES_CTR_1
   \   00000036   0xF5BB 0x7F80      CMP      R11,#+256
   \   0000003A   0xD02D             BEQ.N    ??CRYP_AES_CTR_2
   \   0000003C   0xE04F             B.N      ??CRYP_AES_CTR_3
    516            {
    517              case 128:
    518              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CTR_0: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x900C             STR      R0,[SP, #+48]
    519              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xBA00             REV      R0,R0
   \   00000046   0x9005             STR      R0,[SP, #+20]
    520              keyaddr+=4;
   \   00000048   0x1D2D             ADDS     R5,R5,#+4
    521              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0xBA00             REV      R0,R0
   \   0000004E   0x9006             STR      R0,[SP, #+24]
    522              keyaddr+=4;
   \   00000050   0x1D2D             ADDS     R5,R5,#+4
    523              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000052   0x6828             LDR      R0,[R5, #+0]
   \   00000054   0xBA00             REV      R0,R0
   \   00000056   0x9007             STR      R0,[SP, #+28]
    524              keyaddr+=4;
   \   00000058   0x1D2D             ADDS     R5,R5,#+4
    525              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0xBA00             REV      R0,R0
   \   0000005E   0x9008             STR      R0,[SP, #+32]
    526              break;
   \   00000060   0xE03D             B.N      ??CRYP_AES_CTR_4
    527              case 192:
    528              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CTR_1: (+1)
   \   00000062   0xF44F 0x7080      MOV      R0,#+256
   \   00000066   0x900C             STR      R0,[SP, #+48]
    529              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0xBA00             REV      R0,R0
   \   0000006C   0x9003             STR      R0,[SP, #+12]
    530              keyaddr+=4;
   \   0000006E   0x1D2D             ADDS     R5,R5,#+4
    531              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0xBA00             REV      R0,R0
   \   00000074   0x9004             STR      R0,[SP, #+16]
    532              keyaddr+=4;
   \   00000076   0x1D2D             ADDS     R5,R5,#+4
    533              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0xBA00             REV      R0,R0
   \   0000007C   0x9005             STR      R0,[SP, #+20]
    534              keyaddr+=4;
   \   0000007E   0x1D2D             ADDS     R5,R5,#+4
    535              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0xBA00             REV      R0,R0
   \   00000084   0x9006             STR      R0,[SP, #+24]
    536              keyaddr+=4;
   \   00000086   0x1D2D             ADDS     R5,R5,#+4
    537              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0xBA00             REV      R0,R0
   \   0000008C   0x9007             STR      R0,[SP, #+28]
    538              keyaddr+=4;
   \   0000008E   0x1D2D             ADDS     R5,R5,#+4
    539              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000090   0x6828             LDR      R0,[R5, #+0]
   \   00000092   0xBA00             REV      R0,R0
   \   00000094   0x9008             STR      R0,[SP, #+32]
    540              break;
   \   00000096   0xE022             B.N      ??CRYP_AES_CTR_4
    541              case 256:
    542              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CTR_2: (+1)
   \   00000098   0xF44F 0x7000      MOV      R0,#+512
   \   0000009C   0x900C             STR      R0,[SP, #+48]
    543              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0xBA00             REV      R0,R0
   \   000000A2   0x9001             STR      R0,[SP, #+4]
    544              keyaddr+=4;
   \   000000A4   0x1D2D             ADDS     R5,R5,#+4
    545              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0xBA00             REV      R0,R0
   \   000000AA   0x9002             STR      R0,[SP, #+8]
    546              keyaddr+=4;
   \   000000AC   0x1D2D             ADDS     R5,R5,#+4
    547              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0xBA00             REV      R0,R0
   \   000000B2   0x9003             STR      R0,[SP, #+12]
    548              keyaddr+=4;
   \   000000B4   0x1D2D             ADDS     R5,R5,#+4
    549              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0xBA00             REV      R0,R0
   \   000000BA   0x9004             STR      R0,[SP, #+16]
    550              keyaddr+=4;
   \   000000BC   0x1D2D             ADDS     R5,R5,#+4
    551              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xBA00             REV      R0,R0
   \   000000C2   0x9005             STR      R0,[SP, #+20]
    552              keyaddr+=4;
   \   000000C4   0x1D2D             ADDS     R5,R5,#+4
    553              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000C6   0x6828             LDR      R0,[R5, #+0]
   \   000000C8   0xBA00             REV      R0,R0
   \   000000CA   0x9006             STR      R0,[SP, #+24]
    554              keyaddr+=4;
   \   000000CC   0x1D2D             ADDS     R5,R5,#+4
    555              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0xBA00             REV      R0,R0
   \   000000D2   0x9007             STR      R0,[SP, #+28]
    556              keyaddr+=4;
   \   000000D4   0x1D2D             ADDS     R5,R5,#+4
    557              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0xBA00             REV      R0,R0
   \   000000DA   0x9008             STR      R0,[SP, #+32]
    558              break;
   \   000000DC   0xE7FF             B.N      ??CRYP_AES_CTR_4
    559              default:
    560              break;
    561            }
    562            /* CRYP Initialization Vectors */
    563            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_CTR_3: (+1)
   \                     ??CRYP_AES_CTR_4: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0xBA00             REV      R0,R0
   \   000000E2   0x900D             STR      R0,[SP, #+52]
    564            ivaddr+=4;
   \   000000E4   0x1D24             ADDS     R4,R4,#+4
    565            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0xBA00             REV      R0,R0
   \   000000EA   0x900E             STR      R0,[SP, #+56]
    566            ivaddr+=4;
   \   000000EC   0x1D24             ADDS     R4,R4,#+4
    567            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0xBA00             REV      R0,R0
   \   000000F2   0x900F             STR      R0,[SP, #+60]
    568            ivaddr+=4;
   \   000000F4   0x1D24             ADDS     R4,R4,#+4
    569            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0xBA00             REV      R0,R0
   \   000000FA   0x9010             STR      R0,[SP, #+64]
    570          
    571            /* Key Initialisation */
    572            CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   000000FC   0xA801             ADD      R0,SP,#+4
   \   000000FE   0x.... 0x....      BL       CRYP_KeyInit
    573          
    574            /*------------------ AES Decryption ------------------*/
    575            if(Mode == MODE_DECRYPT) /* AES decryption */
   \   00000102   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000106   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000010A   0xD102             BNE.N    ??CRYP_AES_CTR_5
    576            {
    577              /* Crypto Init for decryption process */
    578              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   0000010C   0x2004             MOVS     R0,#+4
   \   0000010E   0x9009             STR      R0,[SP, #+36]
   \   00000110   0xE001             B.N      ??CRYP_AES_CTR_6
    579            }
    580            /*------------------ AES Encryption ------------------*/
    581            else /* AES encryption */
    582            {
    583              /* Crypto Init for Encryption process */
    584              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \                     ??CRYP_AES_CTR_5: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x9009             STR      R0,[SP, #+36]
    585            }
    586            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
   \                     ??CRYP_AES_CTR_6: (+1)
   \   00000116   0x2030             MOVS     R0,#+48
   \   00000118   0x900A             STR      R0,[SP, #+40]
    587            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   0000011A   0x2080             MOVS     R0,#+128
   \   0000011C   0x900B             STR      R0,[SP, #+44]
    588            CRYP_Init(&AES_CRYP_InitStructure);
   \   0000011E   0xA809             ADD      R0,SP,#+36
   \   00000120   0x.... 0x....      BL       CRYP_Init
    589          
    590            /* CRYP Initialization Vectors */
    591            CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000124   0xA80D             ADD      R0,SP,#+52
   \   00000126   0x.... 0x....      BL       CRYP_IVInit
    592          
    593            /* Flush IN/OUT FIFOs */
    594            CRYP_FIFOFlush();
   \   0000012A   0x.... 0x....      BL       CRYP_FIFOFlush
    595          
    596            /* Enable Crypto processor */
    597            CRYP_Cmd(ENABLE);
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x.... 0x....      BL       CRYP_Cmd
    598          
    599            if(CRYP_GetCmdStatus() == DISABLE)
   \   00000134   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD101             BNE.N    ??CRYP_AES_CTR_7
    600            {
    601              /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    602                 the CRYP peripheral (please check the device sales type. */
    603              return(ERROR);
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0xE049             B.N      ??CRYP_AES_CTR_8
    604            }
    605            
    606            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
   \                     ??CRYP_AES_CTR_7: (+1)
   \   00000140   0xF05F 0x0900      MOVS     R9,#+0
   \   00000144   0x9C1B             LDR      R4,[SP, #+108]
   \   00000146   0xE019             B.N      ??CRYP_AES_CTR_9
    607            {
    608          
    609              /* Write the Input block in the IN FIFO */
    610              CRYP_DataIn(*(uint32_t*)(inputaddr));
    611              inputaddr+=4;
    612              CRYP_DataIn(*(uint32_t*)(inputaddr));
    613              inputaddr+=4;
    614              CRYP_DataIn(*(uint32_t*)(inputaddr));
    615              inputaddr+=4;
    616              CRYP_DataIn(*(uint32_t*)(inputaddr));
    617              inputaddr+=4;
    618              /* Wait until the complete message has been processed */
    619              counter = 0;
    620              do
    621              {
    622                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    623                counter++;
    624              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    625          
    626              if (busystatus != RESET)
    627             {
    628                 status = ERROR;
    629              }
    630              else
    631              {
    632          
    633                /* Read the Output block from the Output FIFO */
    634                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_CTR_10: (+1)
   \   00000148   0x.... 0x....      BL       CRYP_DataOut
   \   0000014C   0xF8C8 0x0000      STR      R0,[R8, #+0]
    635                outputaddr+=4;
   \   00000150   0xF118 0x0804      ADDS     R8,R8,#+4
    636                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000154   0x.... 0x....      BL       CRYP_DataOut
   \   00000158   0xF8C8 0x0000      STR      R0,[R8, #+0]
    637                outputaddr+=4;
   \   0000015C   0xF118 0x0804      ADDS     R8,R8,#+4
    638                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000160   0x.... 0x....      BL       CRYP_DataOut
   \   00000164   0xF8C8 0x0000      STR      R0,[R8, #+0]
    639                outputaddr+=4;
   \   00000168   0xF118 0x0804      ADDS     R8,R8,#+4
    640                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000016C   0x.... 0x....      BL       CRYP_DataOut
   \   00000170   0xF8C8 0x0000      STR      R0,[R8, #+0]
    641                outputaddr+=4;
   \   00000174   0xF118 0x0804      ADDS     R8,R8,#+4
    642              }
   \                     ??CRYP_AES_CTR_11: (+1)
   \   00000178   0xF119 0x0910      ADDS     R9,R9,#+16
   \                     ??CRYP_AES_CTR_9: (+1)
   \   0000017C   0x45A1             CMP      R9,R4
   \   0000017E   0xD224             BCS.N    ??CRYP_AES_CTR_12
   \   00000180   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000182   0x2E00             CMP      R6,#+0
   \   00000184   0xD021             BEQ.N    ??CRYP_AES_CTR_12
   \   00000186   0x6838             LDR      R0,[R7, #+0]
   \   00000188   0x.... 0x....      BL       CRYP_DataIn
   \   0000018C   0x1D3F             ADDS     R7,R7,#+4
   \   0000018E   0x6838             LDR      R0,[R7, #+0]
   \   00000190   0x.... 0x....      BL       CRYP_DataIn
   \   00000194   0x1D3F             ADDS     R7,R7,#+4
   \   00000196   0x6838             LDR      R0,[R7, #+0]
   \   00000198   0x.... 0x....      BL       CRYP_DataIn
   \   0000019C   0x1D3F             ADDS     R7,R7,#+4
   \   0000019E   0x6838             LDR      R0,[R7, #+0]
   \   000001A0   0x.... 0x....      BL       CRYP_DataIn
   \   000001A4   0x1D3F             ADDS     R7,R7,#+4
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CTR_13: (+1)
   \   000001AA   0x2010             MOVS     R0,#+16
   \   000001AC   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000001B0   0x9900             LDR      R1,[SP, #+0]
   \   000001B2   0x1C49             ADDS     R1,R1,#+1
   \   000001B4   0x9100             STR      R1,[SP, #+0]
   \   000001B6   0x9900             LDR      R1,[SP, #+0]
   \   000001B8   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001BC   0xD001             BEQ.N    ??CRYP_AES_CTR_14
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD1F3             BNE.N    ??CRYP_AES_CTR_13
   \                     ??CRYP_AES_CTR_14: (+1)
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD0C0             BEQ.N    ??CRYP_AES_CTR_10
   \   000001C6   0x2600             MOVS     R6,#+0
   \   000001C8   0xE7D6             B.N      ??CRYP_AES_CTR_11
    643            }
    644            /* Disable Crypto */
    645            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_CTR_12: (+1)
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x.... 0x....      BL       CRYP_Cmd
    646          
    647            return status;
   \   000001D0   0x0030             MOVS     R0,R6
   \   000001D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_CTR_8: (+1)
   \   000001D4   0xB011             ADD      SP,SP,#+68
   \   000001D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    648          }
    649          
    650          /**
    651            * @brief  Encrypt and decrypt using AES in GCM Mode. The GCM and CCM modes
    652            *         are available only on STM32F437x Devices.
    653            * @param  Mode: encryption or decryption Mode.
    654            *          This parameter can be one of the following values:
    655            *            @arg MODE_ENCRYPT: Encryption
    656            *            @arg MODE_DECRYPT: Decryption
    657            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    658            * @param  Key: Key used for AES algorithm.
    659            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    660            * @param  Input: pointer to the Input buffer.
    661            * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
    662            * @param  Header: pointer to the header buffer.
    663            * @param  Hlength: length of the header buffer in bytes, must be a multiple of 16.  
    664            * @param  Output: pointer to the returned buffer.
    665            * @param  AuthTAG: pointer to the authentication TAG buffer.
    666            * @retval An ErrorStatus enumeration value:
    667            *          - SUCCESS: Operation done
    668            *          - ERROR: Operation failed
    669            */

   \                                 In section .text, align 2, keep-with-next
    670          ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
    671                                   uint8_t *Key, uint16_t Keysize,
    672                                   uint8_t *Input, uint32_t ILength,
    673                                   uint8_t *Header, uint32_t HLength,
    674                                   uint8_t *Output, uint8_t *AuthTAG)
    675          {
   \                     CRYP_AES_GCM: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB097             SUB      SP,SP,#+92
    676            CRYP_InitTypeDef AES_CRYP_InitStructure;
    677            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    678            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    679            __IO uint32_t counter = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    680            uint32_t busystatus = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
    681            ErrorStatus status = SUCCESS;
   \   0000000C   0x2401             MOVS     R4,#+1
    682            uint32_t keyaddr    = (uint32_t)Key;
   \   0000000E   0x9D19             LDR      R5,[SP, #+100]
    683            uint32_t inputaddr  = (uint32_t)Input;
   \   00000010   0x9E24             LDR      R6,[SP, #+144]
    684            uint32_t outputaddr = (uint32_t)Output;
   \   00000012   0x9F28             LDR      R7,[SP, #+160]
    685            uint32_t ivaddr     = (uint32_t)InitVectors;
   \   00000014   0xF8DD 0x9060      LDR      R9,[SP, #+96]
    686            uint32_t headeraddr = (uint32_t)Header;
   \   00000018   0xF8DD 0x8098      LDR      R8,[SP, #+152]
   \   0000001C   0xF8DD 0xA0A4      LDR      R10,[SP, #+164]
    687            uint32_t tagaddr = (uint32_t)AuthTAG;
    688            uint64_t headerlength = HLength * 8;/* header length in bits */
   \   00000020   0x9827             LDR      R0,[SP, #+156]
   \   00000022   0x00C0             LSLS     R0,R0,#+3
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
    689            uint64_t inputlength = ILength * 8;/* input length in bits */
   \   0000002A   0x9825             LDR      R0,[SP, #+148]
   \   0000002C   0x00C0             LSLS     R0,R0,#+3
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
    690            uint32_t loopcounter = 0;
   \   00000034   0xF05F 0x0B00      MOVS     R11,#+0
    691          
    692            /* Crypto structures initialisation*/
    693            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   00000038   0xA80A             ADD      R0,SP,#+40
   \   0000003A   0x.... 0x....      BL       CRYP_KeyStructInit
    694          
    695            switch(Keysize)
   \   0000003E   0xF8BD 0x0068      LDRH     R0,[SP, #+104]
   \   00000042   0x2880             CMP      R0,#+128
   \   00000044   0xD005             BEQ.N    ??CRYP_AES_GCM_0
   \   00000046   0x28C0             CMP      R0,#+192
   \   00000048   0xD015             BEQ.N    ??CRYP_AES_GCM_1
   \   0000004A   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004E   0xD02D             BEQ.N    ??CRYP_AES_GCM_2
   \   00000050   0xE04F             B.N      ??CRYP_AES_GCM_3
    696            {
    697              case 128:
    698              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_GCM_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x9009             STR      R0,[SP, #+36]
    699              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0xBA00             REV      R0,R0
   \   0000005A   0x900E             STR      R0,[SP, #+56]
    700              keyaddr+=4;
   \   0000005C   0x1D2D             ADDS     R5,R5,#+4
    701              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   0000005E   0x6828             LDR      R0,[R5, #+0]
   \   00000060   0xBA00             REV      R0,R0
   \   00000062   0x900F             STR      R0,[SP, #+60]
    702              keyaddr+=4;
   \   00000064   0x1D2D             ADDS     R5,R5,#+4
    703              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0xBA00             REV      R0,R0
   \   0000006A   0x9010             STR      R0,[SP, #+64]
    704              keyaddr+=4;
   \   0000006C   0x1D2D             ADDS     R5,R5,#+4
    705              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0xBA00             REV      R0,R0
   \   00000072   0x9011             STR      R0,[SP, #+68]
    706              break;
   \   00000074   0xE03D             B.N      ??CRYP_AES_GCM_4
    707              case 192:
    708              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_GCM_1: (+1)
   \   00000076   0xF44F 0x7080      MOV      R0,#+256
   \   0000007A   0x9009             STR      R0,[SP, #+36]
    709              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   \   0000007E   0xBA00             REV      R0,R0
   \   00000080   0x900C             STR      R0,[SP, #+48]
    710              keyaddr+=4;
   \   00000082   0x1D2D             ADDS     R5,R5,#+4
    711              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0xBA00             REV      R0,R0
   \   00000088   0x900D             STR      R0,[SP, #+52]
    712              keyaddr+=4;
   \   0000008A   0x1D2D             ADDS     R5,R5,#+4
    713              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000008C   0x6828             LDR      R0,[R5, #+0]
   \   0000008E   0xBA00             REV      R0,R0
   \   00000090   0x900E             STR      R0,[SP, #+56]
    714              keyaddr+=4;
   \   00000092   0x1D2D             ADDS     R5,R5,#+4
    715              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0xBA00             REV      R0,R0
   \   00000098   0x900F             STR      R0,[SP, #+60]
    716              keyaddr+=4;
   \   0000009A   0x1D2D             ADDS     R5,R5,#+4
    717              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000009C   0x6828             LDR      R0,[R5, #+0]
   \   0000009E   0xBA00             REV      R0,R0
   \   000000A0   0x9010             STR      R0,[SP, #+64]
    718              keyaddr+=4;
   \   000000A2   0x1D2D             ADDS     R5,R5,#+4
    719              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0xBA00             REV      R0,R0
   \   000000A8   0x9011             STR      R0,[SP, #+68]
    720              break;
   \   000000AA   0xE022             B.N      ??CRYP_AES_GCM_4
    721              case 256:
    722              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_GCM_2: (+1)
   \   000000AC   0xF44F 0x7000      MOV      R0,#+512
   \   000000B0   0x9009             STR      R0,[SP, #+36]
    723              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0xBA00             REV      R0,R0
   \   000000B6   0x900A             STR      R0,[SP, #+40]
    724              keyaddr+=4;
   \   000000B8   0x1D2D             ADDS     R5,R5,#+4
    725              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000000BA   0x6828             LDR      R0,[R5, #+0]
   \   000000BC   0xBA00             REV      R0,R0
   \   000000BE   0x900B             STR      R0,[SP, #+44]
    726              keyaddr+=4;
   \   000000C0   0x1D2D             ADDS     R5,R5,#+4
    727              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000C2   0x6828             LDR      R0,[R5, #+0]
   \   000000C4   0xBA00             REV      R0,R0
   \   000000C6   0x900C             STR      R0,[SP, #+48]
    728              keyaddr+=4;
   \   000000C8   0x1D2D             ADDS     R5,R5,#+4
    729              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000CA   0x6828             LDR      R0,[R5, #+0]
   \   000000CC   0xBA00             REV      R0,R0
   \   000000CE   0x900D             STR      R0,[SP, #+52]
    730              keyaddr+=4;
   \   000000D0   0x1D2D             ADDS     R5,R5,#+4
    731              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0xBA00             REV      R0,R0
   \   000000D6   0x900E             STR      R0,[SP, #+56]
    732              keyaddr+=4;
   \   000000D8   0x1D2D             ADDS     R5,R5,#+4
    733              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000DA   0x6828             LDR      R0,[R5, #+0]
   \   000000DC   0xBA00             REV      R0,R0
   \   000000DE   0x900F             STR      R0,[SP, #+60]
    734              keyaddr+=4;
   \   000000E0   0x1D2D             ADDS     R5,R5,#+4
    735              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000E2   0x6828             LDR      R0,[R5, #+0]
   \   000000E4   0xBA00             REV      R0,R0
   \   000000E6   0x9010             STR      R0,[SP, #+64]
    736              keyaddr+=4;
   \   000000E8   0x1D2D             ADDS     R5,R5,#+4
    737              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000EA   0x6828             LDR      R0,[R5, #+0]
   \   000000EC   0xBA00             REV      R0,R0
   \   000000EE   0x9011             STR      R0,[SP, #+68]
    738              break;
   \   000000F0   0xE7FF             B.N      ??CRYP_AES_GCM_4
    739              default:
    740              break;
    741            }
    742            
    743            /* CRYP Initialization Vectors */
    744            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_GCM_3: (+1)
   \                     ??CRYP_AES_GCM_4: (+1)
   \   000000F2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000F6   0xBA00             REV      R0,R0
   \   000000F8   0x9012             STR      R0,[SP, #+72]
    745            ivaddr+=4;
   \   000000FA   0xF119 0x0904      ADDS     R9,R9,#+4
    746            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   000000FE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000102   0xBA00             REV      R0,R0
   \   00000104   0x9013             STR      R0,[SP, #+76]
    747            ivaddr+=4;
   \   00000106   0xF119 0x0904      ADDS     R9,R9,#+4
    748            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \   0000010A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000010E   0xBA00             REV      R0,R0
   \   00000110   0x9014             STR      R0,[SP, #+80]
    749            ivaddr+=4;
   \   00000112   0xF119 0x0904      ADDS     R9,R9,#+4
    750            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \   00000116   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000011A   0xBA00             REV      R0,R0
   \   0000011C   0x9015             STR      R0,[SP, #+84]
    751            
    752            /*------------------ AES Encryption ------------------*/
    753            if(Mode == MODE_ENCRYPT) /* AES encryption */
   \   0000011E   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \   00000122   0x2801             CMP      R0,#+1
   \   00000124   0xF040 0x80F8      BNE.W    ??CRYP_AES_GCM_5
    754            {
    755              /* Flush IN/OUT FIFOs */
    756              CRYP_FIFOFlush();
   \   00000128   0x.... 0x....      BL       CRYP_FIFOFlush
    757              
    758              /* Key Initialisation */
    759              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   0000012C   0xA80A             ADD      R0,SP,#+40
   \   0000012E   0x.... 0x....      BL       CRYP_KeyInit
    760              
    761              /* CRYP Initialization Vectors */
    762              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000132   0xA812             ADD      R0,SP,#+72
   \   00000134   0x.... 0x....      BL       CRYP_IVInit
    763              
    764              /* Crypto Init for Key preparation for decryption process */
    765              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x9006             STR      R0,[SP, #+24]
    766              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
   \   0000013C   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000140   0x9007             STR      R0,[SP, #+28]
    767              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000142   0x2080             MOVS     R0,#+128
   \   00000144   0x9008             STR      R0,[SP, #+32]
    768              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000146   0xA806             ADD      R0,SP,#+24
   \   00000148   0x.... 0x....      BL       CRYP_Init
    769              
    770              /***************************** Init phase *********************************/
    771              /* Select init phase */
    772              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x.... 0x....      BL       CRYP_PhaseConfig
    773              
    774              /* Enable Crypto processor */
    775              CRYP_Cmd(ENABLE);
   \   00000152   0x2001             MOVS     R0,#+1
   \   00000154   0x.... 0x....      BL       CRYP_Cmd
    776              
    777              /* Wait for CRYPEN bit to be 0 */
    778              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_GCM_6: (+1)
   \   00000158   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000015C   0x2801             CMP      R0,#+1
   \   0000015E   0xD0FB             BEQ.N    ??CRYP_AES_GCM_6
    779              {
    780              }
    781              
    782              /***************************** header phase *******************************/
    783              if(HLength != 0)
   \   00000160   0x9827             LDR      R0,[SP, #+156]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD042             BEQ.N    ??CRYP_AES_GCM_7
    784              {
    785                /* Select header phase */
    786                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   00000166   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000016A   0x.... 0x....      BL       CRYP_PhaseConfig
    787                
    788                /* Enable Crypto processor */
    789                CRYP_Cmd(ENABLE);
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x.... 0x....      BL       CRYP_Cmd
    790                
    791                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000174   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD101             BNE.N    ??CRYP_AES_GCM_8
    792                {
    793                   /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    794                      the CRYP peripheral (please check the device sales type. */
    795                   return(ERROR);
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xE1C7             B.N      ??CRYP_AES_GCM_9
    796                }
    797                
    798                for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
   \                     ??CRYP_AES_GCM_8: (+1)
   \   00000180   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000184   0xE01E             B.N      ??CRYP_AES_GCM_10
    799                {
    800                  /* Wait until the IFEM flag is reset */
    801                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_GCM_11: (+1)
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD0FA             BEQ.N    ??CRYP_AES_GCM_11
    802                  {
    803                  }
    804                  
    805                  /* Write the Input block in the IN FIFO */
    806                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000190   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000194   0x.... 0x....      BL       CRYP_DataIn
    807                  headeraddr+=4;
   \   00000198   0xF118 0x0804      ADDS     R8,R8,#+4
    808                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000019C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000001A0   0x.... 0x....      BL       CRYP_DataIn
    809                  headeraddr+=4;
   \   000001A4   0xF118 0x0804      ADDS     R8,R8,#+4
    810                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000001A8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000001AC   0x.... 0x....      BL       CRYP_DataIn
    811                  headeraddr+=4;
   \   000001B0   0xF118 0x0804      ADDS     R8,R8,#+4
    812                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000001B4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000001B8   0x.... 0x....      BL       CRYP_DataIn
    813                  headeraddr+=4;
   \   000001BC   0xF118 0x0804      ADDS     R8,R8,#+4
    814                }
   \   000001C0   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_GCM_10: (+1)
   \   000001C4   0x9827             LDR      R0,[SP, #+156]
   \   000001C6   0x4583             CMP      R11,R0
   \   000001C8   0xD3DD             BCC.N    ??CRYP_AES_GCM_11
    815                
    816                /* Wait until the complete message has been processed */
    817                counter = 0;
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x9000             STR      R0,[SP, #+0]
    818                do
    819                {
    820                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_GCM_12: (+1)
   \   000001CE   0x2010             MOVS     R0,#+16
   \   000001D0   0x.... 0x....      BL       CRYP_GetFlagStatus
    821                  counter++;
   \   000001D4   0x9900             LDR      R1,[SP, #+0]
   \   000001D6   0x1C49             ADDS     R1,R1,#+1
   \   000001D8   0x9100             STR      R1,[SP, #+0]
    822                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   000001DA   0x9900             LDR      R1,[SP, #+0]
   \   000001DC   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001E0   0xD001             BEQ.N    ??CRYP_AES_GCM_13
   \   000001E2   0x2800             CMP      R0,#+0
   \   000001E4   0xD1F3             BNE.N    ??CRYP_AES_GCM_12
    823          
    824                if (busystatus != RESET)
   \                     ??CRYP_AES_GCM_13: (+1)
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD000             BEQ.N    ??CRYP_AES_GCM_7
    825                {
    826                  status = ERROR;
   \   000001EA   0x2400             MOVS     R4,#+0
    827                }
    828              }
    829              
    830              /**************************** payload phase *******************************/
    831              if(ILength != 0)
   \                     ??CRYP_AES_GCM_7: (+1)
   \   000001EC   0x9825             LDR      R0,[SP, #+148]
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD053             BEQ.N    ??CRYP_AES_GCM_14
    832              {
    833                /* Select payload phase */
    834                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   000001F2   0xF45F 0x3000      MOVS     R0,#+131072
   \   000001F6   0x.... 0x....      BL       CRYP_PhaseConfig
    835                
    836                /* Enable Crypto processor */
    837                CRYP_Cmd(ENABLE);
   \   000001FA   0x2001             MOVS     R0,#+1
   \   000001FC   0x.... 0x....      BL       CRYP_Cmd
    838                
    839                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000200   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000204   0x2800             CMP      R0,#+0
   \   00000206   0xD101             BNE.N    ??CRYP_AES_GCM_15
    840                {
    841                  /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    842                     the CRYP peripheral (please check the device sales type. */
    843                  return(ERROR);
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0xE181             B.N      ??CRYP_AES_GCM_9
    844                }
    845                
    846                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_GCM_15: (+1)
   \   0000020C   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000210   0xE016             B.N      ??CRYP_AES_GCM_16
    847                {
    848                  /* Wait until the IFEM flag is reset */
    849                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
    850                  {
    851                  }
    852                  /* Write the Input block in the IN FIFO */
    853                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    854                  inputaddr+=4;
    855                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    856                  inputaddr+=4;
    857                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    858                  inputaddr+=4;
    859                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    860                  inputaddr+=4;
    861                  
    862                  /* Wait until the complete message has been processed */
    863                  counter = 0;
    864                  do
    865                  {
    866                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    867                    counter++;
    868                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    869          
    870                  if (busystatus != RESET)
    871                  {
    872                    status = ERROR;
    873                  }
    874                  else
    875                  {
    876                    /* Wait until the OFNE flag is reset */
    877                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_17: (+1)
   \   00000212   0x2004             MOVS     R0,#+4
   \   00000214   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000218   0x2800             CMP      R0,#+0
   \   0000021A   0xD0FA             BEQ.N    ??CRYP_AES_GCM_17
    878                    {
    879                    }
    880                    
    881                    /* Read the Output block from the Output FIFO */
    882                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000021C   0x.... 0x....      BL       CRYP_DataOut
   \   00000220   0x6038             STR      R0,[R7, #+0]
    883                    outputaddr+=4;
   \   00000222   0x1D3F             ADDS     R7,R7,#+4
    884                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000224   0x.... 0x....      BL       CRYP_DataOut
   \   00000228   0x6038             STR      R0,[R7, #+0]
    885                    outputaddr+=4;
   \   0000022A   0x1D3F             ADDS     R7,R7,#+4
    886                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000022C   0x.... 0x....      BL       CRYP_DataOut
   \   00000230   0x6038             STR      R0,[R7, #+0]
    887                    outputaddr+=4;
   \   00000232   0x1D3F             ADDS     R7,R7,#+4
    888                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000234   0x.... 0x....      BL       CRYP_DataOut
   \   00000238   0x6038             STR      R0,[R7, #+0]
    889                    outputaddr+=4;
   \   0000023A   0x1D3F             ADDS     R7,R7,#+4
    890                  }
   \                     ??CRYP_AES_GCM_18: (+1)
   \   0000023C   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_GCM_16: (+1)
   \   00000240   0x9825             LDR      R0,[SP, #+148]
   \   00000242   0x4583             CMP      R11,R0
   \   00000244   0xD229             BCS.N    ??CRYP_AES_GCM_14
   \   00000246   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000248   0x2C00             CMP      R4,#+0
   \   0000024A   0xD026             BEQ.N    ??CRYP_AES_GCM_14
   \                     ??CRYP_AES_GCM_19: (+1)
   \   0000024C   0x2001             MOVS     R0,#+1
   \   0000024E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000252   0x2800             CMP      R0,#+0
   \   00000254   0xD0FA             BEQ.N    ??CRYP_AES_GCM_19
   \   00000256   0x6830             LDR      R0,[R6, #+0]
   \   00000258   0x.... 0x....      BL       CRYP_DataIn
   \   0000025C   0x1D36             ADDS     R6,R6,#+4
   \   0000025E   0x6830             LDR      R0,[R6, #+0]
   \   00000260   0x.... 0x....      BL       CRYP_DataIn
   \   00000264   0x1D36             ADDS     R6,R6,#+4
   \   00000266   0x6830             LDR      R0,[R6, #+0]
   \   00000268   0x.... 0x....      BL       CRYP_DataIn
   \   0000026C   0x1D36             ADDS     R6,R6,#+4
   \   0000026E   0x6830             LDR      R0,[R6, #+0]
   \   00000270   0x.... 0x....      BL       CRYP_DataIn
   \   00000274   0x1D36             ADDS     R6,R6,#+4
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_GCM_20: (+1)
   \   0000027A   0x2010             MOVS     R0,#+16
   \   0000027C   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000280   0x9900             LDR      R1,[SP, #+0]
   \   00000282   0x1C49             ADDS     R1,R1,#+1
   \   00000284   0x9100             STR      R1,[SP, #+0]
   \   00000286   0x9900             LDR      R1,[SP, #+0]
   \   00000288   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000028C   0xD001             BEQ.N    ??CRYP_AES_GCM_21
   \   0000028E   0x2800             CMP      R0,#+0
   \   00000290   0xD1F3             BNE.N    ??CRYP_AES_GCM_20
   \                     ??CRYP_AES_GCM_21: (+1)
   \   00000292   0x2800             CMP      R0,#+0
   \   00000294   0xD0BD             BEQ.N    ??CRYP_AES_GCM_17
   \   00000296   0x2400             MOVS     R4,#+0
   \   00000298   0xE7D0             B.N      ??CRYP_AES_GCM_18
    891                }
    892              }
    893              
    894              /***************************** final phase ********************************/
    895              /* Select final phase */
    896              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_GCM_14: (+1)
   \   0000029A   0xF45F 0x3040      MOVS     R0,#+196608
   \   0000029E   0x.... 0x....      BL       CRYP_PhaseConfig
    897              
    898              /* Enable Crypto processor */
    899              CRYP_Cmd(ENABLE);
   \   000002A2   0x2001             MOVS     R0,#+1
   \   000002A4   0x.... 0x....      BL       CRYP_Cmd
    900              
    901              if(CRYP_GetCmdStatus() == DISABLE)
   \   000002A8   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000002AC   0x2800             CMP      R0,#+0
   \   000002AE   0xD101             BNE.N    ??CRYP_AES_GCM_22
    902              {
    903                /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    904                   the CRYP peripheral (please check the device sales type. */
    905                return(ERROR);
   \   000002B0   0x2000             MOVS     R0,#+0
   \   000002B2   0xE12D             B.N      ??CRYP_AES_GCM_9
    906              }
    907              
    908              /* Write number of bits concatenated with header in the IN FIFO */
    909              CRYP_DataIn(__REV(headerlength>>32));
   \                     ??CRYP_AES_GCM_22: (+1)
   \   000002B4   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   000002B8   0xBA08             REV      R0,R1
   \   000002BA   0x.... 0x....      BL       CRYP_DataIn
    910              CRYP_DataIn(__REV(headerlength));
   \   000002BE   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   000002C2   0xBA00             REV      R0,R0
   \   000002C4   0x.... 0x....      BL       CRYP_DataIn
    911              CRYP_DataIn(__REV(inputlength>>32));
   \   000002C8   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   000002CC   0xBA08             REV      R0,R1
   \   000002CE   0x.... 0x....      BL       CRYP_DataIn
    912              CRYP_DataIn(__REV(inputlength));
   \   000002D2   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   000002D6   0xBA00             REV      R0,R0
   \   000002D8   0x.... 0x....      BL       CRYP_DataIn
    913              /* Wait until the OFNE flag is reset */
    914              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_23: (+1)
   \   000002DC   0x2004             MOVS     R0,#+4
   \   000002DE   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000002E2   0x2800             CMP      R0,#+0
   \   000002E4   0xD0FA             BEQ.N    ??CRYP_AES_GCM_23
    915              {
    916              }
    917              
    918              tagaddr = (uint32_t)AuthTAG;
    919              /* Read the Auth TAG in the IN FIFO */
    920              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002E6   0x.... 0x....      BL       CRYP_DataOut
   \   000002EA   0xF8CA 0x0000      STR      R0,[R10, #+0]
    921              tagaddr+=4;
   \   000002EE   0xF11A 0x0A04      ADDS     R10,R10,#+4
    922              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002F2   0x.... 0x....      BL       CRYP_DataOut
   \   000002F6   0xF8CA 0x0000      STR      R0,[R10, #+0]
    923              tagaddr+=4;
   \   000002FA   0xF11A 0x0A04      ADDS     R10,R10,#+4
    924              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002FE   0x.... 0x....      BL       CRYP_DataOut
   \   00000302   0xF8CA 0x0000      STR      R0,[R10, #+0]
    925              tagaddr+=4;
   \   00000306   0xF11A 0x0A04      ADDS     R10,R10,#+4
    926              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   0000030A   0x.... 0x....      BL       CRYP_DataOut
   \   0000030E   0xF8CA 0x0000      STR      R0,[R10, #+0]
    927              tagaddr+=4;
   \   00000312   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000316   0xE0F6             B.N      ??CRYP_AES_GCM_24
    928            }
    929            /*------------------ AES Decryption ------------------*/
    930            else /* AES decryption */
    931            {
    932              /* Flush IN/OUT FIFOs */
    933              CRYP_FIFOFlush();
   \                     ??CRYP_AES_GCM_5: (+1)
   \   00000318   0x.... 0x....      BL       CRYP_FIFOFlush
    934              
    935              /* Key Initialisation */
    936              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   0000031C   0xA80A             ADD      R0,SP,#+40
   \   0000031E   0x.... 0x....      BL       CRYP_KeyInit
    937              
    938              /* CRYP Initialization Vectors */
    939              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000322   0xA812             ADD      R0,SP,#+72
   \   00000324   0x.... 0x....      BL       CRYP_IVInit
    940              
    941              /* Crypto Init for Key preparation for decryption process */
    942              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   00000328   0x2004             MOVS     R0,#+4
   \   0000032A   0x9006             STR      R0,[SP, #+24]
    943              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
   \   0000032C   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000330   0x9007             STR      R0,[SP, #+28]
    944              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000332   0x2080             MOVS     R0,#+128
   \   00000334   0x9008             STR      R0,[SP, #+32]
    945              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000336   0xA806             ADD      R0,SP,#+24
   \   00000338   0x.... 0x....      BL       CRYP_Init
    946              
    947              /***************************** Init phase *********************************/
    948              /* Select init phase */
    949              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   0000033C   0x2000             MOVS     R0,#+0
   \   0000033E   0x.... 0x....      BL       CRYP_PhaseConfig
    950              
    951              /* Enable Crypto processor */
    952              CRYP_Cmd(ENABLE);
   \   00000342   0x2001             MOVS     R0,#+1
   \   00000344   0x.... 0x....      BL       CRYP_Cmd
    953              
    954              /* Wait for CRYPEN bit to be 0 */
    955              while(CRYP_GetCmdStatus() == ENABLE);
   \                     ??CRYP_AES_GCM_25: (+1)
   \   00000348   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000034C   0x2801             CMP      R0,#+1
   \   0000034E   0xD0FB             BEQ.N    ??CRYP_AES_GCM_25
    956              
    957              /***************************** header phase *******************************/
    958              if(HLength != 0)
   \   00000350   0x9827             LDR      R0,[SP, #+156]
   \   00000352   0x2800             CMP      R0,#+0
   \   00000354   0xD042             BEQ.N    ??CRYP_AES_GCM_26
    959              {
    960                /* Select header phase */
    961                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   00000356   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000035A   0x.... 0x....      BL       CRYP_PhaseConfig
    962                
    963                /* Enable Crypto processor */
    964                CRYP_Cmd(ENABLE);
   \   0000035E   0x2001             MOVS     R0,#+1
   \   00000360   0x.... 0x....      BL       CRYP_Cmd
    965                
    966                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000364   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000368   0x2800             CMP      R0,#+0
   \   0000036A   0xD101             BNE.N    ??CRYP_AES_GCM_27
    967                {
    968                  /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
    969                     the CRYP peripheral (please check the device sales type. */
    970                  return(ERROR);
   \   0000036C   0x2000             MOVS     R0,#+0
   \   0000036E   0xE0CF             B.N      ??CRYP_AES_GCM_9
    971                }
    972                
    973                for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
   \                     ??CRYP_AES_GCM_27: (+1)
   \   00000370   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000374   0xE01E             B.N      ??CRYP_AES_GCM_28
    974                {
    975                  /* Wait until the IFEM flag is reset */
    976                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
   \                     ??CRYP_AES_GCM_29: (+1)
   \   00000376   0x2001             MOVS     R0,#+1
   \   00000378   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000037C   0x2800             CMP      R0,#+0
   \   0000037E   0xD0FA             BEQ.N    ??CRYP_AES_GCM_29
    977                  
    978                  /* Write the Input block in the IN FIFO */
    979                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000380   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000384   0x.... 0x....      BL       CRYP_DataIn
    980                  headeraddr+=4;
   \   00000388   0xF118 0x0804      ADDS     R8,R8,#+4
    981                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000038C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000390   0x.... 0x....      BL       CRYP_DataIn
    982                  headeraddr+=4;
   \   00000394   0xF118 0x0804      ADDS     R8,R8,#+4
    983                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000398   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000039C   0x.... 0x....      BL       CRYP_DataIn
    984                  headeraddr+=4;
   \   000003A0   0xF118 0x0804      ADDS     R8,R8,#+4
    985                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000003A4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000003A8   0x.... 0x....      BL       CRYP_DataIn
    986                  headeraddr+=4;
   \   000003AC   0xF118 0x0804      ADDS     R8,R8,#+4
    987                }
   \   000003B0   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_GCM_28: (+1)
   \   000003B4   0x9827             LDR      R0,[SP, #+156]
   \   000003B6   0x4583             CMP      R11,R0
   \   000003B8   0xD3DD             BCC.N    ??CRYP_AES_GCM_29
    988                
    989                /* Wait until the complete message has been processed */
    990                counter = 0;
   \   000003BA   0x2000             MOVS     R0,#+0
   \   000003BC   0x9000             STR      R0,[SP, #+0]
    991                do
    992                {
    993                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_GCM_30: (+1)
   \   000003BE   0x2010             MOVS     R0,#+16
   \   000003C0   0x.... 0x....      BL       CRYP_GetFlagStatus
    994                  counter++;
   \   000003C4   0x9900             LDR      R1,[SP, #+0]
   \   000003C6   0x1C49             ADDS     R1,R1,#+1
   \   000003C8   0x9100             STR      R1,[SP, #+0]
    995                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   000003CA   0x9900             LDR      R1,[SP, #+0]
   \   000003CC   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000003D0   0xD001             BEQ.N    ??CRYP_AES_GCM_31
   \   000003D2   0x2800             CMP      R0,#+0
   \   000003D4   0xD1F3             BNE.N    ??CRYP_AES_GCM_30
    996          
    997                if (busystatus != RESET)
   \                     ??CRYP_AES_GCM_31: (+1)
   \   000003D6   0x2800             CMP      R0,#+0
   \   000003D8   0xD000             BEQ.N    ??CRYP_AES_GCM_26
    998                {
    999                  status = ERROR;
   \   000003DA   0x2400             MOVS     R4,#+0
   1000                }
   1001              }
   1002              
   1003              /**************************** payload phase *******************************/
   1004              if(ILength != 0)
   \                     ??CRYP_AES_GCM_26: (+1)
   \   000003DC   0x9825             LDR      R0,[SP, #+148]
   \   000003DE   0x2800             CMP      R0,#+0
   \   000003E0   0xD053             BEQ.N    ??CRYP_AES_GCM_32
   1005              {
   1006                /* Select payload phase */
   1007                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   000003E2   0xF45F 0x3000      MOVS     R0,#+131072
   \   000003E6   0x.... 0x....      BL       CRYP_PhaseConfig
   1008          
   1009                /* Enable Crypto processor */
   1010                CRYP_Cmd(ENABLE);
   \   000003EA   0x2001             MOVS     R0,#+1
   \   000003EC   0x.... 0x....      BL       CRYP_Cmd
   1011                
   1012                if(CRYP_GetCmdStatus() == DISABLE)
   \   000003F0   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000003F4   0x2800             CMP      R0,#+0
   \   000003F6   0xD101             BNE.N    ??CRYP_AES_GCM_33
   1013                {
   1014                  /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1015                     the CRYP peripheral (please check the device sales type. */
   1016                  return(ERROR);
   \   000003F8   0x2000             MOVS     R0,#+0
   \   000003FA   0xE089             B.N      ??CRYP_AES_GCM_9
   1017                }
   1018                
   1019                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_GCM_33: (+1)
   \   000003FC   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000400   0xE016             B.N      ??CRYP_AES_GCM_34
   1020                {
   1021                  /* Wait until the IFEM flag is reset */
   1022                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
   1023                  /* Write the Input block in the IN FIFO */
   1024                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1025                  inputaddr+=4;
   1026                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1027                  inputaddr+=4;
   1028                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1029                  inputaddr+=4;
   1030                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1031                  inputaddr+=4;
   1032                  
   1033                  /* Wait until the complete message has been processed */
   1034                  counter = 0;
   1035                  do
   1036                  {
   1037                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1038                    counter++;
   1039                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1040          
   1041                  if (busystatus != RESET)
   1042                  {
   1043                    status = ERROR;
   1044                  }
   1045                  else
   1046                  {
   1047                    /* Wait until the OFNE flag is reset */
   1048                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
   \                     ??CRYP_AES_GCM_35: (+1)
   \   00000402   0x2004             MOVS     R0,#+4
   \   00000404   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000408   0x2800             CMP      R0,#+0
   \   0000040A   0xD0FA             BEQ.N    ??CRYP_AES_GCM_35
   1049                    
   1050                    /* Read the Output block from the Output FIFO */
   1051                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000040C   0x.... 0x....      BL       CRYP_DataOut
   \   00000410   0x6038             STR      R0,[R7, #+0]
   1052                    outputaddr+=4;
   \   00000412   0x1D3F             ADDS     R7,R7,#+4
   1053                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000414   0x.... 0x....      BL       CRYP_DataOut
   \   00000418   0x6038             STR      R0,[R7, #+0]
   1054                    outputaddr+=4;
   \   0000041A   0x1D3F             ADDS     R7,R7,#+4
   1055                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000041C   0x.... 0x....      BL       CRYP_DataOut
   \   00000420   0x6038             STR      R0,[R7, #+0]
   1056                    outputaddr+=4;
   \   00000422   0x1D3F             ADDS     R7,R7,#+4
   1057                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000424   0x.... 0x....      BL       CRYP_DataOut
   \   00000428   0x6038             STR      R0,[R7, #+0]
   1058                    outputaddr+=4;
   \   0000042A   0x1D3F             ADDS     R7,R7,#+4
   1059                  }
   \                     ??CRYP_AES_GCM_36: (+1)
   \   0000042C   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_GCM_34: (+1)
   \   00000430   0x9825             LDR      R0,[SP, #+148]
   \   00000432   0x4583             CMP      R11,R0
   \   00000434   0xD229             BCS.N    ??CRYP_AES_GCM_32
   \   00000436   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000438   0x2C00             CMP      R4,#+0
   \   0000043A   0xD026             BEQ.N    ??CRYP_AES_GCM_32
   \                     ??CRYP_AES_GCM_37: (+1)
   \   0000043C   0x2001             MOVS     R0,#+1
   \   0000043E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000442   0x2800             CMP      R0,#+0
   \   00000444   0xD0FA             BEQ.N    ??CRYP_AES_GCM_37
   \   00000446   0x6830             LDR      R0,[R6, #+0]
   \   00000448   0x.... 0x....      BL       CRYP_DataIn
   \   0000044C   0x1D36             ADDS     R6,R6,#+4
   \   0000044E   0x6830             LDR      R0,[R6, #+0]
   \   00000450   0x.... 0x....      BL       CRYP_DataIn
   \   00000454   0x1D36             ADDS     R6,R6,#+4
   \   00000456   0x6830             LDR      R0,[R6, #+0]
   \   00000458   0x.... 0x....      BL       CRYP_DataIn
   \   0000045C   0x1D36             ADDS     R6,R6,#+4
   \   0000045E   0x6830             LDR      R0,[R6, #+0]
   \   00000460   0x.... 0x....      BL       CRYP_DataIn
   \   00000464   0x1D36             ADDS     R6,R6,#+4
   \   00000466   0x2000             MOVS     R0,#+0
   \   00000468   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_GCM_38: (+1)
   \   0000046A   0x2010             MOVS     R0,#+16
   \   0000046C   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000470   0x9900             LDR      R1,[SP, #+0]
   \   00000472   0x1C49             ADDS     R1,R1,#+1
   \   00000474   0x9100             STR      R1,[SP, #+0]
   \   00000476   0x9900             LDR      R1,[SP, #+0]
   \   00000478   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000047C   0xD001             BEQ.N    ??CRYP_AES_GCM_39
   \   0000047E   0x2800             CMP      R0,#+0
   \   00000480   0xD1F3             BNE.N    ??CRYP_AES_GCM_38
   \                     ??CRYP_AES_GCM_39: (+1)
   \   00000482   0x2800             CMP      R0,#+0
   \   00000484   0xD0BD             BEQ.N    ??CRYP_AES_GCM_35
   \   00000486   0x2400             MOVS     R4,#+0
   \   00000488   0xE7D0             B.N      ??CRYP_AES_GCM_36
   1060                }
   1061              }
   1062              
   1063              /***************************** final phase ********************************/
   1064              /* Select final phase */
   1065              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_GCM_32: (+1)
   \   0000048A   0xF45F 0x3040      MOVS     R0,#+196608
   \   0000048E   0x.... 0x....      BL       CRYP_PhaseConfig
   1066          
   1067              /* Enable Crypto processor */
   1068              CRYP_Cmd(ENABLE);
   \   00000492   0x2001             MOVS     R0,#+1
   \   00000494   0x.... 0x....      BL       CRYP_Cmd
   1069              
   1070              if(CRYP_GetCmdStatus() == DISABLE)
   \   00000498   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000049C   0x2800             CMP      R0,#+0
   \   0000049E   0xD101             BNE.N    ??CRYP_AES_GCM_40
   1071              {
   1072                /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1073                   the CRYP peripheral (please check the device sales type. */
   1074                return(ERROR);
   \   000004A0   0x2000             MOVS     R0,#+0
   \   000004A2   0xE035             B.N      ??CRYP_AES_GCM_9
   1075              }
   1076              
   1077              /* Write number of bits concatenated with header in the IN FIFO */
   1078              CRYP_DataIn(__REV(headerlength>>32));
   \                     ??CRYP_AES_GCM_40: (+1)
   \   000004A4   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   000004A8   0xBA08             REV      R0,R1
   \   000004AA   0x.... 0x....      BL       CRYP_DataIn
   1079              CRYP_DataIn(__REV(headerlength));
   \   000004AE   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   000004B2   0xBA00             REV      R0,R0
   \   000004B4   0x.... 0x....      BL       CRYP_DataIn
   1080              CRYP_DataIn(__REV(inputlength>>32));
   \   000004B8   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   000004BC   0xBA08             REV      R0,R1
   \   000004BE   0x.... 0x....      BL       CRYP_DataIn
   1081              CRYP_DataIn(__REV(inputlength));
   \   000004C2   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   000004C6   0xBA00             REV      R0,R0
   \   000004C8   0x.... 0x....      BL       CRYP_DataIn
   1082              /* Wait until the OFNE flag is reset */
   1083              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
   \                     ??CRYP_AES_GCM_41: (+1)
   \   000004CC   0x2004             MOVS     R0,#+4
   \   000004CE   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000004D2   0x2800             CMP      R0,#+0
   \   000004D4   0xD0FA             BEQ.N    ??CRYP_AES_GCM_41
   1084              
   1085              tagaddr = (uint32_t)AuthTAG;
   1086              /* Read the Auth TAG in the IN FIFO */
   1087              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000004D6   0x.... 0x....      BL       CRYP_DataOut
   \   000004DA   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1088              tagaddr+=4;
   \   000004DE   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1089              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000004E2   0x.... 0x....      BL       CRYP_DataOut
   \   000004E6   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1090              tagaddr+=4;
   \   000004EA   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1091              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000004EE   0x.... 0x....      BL       CRYP_DataOut
   \   000004F2   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1092              tagaddr+=4;
   \   000004F6   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1093              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000004FA   0x.... 0x....      BL       CRYP_DataOut
   \   000004FE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1094              tagaddr+=4;
   \   00000502   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1095            }
   1096            /* Disable Crypto */
   1097            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_GCM_24: (+1)
   \   00000506   0x2000             MOVS     R0,#+0
   \   00000508   0x.... 0x....      BL       CRYP_Cmd
   1098          
   1099            return status;
   \   0000050C   0x0020             MOVS     R0,R4
   \   0000050E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_GCM_9: (+1)
   \   00000510   0xB01B             ADD      SP,SP,#+108
   \   00000512   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1100          }
   1101          
   1102          /**
   1103            * @brief  Encrypt and decrypt using AES in CCM Mode. The GCM and CCM modes
   1104            *         are available only on STM32F437x Devices.
   1105            * @param  Mode: encryption or decryption Mode.
   1106            *          This parameter can be one of the following values:
   1107            *            @arg MODE_ENCRYPT: Encryption
   1108            *            @arg MODE_DECRYPT: Decryption
   1109            * @param  Nonce: the nounce used for AES algorithm. It shall be unique for each processing.
   1110            * @param  Key: Key used for AES algorithm.
   1111            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
   1112            * @param  Input: pointer to the Input buffer.
   1113            * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
   1114            * @param  Header: pointer to the header buffer.
   1115            * @param  Hlength: length of the header buffer in bytes.
   1116            * @param  HBuffer: pointer to temporary buffer used to append the header
   1117            *         HBuffer size must be equal to Hlength + 21
   1118            * @param  Output: pointer to the returned buffer.
   1119            * @param  AuthTAG: pointer to the authentication TAG buffer.
   1120            * @param  TAGSize: the size of the TAG (called also MAC).
   1121            * @retval An ErrorStatus enumeration value:
   1122            *          - SUCCESS: Operation done
   1123            *          - ERROR: Operation failed
   1124            */

   \                                 In section .text, align 2, keep-with-next
   1125          ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
   1126                                   uint8_t* Nonce, uint32_t NonceSize,
   1127                                   uint8_t *Key, uint16_t Keysize,
   1128                                   uint8_t *Input, uint32_t ILength,
   1129                                   uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
   1130                                   uint8_t *Output,
   1131                                   uint8_t *AuthTAG, uint32_t TAGSize)
   1132          {
   \                     CRYP_AES_CCM: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB09F             SUB      SP,SP,#+124
   1133            CRYP_InitTypeDef AES_CRYP_InitStructure;
   1134            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
   1135            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
   1136            __IO uint32_t counter = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1137            uint32_t busystatus = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   1138            ErrorStatus status = SUCCESS;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1139            uint32_t keyaddr    = (uint32_t)Key;
   \   00000012   0x9C22             LDR      R4,[SP, #+136]
   1140            uint32_t inputaddr  = (uint32_t)Input;
   \   00000014   0x9D2D             LDR      R5,[SP, #+180]
   1141            uint32_t outputaddr = (uint32_t)Output;
   \   00000016   0x9E32             LDR      R6,[SP, #+200]
   \   00000018   0x9F2F             LDR      R7,[SP, #+188]
   1142            uint32_t headeraddr = (uint32_t)Header;
   1143            uint32_t tagaddr = (uint32_t)AuthTAG;
   \   0000001A   0x9833             LDR      R0,[SP, #+204]
   \   0000001C   0x9006             STR      R0,[SP, #+24]
   1144            uint32_t headersize = HLength;
   \   0000001E   0xF8DD 0x80C0      LDR      R8,[SP, #+192]
   1145            uint32_t loopcounter = 0;
   \   00000022   0xF05F 0x0B00      MOVS     R11,#+0
   1146            uint32_t bufferidx = 0;
   \   00000026   0xF05F 0x0900      MOVS     R9,#+0
   1147            uint8_t blockb0[16] = {0};/* Block B0 */
   \   0000002A   0xA802             ADD      R0,SP,#+8
   \   0000002C   0x2110             MOVS     R1,#+16
   \   0000002E   0x.... 0x....      BL       __aeabi_memclr4
   1148            uint8_t ctr[16] = {0}; /* Counter */
   \   00000032   0xA817             ADD      R0,SP,#+92
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x.... 0x....      BL       __aeabi_memclr4
   1149            uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
   \   0000003A   0xA80B             ADD      R0,SP,#+44
   \   0000003C   0x2110             MOVS     R1,#+16
   \   0000003E   0x.... 0x....      BL       __aeabi_memclr4
   1150            uint32_t ctraddr = (uint32_t)ctr;
   \   00000042   0xF10D 0x0A5C      ADD      R10,SP,#+92
   1151            uint32_t b0addr = (uint32_t)blockb0;
   \   00000046   0xF10D 0x0B08      ADD      R11,SP,#+8
   1152            
   1153            /************************ Formatting the header block ***********************/
   1154            if(headersize != 0)
   \   0000004A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004E   0xD052             BEQ.N    ??CRYP_AES_CCM_0
   \   00000050   0x9831             LDR      R0,[SP, #+196]
   1155            {
   1156              /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
   1157              if(headersize < 65280)
   \   00000052   0xF5B8 0x4F7F      CMP      R8,#+65280
   \   00000056   0xD20C             BCS.N    ??CRYP_AES_CCM_1
   1158              {
   1159                HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
   \   00000058   0xEA5F 0x2118      LSRS     R1,R8,#+8
   \   0000005C   0xF800 0x1009      STRB     R1,[R0, R9]
   \   00000060   0xF119 0x0901      ADDS     R9,R9,#+1
   1160                HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
   \   00000064   0xF800 0x8009      STRB     R8,[R0, R9]
   \   00000068   0xF119 0x0901      ADDS     R9,R9,#+1
   1161                headersize += 2;
   \   0000006C   0xF118 0x0802      ADDS     R8,R8,#+2
   \   00000070   0xE01E             B.N      ??CRYP_AES_CCM_2
   1162              }
   1163              else
   1164              {
   1165                /* header is encoded as 0xff || 0xfe || [headersize]32, i.e., six octets */
   1166                HBuffer[bufferidx++] = 0xFF;
   \                     ??CRYP_AES_CCM_1: (+1)
   \   00000072   0x21FF             MOVS     R1,#+255
   \   00000074   0xF800 0x1009      STRB     R1,[R0, R9]
   \   00000078   0xF119 0x0901      ADDS     R9,R9,#+1
   1167                HBuffer[bufferidx++] = 0xFE;
   \   0000007C   0x21FE             MOVS     R1,#+254
   \   0000007E   0xF800 0x1009      STRB     R1,[R0, R9]
   \   00000082   0xF119 0x0901      ADDS     R9,R9,#+1
   1168                HBuffer[bufferidx++] = headersize & 0xff000000;
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0xF800 0x1009      STRB     R1,[R0, R9]
   \   0000008C   0xF119 0x0901      ADDS     R9,R9,#+1
   1169                HBuffer[bufferidx++] = headersize & 0x00ff0000;
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0xF800 0x1009      STRB     R1,[R0, R9]
   \   00000096   0xF119 0x0901      ADDS     R9,R9,#+1
   1170                HBuffer[bufferidx++] = headersize & 0x0000ff00;
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0xF800 0x1009      STRB     R1,[R0, R9]
   \   000000A0   0xF119 0x0901      ADDS     R9,R9,#+1
   1171                HBuffer[bufferidx++] = headersize & 0x000000ff;
   \   000000A4   0xF800 0x8009      STRB     R8,[R0, R9]
   \   000000A8   0xF119 0x0901      ADDS     R9,R9,#+1
   1172                headersize += 6;
   \   000000AC   0xF118 0x0806      ADDS     R8,R8,#+6
   1173              }
   1174              /* Copy the header buffer in internal buffer "HBuffer" */
   1175              for(loopcounter = 0; loopcounter < headersize; loopcounter++)
   \                     ??CRYP_AES_CCM_2: (+1)
   \   000000B0   0xF05F 0x0B00      MOVS     R11,#+0
   \   000000B4   0xE007             B.N      ??CRYP_AES_CCM_3
   1176              {
   1177                HBuffer[bufferidx++] = Header[loopcounter];
   \                     ??CRYP_AES_CCM_4: (+1)
   \   000000B6   0xF817 0x100B      LDRB     R1,[R7, R11]
   \   000000BA   0xF800 0x1009      STRB     R1,[R0, R9]
   \   000000BE   0xF119 0x0901      ADDS     R9,R9,#+1
   1178              }
   \   000000C2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??CRYP_AES_CCM_3: (+1)
   \   000000C6   0x45C3             CMP      R11,R8
   \   000000C8   0xD3F5             BCC.N    ??CRYP_AES_CCM_4
   1179              /* Check if the header size is modulo 16 */
   1180              if ((headersize % 16) != 0)
   \   000000CA   0xF018 0x0F0F      TST      R8,#0xF
   \   000000CE   0xD011             BEQ.N    ??CRYP_AES_CCM_5
   1181              {
   1182                /* Padd the header buffer with 0s till the HBuffer length is modulo 16 */
   1183                for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
   \   000000D0   0x46C3             MOV      R11,R8
   \   000000D2   0xE004             B.N      ??CRYP_AES_CCM_6
   1184                {
   1185                  HBuffer[loopcounter] = 0;
   \                     ??CRYP_AES_CCM_7: (+1)
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0xF800 0x100B      STRB     R1,[R0, R11]
   1186                }
   \   000000DA   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??CRYP_AES_CCM_6: (+1)
   \   000000DE   0xEA5F 0x1118      LSRS     R1,R8,#+4
   \   000000E2   0x1C49             ADDS     R1,R1,#+1
   \   000000E4   0x0109             LSLS     R1,R1,#+4
   \   000000E6   0x4559             CMP      R1,R11
   \   000000E8   0xD2F4             BCS.N    ??CRYP_AES_CCM_7
   1187                /* Set the header size to modulo 16 */
   1188                headersize = ((headersize/16) + 1) * 16;
   \   000000EA   0xEA5F 0x1118      LSRS     R1,R8,#+4
   \   000000EE   0x1C49             ADDS     R1,R1,#+1
   \   000000F0   0xEA5F 0x1801      LSLS     R8,R1,#+4
   1189              }
   1190              /* set the pointer headeraddr to HBuffer */
   1191              headeraddr = (uint32_t)HBuffer;
   \                     ??CRYP_AES_CCM_5: (+1)
   \   000000F4   0x0007             MOVS     R7,R0
   1192            }
   1193            /************************* Formatting the block B0 **************************/
   1194            if(headersize != 0)
   \                     ??CRYP_AES_CCM_0: (+1)
   \   000000F6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000FA   0xD002             BEQ.N    ??CRYP_AES_CCM_8
   1195            {
   1196              blockb0[0] = 0x40;
   \   000000FC   0x2040             MOVS     R0,#+64
   \   000000FE   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1197            }
   1198            /* Flags byte */
   1199            blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
   \                     ??CRYP_AES_CCM_8: (+1)
   \   00000102   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000106   0xA934             ADD      R1,SP,#+208
   \   00000108   0x7809             LDRB     R1,[R1, #+0]
   \   0000010A   0x1E89             SUBS     R1,R1,#+2
   \   0000010C   0x2202             MOVS     R2,#+2
   \   0000010E   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000112   0x00C9             LSLS     R1,R1,#+3
   \   00000114   0xF011 0x0138      ANDS     R1,R1,#0x38
   \   00000118   0x9A21             LDR      R2,[SP, #+132]
   \   0000011A   0xF1D2 0x020F      RSBS     R2,R2,#+15
   \   0000011E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000120   0x1E52             SUBS     R2,R2,#+1
   \   00000122   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000126   0x4311             ORRS     R1,R2,R1
   \   00000128   0x4308             ORRS     R0,R1,R0
   \   0000012A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1200            
   1201            for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
   \   0000012E   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000132   0xE007             B.N      ??CRYP_AES_CCM_9
   1202            {
   1203              blockb0[loopcounter+1] = Nonce[loopcounter];
   \                     ??CRYP_AES_CCM_10: (+1)
   \   00000134   0x9820             LDR      R0,[SP, #+128]
   \   00000136   0xF810 0x000B      LDRB     R0,[R0, R11]
   \   0000013A   0xA902             ADD      R1,SP,#+8
   \   0000013C   0x4459             ADD      R1,R1,R11
   \   0000013E   0x7048             STRB     R0,[R1, #+1]
   1204            }
   \   00000140   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??CRYP_AES_CCM_9: (+1)
   \   00000144   0x9821             LDR      R0,[SP, #+132]
   \   00000146   0x4583             CMP      R11,R0
   \   00000148   0xD3F4             BCC.N    ??CRYP_AES_CCM_10
   1205            for ( ; loopcounter < 13; loopcounter++)
   \                     ??CRYP_AES_CCM_11: (+1)
   \   0000014A   0xF1BB 0x0F0D      CMP      R11,#+13
   \   0000014E   0xD206             BCS.N    ??CRYP_AES_CCM_12
   1206            {
   1207              blockb0[loopcounter+1] = 0;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xA902             ADD      R1,SP,#+8
   \   00000154   0x4459             ADD      R1,R1,R11
   \   00000156   0x7048             STRB     R0,[R1, #+1]
   1208            }
   \   00000158   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000015C   0xE7F5             B.N      ??CRYP_AES_CCM_11
   \                     ??CRYP_AES_CCM_12: (+1)
   \   0000015E   0xF8DD 0x90B8      LDR      R9,[SP, #+184]
   1209            
   1210            blockb0[14] = ((ILength >> 8) & 0xFF);
   \   00000162   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   00000166   0xF88D 0x0016      STRB     R0,[SP, #+22]
   1211            blockb0[15] = (ILength & 0xFF);
   \   0000016A   0x4648             MOV      R0,R9
   \   0000016C   0xF88D 0x0017      STRB     R0,[SP, #+23]
   1212            
   1213            /************************* Formatting the initial counter *******************/
   1214            /* Byte 0:
   1215               Bits 7 and 6 are reserved and shall be set to 0
   1216               Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
   1217               are distinct from B0
   1218               Bits 0, 1, and 2 contain the same encoding of q as in B0
   1219            */
   1220            ctr[0] = blockb0[0] & 0x07;
   \   00000170   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000174   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000178   0xF88D 0x005C      STRB     R0,[SP, #+92]
   1221            /* byte 1 to NonceSize is the IV (Nonce) */
   1222            for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
   \   0000017C   0xF05F 0x0B01      MOVS     R11,#+1
   \   00000180   0xE007             B.N      ??CRYP_AES_CCM_13
   1223            {
   1224              ctr[loopcounter] = blockb0[loopcounter];
   \                     ??CRYP_AES_CCM_14: (+1)
   \   00000182   0xA802             ADD      R0,SP,#+8
   \   00000184   0xF810 0x000B      LDRB     R0,[R0, R11]
   \   00000188   0xA917             ADD      R1,SP,#+92
   \   0000018A   0xF801 0x000B      STRB     R0,[R1, R11]
   1225            }
   \   0000018E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??CRYP_AES_CCM_13: (+1)
   \   00000192   0x9821             LDR      R0,[SP, #+132]
   \   00000194   0x1C40             ADDS     R0,R0,#+1
   \   00000196   0x4583             CMP      R11,R0
   \   00000198   0xD3F3             BCC.N    ??CRYP_AES_CCM_14
   1226            /* Set the LSB to 1 */
   1227            ctr[15] |= 0x01;
   \   0000019A   0xF89D 0x006B      LDRB     R0,[SP, #+107]
   \   0000019E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000001A2   0xF88D 0x006B      STRB     R0,[SP, #+107]
   1228            
   1229            /* Crypto structures initialisation*/
   1230            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   000001A6   0xA80F             ADD      R0,SP,#+60
   \   000001A8   0x.... 0x....      BL       CRYP_KeyStructInit
   1231            
   1232            switch(Keysize)
   \   000001AC   0x982C             LDR      R0,[SP, #+176]
   \   000001AE   0x2880             CMP      R0,#+128
   \   000001B0   0xD005             BEQ.N    ??CRYP_AES_CCM_15
   \   000001B2   0x28C0             CMP      R0,#+192
   \   000001B4   0xD015             BEQ.N    ??CRYP_AES_CCM_16
   \   000001B6   0xF5B0 0x7F80      CMP      R0,#+256
   \   000001BA   0xD02D             BEQ.N    ??CRYP_AES_CCM_17
   \   000001BC   0xE04F             B.N      ??CRYP_AES_CCM_18
   1233            {
   1234              case 128:
   1235              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CCM_15: (+1)
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x900A             STR      R0,[SP, #+40]
   1236              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0xBA00             REV      R0,R0
   \   000001C6   0x9013             STR      R0,[SP, #+76]
   1237              keyaddr+=4;
   \   000001C8   0x1D24             ADDS     R4,R4,#+4
   1238              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000001CA   0x6820             LDR      R0,[R4, #+0]
   \   000001CC   0xBA00             REV      R0,R0
   \   000001CE   0x9014             STR      R0,[SP, #+80]
   1239              keyaddr+=4;
   \   000001D0   0x1D24             ADDS     R4,R4,#+4
   1240              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000001D2   0x6820             LDR      R0,[R4, #+0]
   \   000001D4   0xBA00             REV      R0,R0
   \   000001D6   0x9015             STR      R0,[SP, #+84]
   1241              keyaddr+=4;
   \   000001D8   0x1D24             ADDS     R4,R4,#+4
   1242              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000001DA   0x6820             LDR      R0,[R4, #+0]
   \   000001DC   0xBA00             REV      R0,R0
   \   000001DE   0x9016             STR      R0,[SP, #+88]
   1243              break;
   \   000001E0   0xE03D             B.N      ??CRYP_AES_CCM_19
   1244              case 192:
   1245              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CCM_16: (+1)
   \   000001E2   0xF44F 0x7080      MOV      R0,#+256
   \   000001E6   0x900A             STR      R0,[SP, #+40]
   1246              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000001E8   0x6820             LDR      R0,[R4, #+0]
   \   000001EA   0xBA00             REV      R0,R0
   \   000001EC   0x9011             STR      R0,[SP, #+68]
   1247              keyaddr+=4;
   \   000001EE   0x1D24             ADDS     R4,R4,#+4
   1248              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000001F0   0x6820             LDR      R0,[R4, #+0]
   \   000001F2   0xBA00             REV      R0,R0
   \   000001F4   0x9012             STR      R0,[SP, #+72]
   1249              keyaddr+=4;
   \   000001F6   0x1D24             ADDS     R4,R4,#+4
   1250              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000001F8   0x6820             LDR      R0,[R4, #+0]
   \   000001FA   0xBA00             REV      R0,R0
   \   000001FC   0x9013             STR      R0,[SP, #+76]
   1251              keyaddr+=4;
   \   000001FE   0x1D24             ADDS     R4,R4,#+4
   1252              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000200   0x6820             LDR      R0,[R4, #+0]
   \   00000202   0xBA00             REV      R0,R0
   \   00000204   0x9014             STR      R0,[SP, #+80]
   1253              keyaddr+=4;
   \   00000206   0x1D24             ADDS     R4,R4,#+4
   1254              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000208   0x6820             LDR      R0,[R4, #+0]
   \   0000020A   0xBA00             REV      R0,R0
   \   0000020C   0x9015             STR      R0,[SP, #+84]
   1255              keyaddr+=4;
   \   0000020E   0x1D24             ADDS     R4,R4,#+4
   1256              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000210   0x6820             LDR      R0,[R4, #+0]
   \   00000212   0xBA00             REV      R0,R0
   \   00000214   0x9016             STR      R0,[SP, #+88]
   1257              break;
   \   00000216   0xE022             B.N      ??CRYP_AES_CCM_19
   1258              case 256:
   1259              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CCM_17: (+1)
   \   00000218   0xF44F 0x7000      MOV      R0,#+512
   \   0000021C   0x900A             STR      R0,[SP, #+40]
   1260              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   0000021E   0x6820             LDR      R0,[R4, #+0]
   \   00000220   0xBA00             REV      R0,R0
   \   00000222   0x900F             STR      R0,[SP, #+60]
   1261              keyaddr+=4;
   \   00000224   0x1D24             ADDS     R4,R4,#+4
   1262              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   00000226   0x6820             LDR      R0,[R4, #+0]
   \   00000228   0xBA00             REV      R0,R0
   \   0000022A   0x9010             STR      R0,[SP, #+64]
   1263              keyaddr+=4;
   \   0000022C   0x1D24             ADDS     R4,R4,#+4
   1264              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   0000022E   0x6820             LDR      R0,[R4, #+0]
   \   00000230   0xBA00             REV      R0,R0
   \   00000232   0x9011             STR      R0,[SP, #+68]
   1265              keyaddr+=4;
   \   00000234   0x1D24             ADDS     R4,R4,#+4
   1266              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000236   0x6820             LDR      R0,[R4, #+0]
   \   00000238   0xBA00             REV      R0,R0
   \   0000023A   0x9012             STR      R0,[SP, #+72]
   1267              keyaddr+=4;
   \   0000023C   0x1D24             ADDS     R4,R4,#+4
   1268              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000023E   0x6820             LDR      R0,[R4, #+0]
   \   00000240   0xBA00             REV      R0,R0
   \   00000242   0x9013             STR      R0,[SP, #+76]
   1269              keyaddr+=4;
   \   00000244   0x1D24             ADDS     R4,R4,#+4
   1270              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000246   0x6820             LDR      R0,[R4, #+0]
   \   00000248   0xBA00             REV      R0,R0
   \   0000024A   0x9014             STR      R0,[SP, #+80]
   1271              keyaddr+=4;
   \   0000024C   0x1D24             ADDS     R4,R4,#+4
   1272              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000024E   0x6820             LDR      R0,[R4, #+0]
   \   00000250   0xBA00             REV      R0,R0
   \   00000252   0x9015             STR      R0,[SP, #+84]
   1273              keyaddr+=4;
   \   00000254   0x1D24             ADDS     R4,R4,#+4
   1274              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000256   0x6820             LDR      R0,[R4, #+0]
   \   00000258   0xBA00             REV      R0,R0
   \   0000025A   0x9016             STR      R0,[SP, #+88]
   1275              break;
   \   0000025C   0xE7FF             B.N      ??CRYP_AES_CCM_19
   1276              default:
   1277              break;
   1278            }
   1279            
   1280            /* CRYP Initialization Vectors */
   1281            AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
   \                     ??CRYP_AES_CCM_18: (+1)
   \                     ??CRYP_AES_CCM_19: (+1)
   \   0000025E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000262   0xBA00             REV      R0,R0
   \   00000264   0x901B             STR      R0,[SP, #+108]
   1282            ctraddr+=4;
   \   00000266   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1283            AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
   \   0000026A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000026E   0xBA00             REV      R0,R0
   \   00000270   0x901C             STR      R0,[SP, #+112]
   1284            ctraddr+=4;
   \   00000272   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1285            AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
   \   00000276   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000027A   0xBA00             REV      R0,R0
   \   0000027C   0x901D             STR      R0,[SP, #+116]
   1286            ctraddr+=4;
   \   0000027E   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1287            AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
   \   00000282   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000286   0xBA00             REV      R0,R0
   \   00000288   0x901E             STR      R0,[SP, #+120]
   1288            
   1289            /*------------------ AES Encryption ------------------*/
   1290            if(Mode == MODE_ENCRYPT) /* AES encryption */
   \   0000028A   0xF89D 0x007C      LDRB     R0,[SP, #+124]
   \   0000028E   0x2801             CMP      R0,#+1
   \   00000290   0xF040 0x8105      BNE.W    ??CRYP_AES_CCM_20
   1291            {
   1292              /* Flush IN/OUT FIFOs */
   1293              CRYP_FIFOFlush();
   \   00000294   0x.... 0x....      BL       CRYP_FIFOFlush
   1294              
   1295              /* Key Initialisation */
   1296              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   00000298   0xA80F             ADD      R0,SP,#+60
   \   0000029A   0x.... 0x....      BL       CRYP_KeyInit
   1297              
   1298              /* CRYP Initialization Vectors */
   1299              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   0000029E   0xA81B             ADD      R0,SP,#+108
   \   000002A0   0x.... 0x....      BL       CRYP_IVInit
   1300              
   1301              /* Crypto Init for Key preparation for decryption process */
   1302              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \   000002A4   0x2000             MOVS     R0,#+0
   \   000002A6   0x9007             STR      R0,[SP, #+28]
   1303              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
   \   000002A8   0xF05F 0x1008      MOVS     R0,#+524296
   \   000002AC   0x9008             STR      R0,[SP, #+32]
   1304              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   000002AE   0x2080             MOVS     R0,#+128
   \   000002B0   0x9009             STR      R0,[SP, #+36]
   1305              CRYP_Init(&AES_CRYP_InitStructure);
   \   000002B2   0xA807             ADD      R0,SP,#+28
   \   000002B4   0x.... 0x....      BL       CRYP_Init
   1306              
   1307              /***************************** Init phase *********************************/
   1308              /* Select init phase */
   1309              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   000002B8   0x2000             MOVS     R0,#+0
   \   000002BA   0x.... 0x....      BL       CRYP_PhaseConfig
   1310              
   1311              b0addr = (uint32_t)blockb0;
   \   000002BE   0xF10D 0x0B08      ADD      R11,SP,#+8
   1312              /* Write the blockb0 block in the IN FIFO */
   1313              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000002C2   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002C6   0x.... 0x....      BL       CRYP_DataIn
   1314              b0addr+=4;
   \   000002CA   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1315              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000002CE   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002D2   0x.... 0x....      BL       CRYP_DataIn
   1316              b0addr+=4;
   \   000002D6   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1317              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000002DA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002DE   0x.... 0x....      BL       CRYP_DataIn
   1318              b0addr+=4;
   \   000002E2   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1319              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000002E6   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000002EA   0x.... 0x....      BL       CRYP_DataIn
   1320              
   1321              /* Enable Crypto processor */
   1322              CRYP_Cmd(ENABLE);
   \   000002EE   0x2001             MOVS     R0,#+1
   \   000002F0   0x.... 0x....      BL       CRYP_Cmd
   1323              
   1324              /* Wait for CRYPEN bit to be 0 */
   1325              while(CRYP_GetCmdStatus() == ENABLE);
   \                     ??CRYP_AES_CCM_21: (+1)
   \   000002F4   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000002F8   0x2801             CMP      R0,#+1
   \   000002FA   0xD0FB             BEQ.N    ??CRYP_AES_CCM_21
   1326              
   1327              /***************************** header phase *******************************/
   1328              if(headersize != 0)
   \   000002FC   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000300   0xD03B             BEQ.N    ??CRYP_AES_CCM_22
   1329              {
   1330                /* Select header phase */
   1331                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   00000302   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000306   0x.... 0x....      BL       CRYP_PhaseConfig
   1332                
   1333                /* Enable Crypto processor */
   1334                CRYP_Cmd(ENABLE);
   \   0000030A   0x2001             MOVS     R0,#+1
   \   0000030C   0x.... 0x....      BL       CRYP_Cmd
   1335                
   1336                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000310   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000314   0x2800             CMP      R0,#+0
   \   00000316   0xD101             BNE.N    ??CRYP_AES_CCM_23
   1337                {
   1338                   /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1339                      the CRYP peripheral (please check the device sales type. */
   1340                   return(ERROR);
   \   00000318   0x2000             MOVS     R0,#+0
   \   0000031A   0xE1D7             B.N      ??CRYP_AES_CCM_24
   1341                }
   1342                
   1343                for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
   \                     ??CRYP_AES_CCM_23: (+1)
   \   0000031C   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000320   0xE016             B.N      ??CRYP_AES_CCM_25
   1344                {
   1345                  /* Wait until the IFEM flag is reset */
   1346                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
   \                     ??CRYP_AES_CCM_26: (+1)
   \   00000322   0x2001             MOVS     R0,#+1
   \   00000324   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000328   0x2800             CMP      R0,#+0
   \   0000032A   0xD0FA             BEQ.N    ??CRYP_AES_CCM_26
   1347                  
   1348                  /* Write the Input block in the IN FIFO */
   1349                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000032C   0x6838             LDR      R0,[R7, #+0]
   \   0000032E   0x.... 0x....      BL       CRYP_DataIn
   1350                  headeraddr+=4;
   \   00000332   0x1D3F             ADDS     R7,R7,#+4
   1351                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000334   0x6838             LDR      R0,[R7, #+0]
   \   00000336   0x.... 0x....      BL       CRYP_DataIn
   1352                  headeraddr+=4;
   \   0000033A   0x1D3F             ADDS     R7,R7,#+4
   1353                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000033C   0x6838             LDR      R0,[R7, #+0]
   \   0000033E   0x.... 0x....      BL       CRYP_DataIn
   1354                  headeraddr+=4;
   \   00000342   0x1D3F             ADDS     R7,R7,#+4
   1355                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000344   0x6838             LDR      R0,[R7, #+0]
   \   00000346   0x.... 0x....      BL       CRYP_DataIn
   1356                  headeraddr+=4;
   \   0000034A   0x1D3F             ADDS     R7,R7,#+4
   1357                }
   \   0000034C   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_CCM_25: (+1)
   \   00000350   0x45C3             CMP      R11,R8
   \   00000352   0xD3E6             BCC.N    ??CRYP_AES_CCM_26
   1358                
   1359                /* Wait until the complete message has been processed */
   1360                counter = 0;
   \   00000354   0x2000             MOVS     R0,#+0
   \   00000356   0x9000             STR      R0,[SP, #+0]
   1361                do
   1362                {
   1363                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CCM_27: (+1)
   \   00000358   0x2010             MOVS     R0,#+16
   \   0000035A   0x.... 0x....      BL       CRYP_GetFlagStatus
   1364                  counter++;
   \   0000035E   0x9900             LDR      R1,[SP, #+0]
   \   00000360   0x1C49             ADDS     R1,R1,#+1
   \   00000362   0x9100             STR      R1,[SP, #+0]
   1365                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000364   0x9900             LDR      R1,[SP, #+0]
   \   00000366   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000036A   0xD001             BEQ.N    ??CRYP_AES_CCM_28
   \   0000036C   0x2800             CMP      R0,#+0
   \   0000036E   0xD1F3             BNE.N    ??CRYP_AES_CCM_27
   1366          
   1367                if (busystatus != RESET)
   \                     ??CRYP_AES_CCM_28: (+1)
   \   00000370   0x2800             CMP      R0,#+0
   \   00000372   0xD002             BEQ.N    ??CRYP_AES_CCM_22
   1368                {
   1369                  status = ERROR;
   \   00000374   0x2000             MOVS     R0,#+0
   \   00000376   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1370                }
   1371              }
   1372              
   1373              /**************************** payload phase *******************************/
   1374              if(ILength != 0)
   \                     ??CRYP_AES_CCM_22: (+1)
   \   0000037A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000037E   0xD055             BEQ.N    ??CRYP_AES_CCM_29
   1375              {
   1376                /* Select payload phase */
   1377                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   00000380   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000384   0x.... 0x....      BL       CRYP_PhaseConfig
   1378                
   1379                /* Enable Crypto processor */
   1380                CRYP_Cmd(ENABLE);
   \   00000388   0x2001             MOVS     R0,#+1
   \   0000038A   0x.... 0x....      BL       CRYP_Cmd
   1381                
   1382                if(CRYP_GetCmdStatus() == DISABLE)
   \   0000038E   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000392   0x2800             CMP      R0,#+0
   \   00000394   0xD101             BNE.N    ??CRYP_AES_CCM_30
   1383                {
   1384                  /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1385                     the CRYP peripheral (please check the device sales type. */
   1386                  return(ERROR);
   \   00000396   0x2000             MOVS     R0,#+0
   \   00000398   0xE198             B.N      ??CRYP_AES_CCM_24
   1387                }
   1388                
   1389                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_CCM_30: (+1)
   \   0000039A   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000039E   0xE016             B.N      ??CRYP_AES_CCM_31
   1390                {
   1391                  /* Wait until the IFEM flag is reset */
   1392                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
   1393                  /* Write the Input block in the IN FIFO */
   1394                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1395                  inputaddr+=4;
   1396                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1397                  inputaddr+=4;
   1398                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1399                  inputaddr+=4;
   1400                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1401                  inputaddr+=4;
   1402                  
   1403                  /* Wait until the complete message has been processed */
   1404                  counter = 0;
   1405                  do
   1406                  {
   1407                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1408                    counter++;
   1409                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1410          
   1411                  if (busystatus != RESET)
   1412                  {
   1413                    status = ERROR;
   1414                  }
   1415                  else
   1416                  {
   1417                    /* Wait until the OFNE flag is reset */
   1418                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
   \                     ??CRYP_AES_CCM_32: (+1)
   \   000003A0   0x2004             MOVS     R0,#+4
   \   000003A2   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000003A6   0x2800             CMP      R0,#+0
   \   000003A8   0xD0FA             BEQ.N    ??CRYP_AES_CCM_32
   1419                    
   1420                    /* Read the Output block from the Output FIFO */
   1421                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003AA   0x.... 0x....      BL       CRYP_DataOut
   \   000003AE   0x6030             STR      R0,[R6, #+0]
   1422                    outputaddr+=4;
   \   000003B0   0x1D36             ADDS     R6,R6,#+4
   1423                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003B2   0x.... 0x....      BL       CRYP_DataOut
   \   000003B6   0x6030             STR      R0,[R6, #+0]
   1424                    outputaddr+=4;
   \   000003B8   0x1D36             ADDS     R6,R6,#+4
   1425                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003BA   0x.... 0x....      BL       CRYP_DataOut
   \   000003BE   0x6030             STR      R0,[R6, #+0]
   1426                    outputaddr+=4;
   \   000003C0   0x1D36             ADDS     R6,R6,#+4
   1427                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003C2   0x.... 0x....      BL       CRYP_DataOut
   \   000003C6   0x6030             STR      R0,[R6, #+0]
   1428                    outputaddr+=4;
   \   000003C8   0x1D36             ADDS     R6,R6,#+4
   1429                  }
   \                     ??CRYP_AES_CCM_33: (+1)
   \   000003CA   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_CCM_31: (+1)
   \   000003CE   0x45CB             CMP      R11,R9
   \   000003D0   0xD22C             BCS.N    ??CRYP_AES_CCM_29
   \   000003D2   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000003D6   0x2800             CMP      R0,#+0
   \   000003D8   0xD028             BEQ.N    ??CRYP_AES_CCM_29
   \                     ??CRYP_AES_CCM_34: (+1)
   \   000003DA   0x2001             MOVS     R0,#+1
   \   000003DC   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000003E0   0x2800             CMP      R0,#+0
   \   000003E2   0xD0FA             BEQ.N    ??CRYP_AES_CCM_34
   \   000003E4   0x6828             LDR      R0,[R5, #+0]
   \   000003E6   0x.... 0x....      BL       CRYP_DataIn
   \   000003EA   0x1D2D             ADDS     R5,R5,#+4
   \   000003EC   0x6828             LDR      R0,[R5, #+0]
   \   000003EE   0x.... 0x....      BL       CRYP_DataIn
   \   000003F2   0x1D2D             ADDS     R5,R5,#+4
   \   000003F4   0x6828             LDR      R0,[R5, #+0]
   \   000003F6   0x.... 0x....      BL       CRYP_DataIn
   \   000003FA   0x1D2D             ADDS     R5,R5,#+4
   \   000003FC   0x6828             LDR      R0,[R5, #+0]
   \   000003FE   0x.... 0x....      BL       CRYP_DataIn
   \   00000402   0x1D2D             ADDS     R5,R5,#+4
   \   00000404   0x2000             MOVS     R0,#+0
   \   00000406   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CCM_35: (+1)
   \   00000408   0x2010             MOVS     R0,#+16
   \   0000040A   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000040E   0x9900             LDR      R1,[SP, #+0]
   \   00000410   0x1C49             ADDS     R1,R1,#+1
   \   00000412   0x9100             STR      R1,[SP, #+0]
   \   00000414   0x9900             LDR      R1,[SP, #+0]
   \   00000416   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000041A   0xD001             BEQ.N    ??CRYP_AES_CCM_36
   \   0000041C   0x2800             CMP      R0,#+0
   \   0000041E   0xD1F3             BNE.N    ??CRYP_AES_CCM_35
   \                     ??CRYP_AES_CCM_36: (+1)
   \   00000420   0x2800             CMP      R0,#+0
   \   00000422   0xD0BD             BEQ.N    ??CRYP_AES_CCM_32
   \   00000424   0x2000             MOVS     R0,#+0
   \   00000426   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000042A   0xE7CE             B.N      ??CRYP_AES_CCM_33
   1430                }
   1431              }
   1432              
   1433              /***************************** final phase ********************************/
   1434              /* Select final phase */
   1435              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_CCM_29: (+1)
   \   0000042C   0xF45F 0x3040      MOVS     R0,#+196608
   \   00000430   0x.... 0x....      BL       CRYP_PhaseConfig
   1436              
   1437              /* Enable Crypto processor */
   1438              CRYP_Cmd(ENABLE);
   \   00000434   0x2001             MOVS     R0,#+1
   \   00000436   0x.... 0x....      BL       CRYP_Cmd
   1439              
   1440              if(CRYP_GetCmdStatus() == DISABLE)
   \   0000043A   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000043E   0x2800             CMP      R0,#+0
   \   00000440   0xD101             BNE.N    ??CRYP_AES_CCM_37
   1441              {
   1442                /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1443                   the CRYP peripheral (please check the device sales type. */
   1444                return(ERROR);
   \   00000442   0x2000             MOVS     R0,#+0
   \   00000444   0xE142             B.N      ??CRYP_AES_CCM_24
   1445              }
   1446              
   1447              ctraddr = (uint32_t)ctr;
   \                     ??CRYP_AES_CCM_37: (+1)
   \   00000446   0xF10D 0x0A5C      ADD      R10,SP,#+92
   1448              /* Write the counter block in the IN FIFO */
   1449              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   0000044A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000044E   0x.... 0x....      BL       CRYP_DataIn
   1450              ctraddr+=4;
   \   00000452   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1451              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   00000456   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000045A   0x.... 0x....      BL       CRYP_DataIn
   1452              ctraddr+=4;
   \   0000045E   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1453              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   00000462   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000466   0x.... 0x....      BL       CRYP_DataIn
   1454              ctraddr+=4;
   \   0000046A   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1455              /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
   1456              CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
   \   0000046E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000472   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000476   0x.... 0x....      BL       CRYP_DataIn
   1457              
   1458              /* Wait until the OFNE flag is reset */
   1459              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
   \                     ??CRYP_AES_CCM_38: (+1)
   \   0000047A   0x2004             MOVS     R0,#+4
   \   0000047C   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000480   0x2800             CMP      R0,#+0
   \   00000482   0xD0FA             BEQ.N    ??CRYP_AES_CCM_38
   1460              
   1461              /* Read the Auth TAG in the IN FIFO */
   1462              temptag[0] = CRYP_DataOut();
   \   00000484   0x.... 0x....      BL       CRYP_DataOut
   \   00000488   0x900B             STR      R0,[SP, #+44]
   1463              temptag[1] = CRYP_DataOut();
   \   0000048A   0x.... 0x....      BL       CRYP_DataOut
   \   0000048E   0x900C             STR      R0,[SP, #+48]
   1464              temptag[2] = CRYP_DataOut();
   \   00000490   0x.... 0x....      BL       CRYP_DataOut
   \   00000494   0x900D             STR      R0,[SP, #+52]
   1465              temptag[3] = CRYP_DataOut();
   \   00000496   0x.... 0x....      BL       CRYP_DataOut
   \   0000049A   0x900E             STR      R0,[SP, #+56]
   \   0000049C   0xE103             B.N      ??CRYP_AES_CCM_39
   1466            }
   1467            /*------------------ AES Decryption ------------------*/
   1468            else /* AES decryption */
   1469            {
   1470              /* Flush IN/OUT FIFOs */
   1471              CRYP_FIFOFlush();
   \                     ??CRYP_AES_CCM_20: (+1)
   \   0000049E   0x.... 0x....      BL       CRYP_FIFOFlush
   1472              
   1473              /* Key Initialisation */
   1474              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   000004A2   0xA80F             ADD      R0,SP,#+60
   \   000004A4   0x.... 0x....      BL       CRYP_KeyInit
   1475              
   1476              /* CRYP Initialization Vectors */
   1477              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   000004A8   0xA81B             ADD      R0,SP,#+108
   \   000004AA   0x.... 0x....      BL       CRYP_IVInit
   1478              
   1479              /* Crypto Init for Key preparation for decryption process */
   1480              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   000004AE   0x2004             MOVS     R0,#+4
   \   000004B0   0x9007             STR      R0,[SP, #+28]
   1481              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
   \   000004B2   0xF05F 0x1008      MOVS     R0,#+524296
   \   000004B6   0x9008             STR      R0,[SP, #+32]
   1482              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   000004B8   0x2080             MOVS     R0,#+128
   \   000004BA   0x9009             STR      R0,[SP, #+36]
   1483              CRYP_Init(&AES_CRYP_InitStructure);
   \   000004BC   0xA807             ADD      R0,SP,#+28
   \   000004BE   0x.... 0x....      BL       CRYP_Init
   1484              
   1485              /***************************** Init phase *********************************/
   1486              /* Select init phase */
   1487              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   000004C2   0x2000             MOVS     R0,#+0
   \   000004C4   0x.... 0x....      BL       CRYP_PhaseConfig
   1488              
   1489              b0addr = (uint32_t)blockb0;
   \   000004C8   0xF10D 0x0B08      ADD      R11,SP,#+8
   1490              /* Write the blockb0 block in the IN FIFO */
   1491              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000004CC   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000004D0   0x.... 0x....      BL       CRYP_DataIn
   1492              b0addr+=4;
   \   000004D4   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1493              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000004D8   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000004DC   0x.... 0x....      BL       CRYP_DataIn
   1494              b0addr+=4;
   \   000004E0   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1495              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000004E4   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000004E8   0x.... 0x....      BL       CRYP_DataIn
   1496              b0addr+=4;
   \   000004EC   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1497              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   000004F0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000004F4   0x.... 0x....      BL       CRYP_DataIn
   1498              
   1499              /* Enable Crypto processor */
   1500              CRYP_Cmd(ENABLE);
   \   000004F8   0x2001             MOVS     R0,#+1
   \   000004FA   0x.... 0x....      BL       CRYP_Cmd
   1501              
   1502              /* Wait for CRYPEN bit to be 0 */
   1503              while(CRYP_GetCmdStatus() == ENABLE);
   \                     ??CRYP_AES_CCM_40: (+1)
   \   000004FE   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000502   0x2801             CMP      R0,#+1
   \   00000504   0xD0FB             BEQ.N    ??CRYP_AES_CCM_40
   1504              
   1505              /***************************** header phase *******************************/
   1506              if(headersize != 0)
   \   00000506   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000050A   0xD03B             BEQ.N    ??CRYP_AES_CCM_41
   1507              {
   1508                /* Select header phase */
   1509                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   0000050C   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000510   0x.... 0x....      BL       CRYP_PhaseConfig
   1510                
   1511                /* Enable Crypto processor */
   1512                CRYP_Cmd(ENABLE);
   \   00000514   0x2001             MOVS     R0,#+1
   \   00000516   0x.... 0x....      BL       CRYP_Cmd
   1513                
   1514                if(CRYP_GetCmdStatus() == DISABLE)
   \   0000051A   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000051E   0x2800             CMP      R0,#+0
   \   00000520   0xD101             BNE.N    ??CRYP_AES_CCM_42
   1515                {
   1516                  /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1517                     the CRYP peripheral (please check the device sales type. */
   1518                  return(ERROR);
   \   00000522   0x2000             MOVS     R0,#+0
   \   00000524   0xE0D2             B.N      ??CRYP_AES_CCM_24
   1519                }
   1520                
   1521                for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
   \                     ??CRYP_AES_CCM_42: (+1)
   \   00000526   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000052A   0xE016             B.N      ??CRYP_AES_CCM_43
   1522                {
   1523                  /* Wait until the IFEM flag is reset */
   1524                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
   \                     ??CRYP_AES_CCM_44: (+1)
   \   0000052C   0x2001             MOVS     R0,#+1
   \   0000052E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000532   0x2800             CMP      R0,#+0
   \   00000534   0xD0FA             BEQ.N    ??CRYP_AES_CCM_44
   1525                  
   1526                  /* Write the Input block in the IN FIFO */
   1527                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000536   0x6838             LDR      R0,[R7, #+0]
   \   00000538   0x.... 0x....      BL       CRYP_DataIn
   1528                  headeraddr+=4;
   \   0000053C   0x1D3F             ADDS     R7,R7,#+4
   1529                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000053E   0x6838             LDR      R0,[R7, #+0]
   \   00000540   0x.... 0x....      BL       CRYP_DataIn
   1530                  headeraddr+=4;
   \   00000544   0x1D3F             ADDS     R7,R7,#+4
   1531                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000546   0x6838             LDR      R0,[R7, #+0]
   \   00000548   0x.... 0x....      BL       CRYP_DataIn
   1532                  headeraddr+=4;
   \   0000054C   0x1D3F             ADDS     R7,R7,#+4
   1533                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000054E   0x6838             LDR      R0,[R7, #+0]
   \   00000550   0x.... 0x....      BL       CRYP_DataIn
   1534                  headeraddr+=4;
   \   00000554   0x1D3F             ADDS     R7,R7,#+4
   1535                }
   \   00000556   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_CCM_43: (+1)
   \   0000055A   0x45C3             CMP      R11,R8
   \   0000055C   0xD3E6             BCC.N    ??CRYP_AES_CCM_44
   1536                
   1537                /* Wait until the complete message has been processed */
   1538                counter = 0;
   \   0000055E   0x2000             MOVS     R0,#+0
   \   00000560   0x9000             STR      R0,[SP, #+0]
   1539                do
   1540                {
   1541                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CCM_45: (+1)
   \   00000562   0x2010             MOVS     R0,#+16
   \   00000564   0x.... 0x....      BL       CRYP_GetFlagStatus
   1542                  counter++;
   \   00000568   0x9900             LDR      R1,[SP, #+0]
   \   0000056A   0x1C49             ADDS     R1,R1,#+1
   \   0000056C   0x9100             STR      R1,[SP, #+0]
   1543                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   0000056E   0x9900             LDR      R1,[SP, #+0]
   \   00000570   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000574   0xD001             BEQ.N    ??CRYP_AES_CCM_46
   \   00000576   0x2800             CMP      R0,#+0
   \   00000578   0xD1F3             BNE.N    ??CRYP_AES_CCM_45
   1544          
   1545                if (busystatus != RESET)
   \                     ??CRYP_AES_CCM_46: (+1)
   \   0000057A   0x2800             CMP      R0,#+0
   \   0000057C   0xD002             BEQ.N    ??CRYP_AES_CCM_41
   1546                {
   1547                  status = ERROR;
   \   0000057E   0x2000             MOVS     R0,#+0
   \   00000580   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1548                }
   1549              }
   1550              
   1551              /**************************** payload phase *******************************/
   1552              if(ILength != 0)
   \                     ??CRYP_AES_CCM_41: (+1)
   \   00000584   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000588   0xD055             BEQ.N    ??CRYP_AES_CCM_47
   1553              {
   1554                /* Select payload phase */
   1555                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   0000058A   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000058E   0x.... 0x....      BL       CRYP_PhaseConfig
   1556          
   1557                /* Enable Crypto processor */
   1558                CRYP_Cmd(ENABLE);
   \   00000592   0x2001             MOVS     R0,#+1
   \   00000594   0x.... 0x....      BL       CRYP_Cmd
   1559                
   1560                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000598   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000059C   0x2800             CMP      R0,#+0
   \   0000059E   0xD101             BNE.N    ??CRYP_AES_CCM_48
   1561                {
   1562                  /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1563                     the CRYP peripheral (please check the device sales type. */
   1564                  return(ERROR);
   \   000005A0   0x2000             MOVS     R0,#+0
   \   000005A2   0xE093             B.N      ??CRYP_AES_CCM_24
   1565                }
   1566                
   1567                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_CCM_48: (+1)
   \   000005A4   0xF05F 0x0B00      MOVS     R11,#+0
   \   000005A8   0xE016             B.N      ??CRYP_AES_CCM_49
   1568                {
   1569                  /* Wait until the IFEM flag is reset */
   1570                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
   1571                  /* Write the Input block in the IN FIFO */
   1572                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1573                  inputaddr+=4;
   1574                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1575                  inputaddr+=4;
   1576                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1577                  inputaddr+=4;
   1578                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1579                  inputaddr+=4;
   1580                  
   1581                  /* Wait until the complete message has been processed */
   1582                  counter = 0;
   1583                  do
   1584                  {
   1585                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1586                    counter++;
   1587                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1588          
   1589                  if (busystatus != RESET)
   1590                  {
   1591                    status = ERROR;
   1592                  }
   1593                  else
   1594                  {
   1595                    /* Wait until the OFNE flag is reset */
   1596                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
   \                     ??CRYP_AES_CCM_50: (+1)
   \   000005AA   0x2004             MOVS     R0,#+4
   \   000005AC   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000005B0   0x2800             CMP      R0,#+0
   \   000005B2   0xD0FA             BEQ.N    ??CRYP_AES_CCM_50
   1597                    
   1598                    /* Read the Output block from the Output FIFO */
   1599                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000005B4   0x.... 0x....      BL       CRYP_DataOut
   \   000005B8   0x6030             STR      R0,[R6, #+0]
   1600                    outputaddr+=4;
   \   000005BA   0x1D36             ADDS     R6,R6,#+4
   1601                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000005BC   0x.... 0x....      BL       CRYP_DataOut
   \   000005C0   0x6030             STR      R0,[R6, #+0]
   1602                    outputaddr+=4;
   \   000005C2   0x1D36             ADDS     R6,R6,#+4
   1603                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000005C4   0x.... 0x....      BL       CRYP_DataOut
   \   000005C8   0x6030             STR      R0,[R6, #+0]
   1604                    outputaddr+=4;
   \   000005CA   0x1D36             ADDS     R6,R6,#+4
   1605                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000005CC   0x.... 0x....      BL       CRYP_DataOut
   \   000005D0   0x6030             STR      R0,[R6, #+0]
   1606                    outputaddr+=4;
   \   000005D2   0x1D36             ADDS     R6,R6,#+4
   1607                  }
   \                     ??CRYP_AES_CCM_51: (+1)
   \   000005D4   0xF11B 0x0B10      ADDS     R11,R11,#+16
   \                     ??CRYP_AES_CCM_49: (+1)
   \   000005D8   0x45CB             CMP      R11,R9
   \   000005DA   0xD22C             BCS.N    ??CRYP_AES_CCM_47
   \   000005DC   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000005E0   0x2800             CMP      R0,#+0
   \   000005E2   0xD028             BEQ.N    ??CRYP_AES_CCM_47
   \                     ??CRYP_AES_CCM_52: (+1)
   \   000005E4   0x2001             MOVS     R0,#+1
   \   000005E6   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000005EA   0x2800             CMP      R0,#+0
   \   000005EC   0xD0FA             BEQ.N    ??CRYP_AES_CCM_52
   \   000005EE   0x6828             LDR      R0,[R5, #+0]
   \   000005F0   0x.... 0x....      BL       CRYP_DataIn
   \   000005F4   0x1D2D             ADDS     R5,R5,#+4
   \   000005F6   0x6828             LDR      R0,[R5, #+0]
   \   000005F8   0x.... 0x....      BL       CRYP_DataIn
   \   000005FC   0x1D2D             ADDS     R5,R5,#+4
   \   000005FE   0x6828             LDR      R0,[R5, #+0]
   \   00000600   0x.... 0x....      BL       CRYP_DataIn
   \   00000604   0x1D2D             ADDS     R5,R5,#+4
   \   00000606   0x6828             LDR      R0,[R5, #+0]
   \   00000608   0x.... 0x....      BL       CRYP_DataIn
   \   0000060C   0x1D2D             ADDS     R5,R5,#+4
   \   0000060E   0x2000             MOVS     R0,#+0
   \   00000610   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CCM_53: (+1)
   \   00000612   0x2010             MOVS     R0,#+16
   \   00000614   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000618   0x9900             LDR      R1,[SP, #+0]
   \   0000061A   0x1C49             ADDS     R1,R1,#+1
   \   0000061C   0x9100             STR      R1,[SP, #+0]
   \   0000061E   0x9900             LDR      R1,[SP, #+0]
   \   00000620   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000624   0xD001             BEQ.N    ??CRYP_AES_CCM_54
   \   00000626   0x2800             CMP      R0,#+0
   \   00000628   0xD1F3             BNE.N    ??CRYP_AES_CCM_53
   \                     ??CRYP_AES_CCM_54: (+1)
   \   0000062A   0x2800             CMP      R0,#+0
   \   0000062C   0xD0BD             BEQ.N    ??CRYP_AES_CCM_50
   \   0000062E   0x2000             MOVS     R0,#+0
   \   00000630   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000634   0xE7CE             B.N      ??CRYP_AES_CCM_51
   1608                }
   1609              }
   1610              
   1611              /***************************** final phase ********************************/
   1612              /* Select final phase */
   1613              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_CCM_47: (+1)
   \   00000636   0xF45F 0x3040      MOVS     R0,#+196608
   \   0000063A   0x.... 0x....      BL       CRYP_PhaseConfig
   1614              
   1615              /* Enable Crypto processor */
   1616              CRYP_Cmd(ENABLE);
   \   0000063E   0x2001             MOVS     R0,#+1
   \   00000640   0x.... 0x....      BL       CRYP_Cmd
   1617              
   1618              if(CRYP_GetCmdStatus() == DISABLE)
   \   00000644   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000648   0x2800             CMP      R0,#+0
   \   0000064A   0xD101             BNE.N    ??CRYP_AES_CCM_55
   1619              {
   1620                /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
   1621                   the CRYP peripheral (please check the device sales type. */
   1622                return(ERROR);
   \   0000064C   0x2000             MOVS     R0,#+0
   \   0000064E   0xE03D             B.N      ??CRYP_AES_CCM_24
   1623              }
   1624              
   1625              ctraddr = (uint32_t)ctr;
   \                     ??CRYP_AES_CCM_55: (+1)
   \   00000650   0xF10D 0x0A5C      ADD      R10,SP,#+92
   1626              /* Write the counter block in the IN FIFO */
   1627              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   00000654   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000658   0x.... 0x....      BL       CRYP_DataIn
   1628              ctraddr+=4;
   \   0000065C   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1629              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   00000660   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000664   0x.... 0x....      BL       CRYP_DataIn
   1630              ctraddr+=4;
   \   00000668   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1631              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   0000066C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000670   0x.... 0x....      BL       CRYP_DataIn
   1632              ctraddr+=4;
   \   00000674   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1633              /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
   1634              CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
   \   00000678   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000067C   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000680   0x.... 0x....      BL       CRYP_DataIn
   1635              
   1636              /* Wait until the OFNE flag is reset */
   1637              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
   \                     ??CRYP_AES_CCM_56: (+1)
   \   00000684   0x2004             MOVS     R0,#+4
   \   00000686   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000068A   0x2800             CMP      R0,#+0
   \   0000068C   0xD0FA             BEQ.N    ??CRYP_AES_CCM_56
   1638              
   1639              /* Read the Authentaication TAG (MAC) in the IN FIFO */
   1640              temptag[0] = CRYP_DataOut();
   \   0000068E   0x.... 0x....      BL       CRYP_DataOut
   \   00000692   0x900B             STR      R0,[SP, #+44]
   1641              temptag[1] = CRYP_DataOut();
   \   00000694   0x.... 0x....      BL       CRYP_DataOut
   \   00000698   0x900C             STR      R0,[SP, #+48]
   1642              temptag[2] = CRYP_DataOut();
   \   0000069A   0x.... 0x....      BL       CRYP_DataOut
   \   0000069E   0x900D             STR      R0,[SP, #+52]
   1643              temptag[3] = CRYP_DataOut();
   \   000006A0   0x.... 0x....      BL       CRYP_DataOut
   \   000006A4   0x900E             STR      R0,[SP, #+56]
   1644            }
   1645            
   1646            /* Copy temporary authentication TAG in user TAG buffer */
   1647            for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
   \                     ??CRYP_AES_CCM_39: (+1)
   \   000006A6   0xF05F 0x0B00      MOVS     R11,#+0
   \   000006AA   0xE007             B.N      ??CRYP_AES_CCM_57
   1648            {
   1649              /* Set the authentication TAG buffer */
   1650              *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
   \                     ??CRYP_AES_CCM_58: (+1)
   \   000006AC   0xA80B             ADD      R0,SP,#+44
   \   000006AE   0xF810 0x000B      LDRB     R0,[R0, R11]
   \   000006B2   0x9906             LDR      R1,[SP, #+24]
   \   000006B4   0xF801 0x000B      STRB     R0,[R1, R11]
   1651            }
   \   000006B8   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??CRYP_AES_CCM_57: (+1)
   \   000006BC   0x9834             LDR      R0,[SP, #+208]
   \   000006BE   0x4583             CMP      R11,R0
   \   000006C0   0xD3F4             BCC.N    ??CRYP_AES_CCM_58
   1652            
   1653            /* Disable Crypto */
   1654            CRYP_Cmd(DISABLE);
   \   000006C2   0x2000             MOVS     R0,#+0
   \   000006C4   0x.... 0x....      BL       CRYP_Cmd
   1655          
   1656            return status;
   \   000006C8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \                     ??CRYP_AES_CCM_24: (+1)
   \   000006CC   0xB023             ADD      SP,SP,#+140
   \   000006CE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1657          }

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   1658          
   1659          /**
   1660            * @}
   1661            */ 
   1662          
   1663          /**
   1664            * @}
   1665            */ 
   1666          
   1667          /**
   1668            * @}
   1669            */ 
   1670          
   1671          /**
   1672            * @}
   1673            */ 
   1674          
   1675          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
   1676          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   CRYP_AES_CBC
       104   -> CRYP_Cmd
       104   -> CRYP_DataIn
       104   -> CRYP_DataOut
       104   -> CRYP_FIFOFlush
       104   -> CRYP_GetCmdStatus
       104   -> CRYP_GetFlagStatus
       104   -> CRYP_IVInit
       104   -> CRYP_Init
       104   -> CRYP_KeyInit
       104   -> CRYP_KeyStructInit
     176   CRYP_AES_CCM
       176   -> CRYP_Cmd
       176   -> CRYP_DataIn
       176   -> CRYP_DataOut
       176   -> CRYP_FIFOFlush
       176   -> CRYP_GetCmdStatus
       176   -> CRYP_GetFlagStatus
       176   -> CRYP_IVInit
       176   -> CRYP_Init
       176   -> CRYP_KeyInit
       176   -> CRYP_KeyStructInit
       176   -> CRYP_PhaseConfig
       176   -> __aeabi_memclr4
     104   CRYP_AES_CTR
       104   -> CRYP_Cmd
       104   -> CRYP_DataIn
       104   -> CRYP_DataOut
       104   -> CRYP_FIFOFlush
       104   -> CRYP_GetCmdStatus
       104   -> CRYP_GetFlagStatus
       104   -> CRYP_IVInit
       104   -> CRYP_Init
       104   -> CRYP_KeyInit
       104   -> CRYP_KeyStructInit
      88   CRYP_AES_ECB
        88   -> CRYP_Cmd
        88   -> CRYP_DataIn
        88   -> CRYP_DataOut
        88   -> CRYP_FIFOFlush
        88   -> CRYP_GetCmdStatus
        88   -> CRYP_GetFlagStatus
        88   -> CRYP_Init
        88   -> CRYP_KeyInit
        88   -> CRYP_KeyStructInit
     144   CRYP_AES_GCM
       144   -> CRYP_Cmd
       144   -> CRYP_DataIn
       144   -> CRYP_DataOut
       144   -> CRYP_FIFOFlush
       144   -> CRYP_GetCmdStatus
       144   -> CRYP_GetFlagStatus
       144   -> CRYP_IVInit
       144   -> CRYP_Init
       144   -> CRYP_KeyInit
       144   -> CRYP_KeyStructInit
       144   -> CRYP_PhaseConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?_0
      16  ?_1
      16  ?_2
     540  CRYP_AES_CBC
    1746  CRYP_AES_CCM
     474  CRYP_AES_CTR
     546  CRYP_AES_ECB
    1302  CRYP_AES_GCM

 
    48 bytes in section .rodata
 4 608 bytes in section .text
 
 4 608 bytes of CODE  memory
    48 bytes of CONST memory

Errors: none
Warnings: none
