###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       13/Mar/2017  19:46:56
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#    Command line =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\List
#        -o
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\List\stm32f4xx_flash.lst
#    Object file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab7\EWARM\STM324xG_EVAL\Obj\stm32f4xx_flash.o
#
###############################################################################

C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            + FLASH Interface configuration
     10            *            + FLASH Memory Programming
     11            *            + Option Bytes Programming
     12            *            + Interrupts and flags management
     13            *  
     14           @verbatim    
     15           ===============================================================================
     16                                  ##### How to use this driver #####
     17           ===============================================================================
     18              [..]                             
     19                This driver provides functions to configure and program the FLASH memory 
     20                of all STM32F4xx devices. These functions are split in 4 groups:
     21             
     22                (#) FLASH Interface configuration functions: this group includes the
     23                    management of the following features:
     24                  (++) Set the latency
     25                  (++) Enable/Disable the prefetch buffer
     26                  (++) Enable/Disable the Instruction cache and the Data cache
     27                  (++) Reset the Instruction cache and the Data cache
     28              
     29                (#) FLASH Memory Programming functions: this group includes all needed
     30                    functions to erase and program the main memory:
     31                  (++) Lock and Unlock the FLASH interface
     32                  (++) Erase function: Erase sector, erase all sectors
     33                  (++) Program functions: byte, half word, word and double word
     34              
     35                (#) Option Bytes Programming functions: this group includes all needed
     36                    functions to manage the Option Bytes:
     37                  (++) Set/Reset the write protection
     38                  (++) Set the Read protection Level
     39                  (++) Set the BOR level
     40                  (++) Program the user Option Bytes
     41                  (++) Launch the Option Bytes loader
     42              
     43                (#) Interrupts and flags management functions: this group 
     44                    includes all needed functions to:
     45                  (++) Enable/Disable the FLASH interrupt sources
     46                  (++) Get flags status
     47                  (++) Clear flags
     48                  (++) Get FLASH operation status
     49                  (++) Wait for last FLASH operation   
     50           @endverbatim                      
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     55            *
     56            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     57            * You may not use this file except in compliance with the License.
     58            * You may obtain a copy of the License at:
     59            *
     60            *        http://www.st.com/software_license_agreement_liberty_v2
     61            *
     62            * Unless required by applicable law or agreed to in writing, software 
     63            * distributed under the License is distributed on an "AS IS" BASIS, 
     64            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     65            * See the License for the specific language governing permissions and
     66            * limitations under the License.
     67            *
     68            ******************************************************************************
     69            */
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32f4xx_flash.h"
     73          
     74          /** @addtogroup STM32F4xx_StdPeriph_Driver
     75            * @{
     76            */
     77          
     78          /** @defgroup FLASH 
     79            * @brief FLASH driver modules
     80            * @{
     81            */ 
     82          
     83          /* Private typedef -----------------------------------------------------------*/
     84          /* Private define ------------------------------------------------------------*/ 
     85          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     86          
     87          /* Private macro -------------------------------------------------------------*/
     88          /* Private variables ---------------------------------------------------------*/
     89          /* Private function prototypes -----------------------------------------------*/
     90          /* Private functions ---------------------------------------------------------*/
     91          
     92          /** @defgroup FLASH_Private_Functions
     93            * @{
     94            */ 
     95          
     96          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
     97            *  @brief   FLASH Interface configuration functions 
     98           *
     99          
    100          @verbatim   
    101           ===============================================================================
    102                        ##### FLASH Interface configuration functions #####
    103           ===============================================================================
    104              [..]
    105                This group includes the following functions:
    106                (+) void FLASH_SetLatency(uint32_t FLASH_Latency)
    107                    To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    108                    must be correctly programmed according to the frequency of the CPU clock 
    109                    (HCLK) and the supply voltage of the device.
    110           +-------------------------------------------------------------------------------------+     
    111           | Latency       |                HCLK clock frequency (MHz)                           |
    112           |               |---------------------------------------------------------------------|     
    113           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    114           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    115           |---------------|----------------|----------------|-----------------|-----------------|              
    116           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    117           |---------------|----------------|----------------|-----------------|-----------------|   
    118           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    119           |---------------|----------------|----------------|-----------------|-----------------|   
    120           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    121           |---------------|----------------|----------------|-----------------|-----------------| 
    122           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    123           |---------------|----------------|----------------|-----------------|-----------------| 
    124           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    125           |---------------|----------------|----------------|-----------------|-----------------| 
    126           |5WS(6CPU cycle)|120< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    127           |---------------|----------------|----------------|-----------------|-----------------| 
    128           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    129           |---------------|----------------|----------------|-----------------|-----------------| 
    130           |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
    131           |---------------|----------------|----------------|-----------------|-----------------| 
    132           |8WS(9CPU cycle)|      NA        |      NA        |        NA       |160 < HCLK <= 168|
    133           +-------------------------------------------------------------------------------------+ 
    134           
    135           [..]
    136           +-------------------------------------------------------------------------------------------------------------------+
    137           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    138           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    139           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    140           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    141           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    142           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    143           +-------------------------------------------------------------------------------------------------------------------+  
    144                -@- When VOS bit (in PWR_CR register) is reset to 0 , the maximum value of HCLK is 144 MHz.
    145                    You can use PWR_MainRegulatorModeConfig() function to set or reset this bit.
    146                -@- On STM32F40xx/41xx devices: 
    147                     (++) when VOS = '0', the maximum value of fHCLK = 144MHz. 
    148                     (++) when VOS = '1', the maximum value of fHCLK = 168MHz. 
    149                    [..] 
    150                    On STM32F427x/437x and STM32F429x/439x devices:
    151                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 120MHz.
    152                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 144MHz.
    153                     (++) when VOS[1:0] = '0x11', the maximum value of f  is 168MHz  
    154                     You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
    155                           
    156                (+) void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    157                (+) void FLASH_InstructionCacheCmd(FunctionalState NewState)
    158                (+) void FLASH_DataCacheCmd(FunctionalState NewState)
    159                (+) void FLASH_InstructionCacheReset(void)
    160                (+) void FLASH_DataCacheReset(void)
    161                
    162              [..]   
    163                The unlock sequence is not needed for these functions.
    164           
    165          @endverbatim
    166            * @{
    167            */
    168           
    169          /**
    170            * @brief  Sets the code latency value.  
    171            * @param  FLASH_Latency: specifies the FLASH Latency value.
    172            *          This parameter can be one of the following values:
    173            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    174            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    175            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    176            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    177            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    178            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    179            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    180            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles 
    181            *            @arg FLASH_Latency_8: FLASH Eight Latency cycles
    182            *            @arg FLASH_Latency_9: FLASH Nine Latency cycles
    183            *            @arg FLASH_Latency_10: FLASH Teen Latency cycles 
    184            *            @arg FLASH_Latency_11: FLASH Eleven Latency cycles 
    185            *            @arg FLASH_Latency_12: FLASH Twelve Latency cycles
    186            *            @arg FLASH_Latency_13: FLASH Thirteen Latency cycles        
    187            *            @arg FLASH_Latency_14: FLASH Fourteen Latency cycles
    188            *            @arg FLASH_Latency_15: FLASH Fifteen Latency cycles 
    189            *          For STM32F40xx/41xx and STM32F427x/437x devices this parameter can be   
    190            *          a value between FLASH_Latency_0 and FLASH_Latency_7.
    191            *          For STM32F429x/439x devices this parameter can be a value between 
    192            *          FLASH_Latency_0 and FLASH_Latency_15.    
    193            * @retval None
    194            */

   \                                 In section .text, align 2, keep-with-next
    195          void FLASH_SetLatency(uint32_t FLASH_Latency)
    196          {
    197            /* Check the parameters */
    198            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    199            
    200            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    201            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
   \                     FLASH_SetLatency: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    202          }
   \   00000006   0x4770             BX       LR               ;; return
    203          
    204          /**
    205            * @brief  Enables or disables the Prefetch Buffer.
    206            * @param  NewState: new state of the Prefetch Buffer.
    207            *          This parameter  can be: ENABLE or DISABLE.
    208            * @retval None
    209            */

   \                                 In section .text, align 2, keep-with-next
    210          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    211          {
    212            /* Check the parameters */
    213            assert_param(IS_FUNCTIONAL_STATE(NewState));
    214            
    215            /* Enable or disable the Prefetch Buffer */
    216            if(NewState != DISABLE)
   \                     FLASH_PrefetchBufferCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ.N    ??FLASH_PrefetchBufferCmd_0
    217            {
    218              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xE007             B.N      ??FLASH_PrefetchBufferCmd_1
    219            }
    220            else
    221            {
    222              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
   \                     ??FLASH_PrefetchBufferCmd_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000026   0x6008             STR      R0,[R1, #+0]
    223            }
    224          }
   \                     ??FLASH_PrefetchBufferCmd_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    225          
    226          /**
    227            * @brief  Enables or disables the Instruction Cache feature.
    228            * @param  NewState: new state of the Instruction Cache.
    229            *          This parameter  can be: ENABLE or DISABLE.
    230            * @retval None
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    233          {
    234            /* Check the parameters */
    235            assert_param(IS_FUNCTIONAL_STATE(NewState));
    236            
    237            if(NewState != DISABLE)
   \                     FLASH_InstructionCacheCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ.N    ??FLASH_InstructionCacheCmd_0
    238            {
    239              FLASH->ACR |= FLASH_ACR_ICEN;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xE007             B.N      ??FLASH_InstructionCacheCmd_1
    240            }
    241            else
    242            {
    243              FLASH->ACR &= (~FLASH_ACR_ICEN);
   \                     ??FLASH_InstructionCacheCmd_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000026   0x6008             STR      R0,[R1, #+0]
    244            }
    245          }
   \                     ??FLASH_InstructionCacheCmd_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    246          
    247          /**
    248            * @brief  Enables or disables the Data Cache feature.
    249            * @param  NewState: new state of the Data Cache.
    250            *          This parameter  can be: ENABLE or DISABLE.
    251            * @retval None
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          void FLASH_DataCacheCmd(FunctionalState NewState)
    254          {
    255            /* Check the parameters */
    256            assert_param(IS_FUNCTIONAL_STATE(NewState));
    257            
    258            if(NewState != DISABLE)
   \                     FLASH_DataCacheCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ.N    ??FLASH_DataCacheCmd_0
    259            {
    260              FLASH->ACR |= FLASH_ACR_DCEN;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xE007             B.N      ??FLASH_DataCacheCmd_1
    261            }
    262            else
    263            {
    264              FLASH->ACR &= (~FLASH_ACR_DCEN);
   \                     ??FLASH_DataCacheCmd_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   00000026   0x6008             STR      R0,[R1, #+0]
    265            }
    266          }
   \                     ??FLASH_DataCacheCmd_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    267          
    268          /**
    269            * @brief  Resets the Instruction Cache.
    270            * @note   This function must be used only when the Instruction Cache is disabled.  
    271            * @param  None
    272            * @retval None
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          void FLASH_InstructionCacheReset(void)
    275          {
    276            FLASH->ACR |= FLASH_ACR_ICRST;
   \                     FLASH_InstructionCacheReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    277          }
   \   00000010   0x4770             BX       LR               ;; return
    278          
    279          /**
    280            * @brief  Resets the Data Cache.
    281            * @note   This function must be used only when the Data Cache is disabled.  
    282            * @param  None
    283            * @retval None
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          void FLASH_DataCacheReset(void)
    286          {
    287            FLASH->ACR |= FLASH_ACR_DCRST;
   \                     FLASH_DataCacheReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40023c00
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x40023c00
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    288          }
   \   00000010   0x4770             BX       LR               ;; return
    289          
    290          /**
    291            * @}
    292            */
    293          
    294          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    295           *  @brief   FLASH Memory Programming functions
    296           *
    297          @verbatim   
    298           ===============================================================================
    299                          ##### FLASH Memory Programming functions #####
    300           ===============================================================================   
    301              [..]
    302                This group includes the following functions:
    303                (+) void FLASH_Unlock(void)
    304                (+) void FLASH_Lock(void)
    305                (+) FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    306                (+) FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)       
    307                (+) FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    308                (+) FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    309                (+) FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    310                (+) FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    311                    The following functions can be used only for STM32F429X device. 
    312                (+) FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
    313                (+) FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)    
    314              [..]   
    315                Any operation of erase or program should follow these steps:
    316                (#) Call the FLASH_Unlock() function to enable the FLASH control register access
    317          
    318                (#) Call the desired function to erase sector(s) or program data
    319          
    320                (#) Call the FLASH_Lock() function to disable the FLASH control register access
    321                    (recommended to protect the FLASH memory against possible unwanted operation)
    322              
    323          @endverbatim
    324            * @{
    325            */
    326          
    327          /**
    328            * @brief  Unlocks the FLASH control register access
    329            * @param  None
    330            * @retval None
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          void FLASH_Unlock(void)
    333          {
    334            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     FLASH_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD509             BPL.N    ??FLASH_Unlock_0
    335            {
    336              /* Authorize the FLASH Registers access */
    337              FLASH->KEYR = FLASH_KEY1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable30_2  ;; 0x45670123
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable30_3  ;; 0x40023c04
   \   00000012   0x6008             STR      R0,[R1, #+0]
    338              FLASH->KEYR = FLASH_KEY2;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable30_4  ;; 0xcdef89ab
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable30_3  ;; 0x40023c04
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    339            }  
    340          }
   \                     ??FLASH_Unlock_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    341          
    342          /**
    343            * @brief  Locks the FLASH control register access
    344            * @param  None
    345            * @retval None
    346            */

   \                                 In section .text, align 2, keep-with-next
    347          void FLASH_Lock(void)
    348          {
    349            /* Set the LOCK Bit to lock the FLASH Registers access */
    350            FLASH->CR |= FLASH_CR_LOCK;
   \                     FLASH_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    351          }
   \   00000010   0x4770             BX       LR               ;; return
    352          
    353          /**
    354            * @brief  Erases a specified FLASH Sector.
    355            *
    356            * @note   If an erase and a program operations are requested simustaneously,    
    357            *         the erase operation is performed before the program one.
    358            *   
    359            * @param  FLASH_Sector: The Sector number to be erased.
    360            *          For STM32F40XX device this parameter can be a value between FLASH_Sector_0 
    361            *          and FLASH_Sector_11.
    362            *          For STM32F427X and STM32F429X devices this parameter can be a value between 
    363            *          FLASH_Sector_0 and FLASH_Sector_23.          
    364            *    
    365            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    366            *          This parameter can be one of the following values:
    367            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    368            *                                  the operation will be done by byte (8-bit) 
    369            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    370            *                                  the operation will be done by half word (16-bit)
    371            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    372            *                                  the operation will be done by word (32-bit)
    373            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    374            *                                  the operation will be done by double word (64-bit)
    375            *       
    376            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    377            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    380          {
   \                     FLASH_EraseSector: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    381            uint32_t tmp_psize = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    382            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    383          
    384            /* Check the parameters */
    385            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
    386            assert_param(IS_VOLTAGERANGE(VoltageRange));
    387            
    388            if(VoltageRange == VoltageRange_1)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??FLASH_EraseSector_0
    389            {
    390               tmp_psize = FLASH_PSIZE_BYTE;
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE00D             B.N      ??FLASH_EraseSector_1
    391            }
    392            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseSector_0: (+1)
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD102             BNE.N    ??FLASH_EraseSector_2
    393            {
    394              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000018   0xF44F 0x7580      MOV      R5,#+256
   \   0000001C   0xE007             B.N      ??FLASH_EraseSector_1
    395            }
    396            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseSector_2: (+1)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x2902             CMP      R1,#+2
   \   00000022   0xD102             BNE.N    ??FLASH_EraseSector_3
    397            {
    398              tmp_psize = FLASH_PSIZE_WORD;
   \   00000024   0xF44F 0x7500      MOV      R5,#+512
   \   00000028   0xE001             B.N      ??FLASH_EraseSector_1
    399            }
    400            else
    401            {
    402              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseSector_3: (+1)
   \   0000002A   0xF44F 0x7540      MOV      R5,#+768
    403            }
    404            /* Wait for last operation to be completed */
    405            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_EraseSector_1: (+1)
   \   0000002E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    406            
    407            if(status == FLASH_COMPLETE)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD139             BNE.N    ??FLASH_EraseSector_4
    408            { 
    409              /* if the previous operation is completed, proceed to erase the sector */
    410              FLASH->CR &= CR_PSIZE_MASK;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000046   0x6008             STR      R0,[R1, #+0]
    411              FLASH->CR |= tmp_psize;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x4328             ORRS     R0,R5,R0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000054   0x6008             STR      R0,[R1, #+0]
    412              FLASH->CR &= SECTOR_MASK;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000064   0x6008             STR      R0,[R1, #+0]
    413              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF054 0x0102      ORRS     R1,R4,#0x2
   \   00000070   0x4308             ORRS     R0,R1,R0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000076   0x6008             STR      R0,[R1, #+0]
    414              FLASH->CR |= FLASH_CR_STRT;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000086   0x6008             STR      R0,[R1, #+0]
    415              
    416              /* Wait for last operation to be completed */
    417              status = FLASH_WaitForLastOperation();
   \   00000088   0x.... 0x....      BL       FLASH_WaitForLastOperation
    418              
    419              /* if the erase operation is completed, disable the SER Bit */
    420              FLASH->CR &= (~FLASH_CR_SER);
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0xF031 0x0102      BICS     R1,R1,#0x2
   \   00000096   0x.... 0x....      LDR.W    R2,??DataTable30_1  ;; 0x40023c10
   \   0000009A   0x6011             STR      R1,[R2, #+0]
    421              FLASH->CR &= SECTOR_MASK; 
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0xF031 0x01F8      BICS     R1,R1,#0xF8
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable30_1  ;; 0x40023c10
   \   000000AA   0x6011             STR      R1,[R2, #+0]
    422            }
    423            /* Return the Erase Status */
    424            return status;
   \                     ??FLASH_EraseSector_4: (+1)
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    425          }
    426          
    427          /**
    428            * @brief  Erases all FLASH Sectors.
    429            *
    430            * @note   If an erase and a program operations are requested simustaneously,    
    431            *         the erase operation is performed before the program one.
    432            *  
    433            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    434            *          This parameter can be one of the following values:
    435            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    436            *                                  the operation will be done by byte (8-bit) 
    437            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    438            *                                  the operation will be done by half word (16-bit)
    439            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    440            *                                  the operation will be done by word (32-bit)
    441            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    442            *                                  the operation will be done by double word (64-bit)
    443            *       
    444            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    445            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    446            */

   \                                 In section .text, align 2, keep-with-next
    447          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    448          {
   \                     FLASH_EraseAllSectors: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    449            uint32_t tmp_psize = 0x0;
   \   00000004   0x2100             MOVS     R1,#+0
    450            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    451            
    452            /* Wait for last operation to be completed */
    453            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    454            assert_param(IS_VOLTAGERANGE(VoltageRange));
    455            
    456            if(VoltageRange == VoltageRange_1)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE.N    ??FLASH_EraseAllSectors_0
    457            {
    458               tmp_psize = FLASH_PSIZE_BYTE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xE00D             B.N      ??FLASH_EraseAllSectors_1
    459            }
    460            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseAllSectors_0: (+1)
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD102             BNE.N    ??FLASH_EraseAllSectors_2
    461            {
    462              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   0000001C   0xF44F 0x7180      MOV      R1,#+256
   \   00000020   0xE007             B.N      ??FLASH_EraseAllSectors_1
    463            }
    464            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllSectors_2: (+1)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C02             CMP      R4,#+2
   \   00000026   0xD102             BNE.N    ??FLASH_EraseAllSectors_3
    465            {
    466              tmp_psize = FLASH_PSIZE_WORD;
   \   00000028   0xF44F 0x7100      MOV      R1,#+512
   \   0000002C   0xE001             B.N      ??FLASH_EraseAllSectors_1
    467            }
    468            else
    469            {
    470              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllSectors_3: (+1)
   \   0000002E   0xF44F 0x7140      MOV      R1,#+768
    471            }  
    472            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllSectors_1: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD124             BNE.N    ??FLASH_EraseAllSectors_4
    473            {
    474              /* if the previous operation is completed, proceed to erase all sectors */
    475          #if defined (STM32F427X) || defined (STM32F429X)    
    476              FLASH->CR &= CR_PSIZE_MASK;
    477              FLASH->CR |= tmp_psize;
    478              FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
    479              FLASH->CR |= FLASH_CR_STRT;
    480              
    481              /* Wait for last operation to be completed */
    482              status = FLASH_WaitForLastOperation();
    483          
    484              /* if the erase operation is completed, disable the MER Bit */
    485              FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
    486          #endif /* STM32F427X || STM32F429X */
    487          
    488          #ifdef STM32F40XX
    489              FLASH->CR &= CR_PSIZE_MASK;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable30_1  ;; 0x40023c10
   \   00000046   0x6010             STR      R0,[R2, #+0]
    490              FLASH->CR |= tmp_psize;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000054   0x6008             STR      R0,[R1, #+0]
    491              FLASH->CR |= FLASH_CR_MER;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x40023c10
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable30_1  ;; 0x40023c10
   \   00000064   0x6008             STR      R0,[R1, #+0]
    492              FLASH->CR |= FLASH_CR_STRT;
   \   00000066   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000006E   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000070   0x6008             STR      R0,[R1, #+0]
    493              
    494              /* Wait for last operation to be completed */
    495              status = FLASH_WaitForLastOperation();
   \   00000072   0x.... 0x....      BL       FLASH_WaitForLastOperation
    496          
    497              /* if the erase operation is completed, disable the MER Bit */
    498              FLASH->CR &= (~FLASH_CR_MER);
   \   00000076   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000078   0x6809             LDR      R1,[R1, #+0]
   \   0000007A   0xF031 0x0104      BICS     R1,R1,#0x4
   \   0000007E   0x....             LDR.N    R2,??DataTable30_1  ;; 0x40023c10
   \   00000080   0x6011             STR      R1,[R2, #+0]
    499          #endif /* STM32F40XX */
    500          
    501            }   
    502            /* Return the Erase Status */
    503            return status;
   \                     ??FLASH_EraseAllSectors_4: (+1)
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
    504          }
    505          
    506          #if defined (STM32F429X)
    507          /**
    508            * @brief  Erases all FLASH Sectors in Bank 1.
    509            *
    510            * @note   If an erase and a program operations are requested simultaneously,    
    511            *         the erase operation is performed before the program one.
    512            * @note   This function can be used only for STM32F429x/439x devices.  
    513            *  
    514            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    515            *          This parameter can be one of the following values:
    516            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    517            *                                  the operation will be done by byte (8-bit) 
    518            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    519            *                                  the operation will be done by half word (16-bit)
    520            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    521            *                                  the operation will be done by word (32-bit)
    522            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    523            *                                  the operation will be done by double word (64-bit)
    524            *       
    525            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    526            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    527            */
    528          FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
    529          {
    530            uint32_t tmp_psize = 0x0;
    531            FLASH_Status status = FLASH_COMPLETE;
    532            
    533            /* Wait for last operation to be completed */
    534            status = FLASH_WaitForLastOperation();
    535            assert_param(IS_VOLTAGERANGE(VoltageRange));
    536            
    537            if(VoltageRange == VoltageRange_1)
    538            {
    539               tmp_psize = FLASH_PSIZE_BYTE;
    540            }
    541            else if(VoltageRange == VoltageRange_2)
    542            {
    543              tmp_psize = FLASH_PSIZE_HALF_WORD;
    544            }
    545            else if(VoltageRange == VoltageRange_3)
    546            {
    547              tmp_psize = FLASH_PSIZE_WORD;
    548            }
    549            else
    550            {
    551              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
    552            }  
    553            if(status == FLASH_COMPLETE)
    554            {
    555              /* if the previous operation is completed, proceed to erase all sectors */
    556               FLASH->CR &= CR_PSIZE_MASK;
    557               FLASH->CR |= tmp_psize;
    558               FLASH->CR |= FLASH_CR_MER1;
    559               FLASH->CR |= FLASH_CR_STRT;
    560              
    561              /* Wait for last operation to be completed */
    562              status = FLASH_WaitForLastOperation();
    563          
    564              /* if the erase operation is completed, disable the MER Bit */
    565              FLASH->CR &= (~FLASH_CR_MER1);
    566          
    567            }   
    568            /* Return the Erase Status */
    569            return status;
    570          }
    571          
    572          
    573          /**
    574            * @brief  Erases all FLASH Sectors in Bank 2.
    575            *
    576            * @note   If an erase and a program operations are requested simultaneously,    
    577            *         the erase operation is performed before the program one.
    578            * @note   This function can be used only for STM32F429x/439x devices. 
    579            *     
    580            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    581            *          This parameter can be one of the following values:
    582            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    583            *                                  the operation will be done by byte (8-bit) 
    584            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    585            *                                  the operation will be done by half word (16-bit)
    586            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    587            *                                  the operation will be done by word (32-bit)
    588            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    589            *                                  the operation will be done by double word (64-bit)
    590            *       
    591            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    592            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    593            */
    594          FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
    595          {
    596            uint32_t tmp_psize = 0x0;
    597            FLASH_Status status = FLASH_COMPLETE;
    598            
    599            /* Wait for last operation to be completed */
    600            status = FLASH_WaitForLastOperation();
    601            assert_param(IS_VOLTAGERANGE(VoltageRange));
    602            
    603            if(VoltageRange == VoltageRange_1)
    604            {
    605               tmp_psize = FLASH_PSIZE_BYTE;
    606            }
    607            else if(VoltageRange == VoltageRange_2)
    608            {
    609              tmp_psize = FLASH_PSIZE_HALF_WORD;
    610            }
    611            else if(VoltageRange == VoltageRange_3)
    612            {
    613              tmp_psize = FLASH_PSIZE_WORD;
    614            }
    615            else
    616            {
    617              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
    618            }  
    619            if(status == FLASH_COMPLETE)
    620            {
    621              /* if the previous operation is completed, proceed to erase all sectors */
    622               FLASH->CR &= CR_PSIZE_MASK;
    623               FLASH->CR |= tmp_psize;
    624               FLASH->CR |= FLASH_CR_MER2;
    625               FLASH->CR |= FLASH_CR_STRT;
    626              
    627              /* Wait for last operation to be completed */
    628              status = FLASH_WaitForLastOperation();
    629          
    630              /* if the erase operation is completed, disable the MER Bit */
    631              FLASH->CR &= (~FLASH_CR_MER2);
    632          
    633            }   
    634            /* Return the Erase Status */
    635            return status;
    636          }
    637          #endif /* STM32F429X */
    638          
    639          /**
    640            * @brief  Programs a double word (64-bit) at a specified address.
    641            * @note   This function must be used when the device voltage range is from
    642            *         2.7V to 3.6V and an External Vpp is present.
    643            *
    644            * @note   If an erase and a program operations are requested simustaneously,    
    645            *         the erase operation is performed before the program one.
    646            *  
    647            * @param  Address: specifies the address to be programmed.
    648            * @param  Data: specifies the data to be programmed.
    649            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    650            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    651            */

   \                                 In section .text, align 2, keep-with-next
    652          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    653          {
   \                     FLASH_ProgramDoubleWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x001D             MOVS     R5,R3
    654            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2009             MOVS     R0,#+9
    655          
    656            /* Check the parameters */
    657            assert_param(IS_FLASH_ADDRESS(Address));
    658          
    659            /* Wait for last operation to be completed */
    660            status = FLASH_WaitForLastOperation();
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
    661            
    662            if(status == FLASH_COMPLETE)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2809             CMP      R0,#+9
   \   00000012   0xD11B             BNE.N    ??FLASH_ProgramDoubleWord_0
    663            {
    664              /* if the previous operation is completed, proceed to program the new data */
    665              FLASH->CR &= CR_PSIZE_MASK;
   \   00000014   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000001C   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    666              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   00000020   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF450 0x7040      ORRS     R0,R0,#0x300
   \   00000028   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    667              FLASH->CR |= FLASH_CR_PG;
   \   0000002C   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000034   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000036   0x6008             STR      R0,[R1, #+0]
    668            
    669              *(__IO uint64_t*)Address = Data;
   \   00000038   0xE9C6 0x4500      STRD     R4,R5,[R6, #+0]
    670                  
    671              /* Wait for last operation to be completed */
    672              status = FLASH_WaitForLastOperation();
   \   0000003C   0x.... 0x....      BL       FLASH_WaitForLastOperation
    673          
    674              /* if the program operation is completed, disable the PG Bit */
    675              FLASH->CR &= (~FLASH_CR_PG);
   \   00000040   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x0849             LSRS     R1,R1,#+1
   \   00000046   0x0049             LSLS     R1,R1,#+1
   \   00000048   0x....             LDR.N    R2,??DataTable30_1  ;; 0x40023c10
   \   0000004A   0x6011             STR      R1,[R2, #+0]
    676            } 
    677            /* Return the Program Status */
    678            return status;
   \                     ??FLASH_ProgramDoubleWord_0: (+1)
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    679          }
    680          
    681          /**
    682            * @brief  Programs a word (32-bit) at a specified address.
    683            *
    684            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    685            *
    686            * @note   If an erase and a program operations are requested simustaneously,    
    687            *         the erase operation is performed before the program one.
    688            *  
    689            * @param  Address: specifies the address to be programmed.
    690            *         This parameter can be any address in Program memory zone or in OTP zone.  
    691            * @param  Data: specifies the data to be programmed.
    692            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    693            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    694            */

   \                                 In section .text, align 2, keep-with-next
    695          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    696          {
   \                     FLASH_ProgramWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    697            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    698          
    699            /* Check the parameters */
    700            assert_param(IS_FLASH_ADDRESS(Address));
    701          
    702            /* Wait for last operation to be completed */
    703            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    704            
    705            if(status == FLASH_COMPLETE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xD11A             BNE.N    ??FLASH_ProgramWord_0
    706            {
    707              /* if the previous operation is completed, proceed to program the new data */
    708              FLASH->CR &= CR_PSIZE_MASK;
   \   00000012   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000001A   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    709              FLASH->CR |= FLASH_PSIZE_WORD;
   \   0000001E   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000026   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000028   0x6008             STR      R0,[R1, #+0]
    710              FLASH->CR |= FLASH_CR_PG;
   \   0000002A   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000034   0x6008             STR      R0,[R1, #+0]
    711            
    712              *(__IO uint32_t*)Address = Data;
   \   00000036   0x6025             STR      R5,[R4, #+0]
    713                  
    714              /* Wait for last operation to be completed */
    715              status = FLASH_WaitForLastOperation();
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
    716          
    717              /* if the program operation is completed, disable the PG Bit */
    718              FLASH->CR &= (~FLASH_CR_PG);
   \   0000003C   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x0849             LSRS     R1,R1,#+1
   \   00000042   0x0049             LSLS     R1,R1,#+1
   \   00000044   0x....             LDR.N    R2,??DataTable30_1  ;; 0x40023c10
   \   00000046   0x6011             STR      R1,[R2, #+0]
    719            } 
    720            /* Return the Program Status */
    721            return status;
   \                     ??FLASH_ProgramWord_0: (+1)
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    722          }
    723          
    724          /**
    725            * @brief  Programs a half word (16-bit) at a specified address. 
    726            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V. 
    727            *
    728            * @note   If an erase and a program operations are requested simustaneously,    
    729            *         the erase operation is performed before the program one.
    730            * 
    731            * @param  Address: specifies the address to be programmed.
    732            *         This parameter can be any address in Program memory zone or in OTP zone.  
    733            * @param  Data: specifies the data to be programmed.
    734            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    735            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    736            */

   \                                 In section .text, align 2, keep-with-next
    737          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    738          {
   \                     FLASH_ProgramHalfWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    739            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    740          
    741            /* Check the parameters */
    742            assert_param(IS_FLASH_ADDRESS(Address));
    743          
    744            /* Wait for last operation to be completed */
    745            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    746            
    747            if(status == FLASH_COMPLETE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xD11A             BNE.N    ??FLASH_ProgramHalfWord_0
    748            {
    749              /* if the previous operation is completed, proceed to program the new data */
    750              FLASH->CR &= CR_PSIZE_MASK;
   \   00000012   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000001A   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    751              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   0000001E   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000026   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000028   0x6008             STR      R0,[R1, #+0]
    752              FLASH->CR |= FLASH_CR_PG;
   \   0000002A   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000034   0x6008             STR      R0,[R1, #+0]
    753            
    754              *(__IO uint16_t*)Address = Data;
   \   00000036   0x8025             STRH     R5,[R4, #+0]
    755                  
    756              /* Wait for last operation to be completed */
    757              status = FLASH_WaitForLastOperation();
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
    758          
    759              /* if the program operation is completed, disable the PG Bit */
    760              FLASH->CR &= (~FLASH_CR_PG);
   \   0000003C   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x0849             LSRS     R1,R1,#+1
   \   00000042   0x0049             LSLS     R1,R1,#+1
   \   00000044   0x....             LDR.N    R2,??DataTable30_1  ;; 0x40023c10
   \   00000046   0x6011             STR      R1,[R2, #+0]
    761            } 
    762            /* Return the Program Status */
    763            return status;
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    764          }
    765          
    766          /**
    767            * @brief  Programs a byte (8-bit) at a specified address.
    768            * @note   This function can be used within all the device supply voltage ranges.  
    769            *
    770            * @note   If an erase and a program operations are requested simustaneously,    
    771            *         the erase operation is performed before the program one.
    772            * 
    773            * @param  Address: specifies the address to be programmed.
    774            *         This parameter can be any address in Program memory zone or in OTP zone.  
    775            * @param  Data: specifies the data to be programmed.
    776            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    777            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    780          {
   \                     FLASH_ProgramByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    781            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    782          
    783            /* Check the parameters */
    784            assert_param(IS_FLASH_ADDRESS(Address));
    785          
    786            /* Wait for last operation to be completed */
    787            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    788            
    789            if(status == FLASH_COMPLETE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xD118             BNE.N    ??FLASH_ProgramByte_0
    790            {
    791              /* if the previous operation is completed, proceed to program the new data */
    792              FLASH->CR &= CR_PSIZE_MASK;
   \   00000012   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000001A   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    793              FLASH->CR |= FLASH_PSIZE_BYTE;
   \   0000001E   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000024   0x6008             STR      R0,[R1, #+0]
    794              FLASH->CR |= FLASH_CR_PG;
   \   00000026   0x....             LDR.N    R0,??DataTable30_1  ;; 0x40023c10
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002E   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000030   0x6008             STR      R0,[R1, #+0]
    795            
    796              *(__IO uint8_t*)Address = Data;
   \   00000032   0x7025             STRB     R5,[R4, #+0]
    797                  
    798              /* Wait for last operation to be completed */
    799              status = FLASH_WaitForLastOperation();
   \   00000034   0x.... 0x....      BL       FLASH_WaitForLastOperation
    800          
    801              /* if the program operation is completed, disable the PG Bit */
    802              FLASH->CR &= (~FLASH_CR_PG);
   \   00000038   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0x0849             LSRS     R1,R1,#+1
   \   0000003E   0x0049             LSLS     R1,R1,#+1
   \   00000040   0x....             LDR.N    R2,??DataTable30_1  ;; 0x40023c10
   \   00000042   0x6011             STR      R1,[R2, #+0]
    803            } 
    804          
    805            /* Return the Program Status */
    806            return status;
   \                     ??FLASH_ProgramByte_0: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    807          }
    808          
    809          /**
    810            * @}
    811            */
    812          
    813          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    814           *  @brief   Option Bytes Programming functions 
    815           *
    816          @verbatim   
    817           ===============================================================================
    818                          ##### Option Bytes Programming functions #####
    819           ===============================================================================  
    820              [..]
    821                This group includes the following functions:
    822                (+) void FLASH_OB_Unlock(void)
    823                (+) void FLASH_OB_Lock(void)
    824                (+) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    825                (+) void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)  
    826                (+) void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PCROPSelect)
    827                (+) void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
    828                (+) void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState) 
    829                (+) void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    830                (+) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    831                (+) void FLASH_OB_BORConfig(uint8_t OB_BOR)
    832                (+) FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)							
    833                (+) FLASH_Status FLASH_OB_Launch(void)
    834                (+) uint32_t FLASH_OB_GetUser(void)						
    835                (+) uint8_t FLASH_OB_GetWRP(void)
    836                (+) uint8_t FLASH_OB_GetWRP1(void)
    837                (+) uint8_t FLASH_OB_GetPCROP(void)
    838                (+) uint8_t FLASH_OB_GetPCROP1(void)    						
    839                (+) uint8_t FLASH_OB_GetRDP(void)							
    840                (+) uint8_t FLASH_OB_GetBOR(void)
    841              [..]  
    842                The following function can be used only for STM32F429X device. 
    843                (+) void FLASH_OB_BootConfig(uint8_t OB_BOOT)
    844              [..]   
    845               Any operation of erase or program should follow these steps:
    846                (#) Call the FLASH_OB_Unlock() function to enable the FLASH option control 
    847                    register access
    848          
    849                (#) Call one or several functions to program the desired Option Bytes:
    850                  (++) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) 
    851                       => to Enable/Disable the desired sector write protection
    852                  (++) void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read 
    853                       Protection Level
    854                  (++) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) 
    855                       => to configure the user Option Bytes.
    856                  (++) void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    857          
    858                (#) Once all needed Option Bytes to be programmed are correctly written, 
    859                    call the FLASH_OB_Launch() function to launch the Option Bytes 
    860                    programming process.
    861               
    862                -@- When changing the IWDG mode from HW to SW or from SW to HW, a system 
    863                    reset is needed to make the change effective.  
    864          
    865                (#) Call the FLASH_OB_Lock() function to disable the FLASH option control 
    866                    register access (recommended to protect the Option Bytes against 
    867                    possible unwanted operations)
    868              
    869          @endverbatim
    870            * @{
    871            */
    872          
    873          /**
    874            * @brief  Unlocks the FLASH Option Control Registers access.
    875            * @param  None
    876            * @retval None
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          void FLASH_OB_Unlock(void)
    879          {
    880            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_5  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x07C0             LSLS     R0,R0,#+31
   \   00000006   0xD505             BPL.N    ??FLASH_OB_Unlock_0
    881            {
    882              /* Authorizes the Option Byte register programming */
    883              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R0,??DataTable30_6  ;; 0x8192a3b
   \   0000000A   0x....             LDR.N    R1,??DataTable30_7  ;; 0x40023c08
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    884              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000E   0x....             LDR.N    R0,??DataTable30_8  ;; 0x4c5d6e7f
   \   00000010   0x....             LDR.N    R1,??DataTable30_7  ;; 0x40023c08
   \   00000012   0x6008             STR      R0,[R1, #+0]
    885            }  
    886          }
   \                     ??FLASH_OB_Unlock_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    887          
    888          /**
    889            * @brief  Locks the FLASH Option Control Registers access.
    890            * @param  None
    891            * @retval None
    892            */

   \                                 In section .text, align 2, keep-with-next
    893          void FLASH_OB_Lock(void)
    894          {
    895            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    896            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_5  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000008   0x....             LDR.N    R1,??DataTable30_5  ;; 0x40023c14
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    897          }
   \   0000000C   0x4770             BX       LR               ;; return
    898          
    899          /**
    900            * @brief  Enables or disables the write protection of the desired sectors, for the first
    901            *         1 Mb of the Flash  
    902            *
    903            * @note   When the memory read protection level is selected (RDP level = 1), 
    904            *         it is not possible to program or erase the flash sector i if CortexM4  
    905            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    906            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
    907            * 
    908            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    909            *          This parameter can be one of the following values:
    910            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    911            *            @arg OB_WRP_Sector_All
    912            * @param  Newstate: new state of the Write Protection.
    913            *          This parameter can be: ENABLE or DISABLE.
    914            * @retval None  
    915            */

   \                                 In section .text, align 2, keep-with-next
    916          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    917          { 
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    918            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    919            
    920            /* Check the parameters */
    921            assert_param(IS_OB_WRP(OB_WRP));
    922            assert_param(IS_FUNCTIONAL_STATE(NewState));
    923              
    924            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    925          
    926            if(status == FLASH_COMPLETE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xD10D             BNE.N    ??FLASH_OB_WRPConfig_0
    927            { 
    928              if(NewState != DISABLE)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD005             BEQ.N    ??FLASH_OB_WRPConfig_1
    929              {
    930                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
   \   00000018   0x....             LDR.N    R0,??DataTable30_9  ;; 0x40023c16
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x43A0             BICS     R0,R0,R4
   \   0000001E   0x....             LDR.N    R1,??DataTable30_9  ;; 0x40023c16
   \   00000020   0x8008             STRH     R0,[R1, #+0]
   \   00000022   0xE004             B.N      ??FLASH_OB_WRPConfig_0
    931              }
    932              else
    933              {
    934                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable30_9  ;; 0x40023c16
   \   00000026   0x8800             LDRH     R0,[R0, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable30_9  ;; 0x40023c16
   \   0000002C   0x8008             STRH     R0,[R1, #+0]
    935              }
    936            }
    937          }
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    938          
    939          /**
    940            * @brief  Enables or disables the write protection of the desired sectors, for the second
    941            *         1 Mb of the Flash  
    942            *           
    943            * @note   This function can be used only for STM32F427x/437x and STM32F429x/439x devices.
    944            * @note   When the memory read out protection is selected (RDP level = 1), 
    945            *         it is not possible to program or erase the flash sector i if CortexM4  
    946            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    947            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).      
    948            * 
    949            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    950            *          This parameter can be one of the following values:
    951            *            @arg OB_WRP: A value between OB_WRP_Sector12 and OB_WRP_Sector23
    952            *            @arg OB_WRP_Sector_All                        
    953            * @param  Newstate: new state of the Write Protection.
    954            *          This parameter can be: ENABLE or DISABLE.
    955            * @retval None  
    956            */

   \                                 In section .text, align 2, keep-with-next
    957          void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
    958          { 
   \                     FLASH_OB_WRP1Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    959            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2009             MOVS     R0,#+9
    960            
    961            /* Check the parameters */
    962            assert_param(IS_OB_WRP(OB_WRP));
    963            assert_param(IS_FUNCTIONAL_STATE(NewState));
    964              
    965            status = FLASH_WaitForLastOperation();
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
    966          
    967            if(status == FLASH_COMPLETE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2809             CMP      R0,#+9
   \   00000010   0xD10D             BNE.N    ??FLASH_OB_WRP1Config_0
    968            { 
    969              if(NewState != DISABLE)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD005             BEQ.N    ??FLASH_OB_WRP1Config_1
    970              {
    971                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
   \   00000018   0x....             LDR.N    R0,??DataTable30_10  ;; 0x40023c1a
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x43A0             BICS     R0,R0,R4
   \   0000001E   0x....             LDR.N    R1,??DataTable30_10  ;; 0x40023c1a
   \   00000020   0x8008             STRH     R0,[R1, #+0]
   \   00000022   0xE004             B.N      ??FLASH_OB_WRP1Config_0
    972              }
    973              else
    974              {
    975                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRP1Config_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable30_10  ;; 0x40023c1a
   \   00000026   0x8800             LDRH     R0,[R0, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable30_10  ;; 0x40023c1a
   \   0000002C   0x8008             STRH     R0,[R1, #+0]
    976              }
    977            }
    978          }
   \                     ??FLASH_OB_WRP1Config_0: (+1)
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    979          
    980          #if defined (STM32F429X)
    981          /**
    982            * @brief  Select the Protection Mode (SPRMOD). 
    983            * 
    984            * @note   This function can be used only for STM32F429x/439x devices.       
    985            * 
    986            * @note   After PCROP activation, Option Byte modification is not possible. 
    987            *         Exception made for the global Read Out Protection modification level (level1 to level0) 
    988            * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
    989            *   
    990            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    991            *   
    992            * @note   Some Precautions should be taken when activating the PCROP feature :
    993            *         The active value of nWRPi bits is inverted when PCROP mode is active, this means if SPRMOD = 1
    994            *         and WRPi = 1 (default value), then the user sector i is read/write protected.
    995            *         In order to avoid activation of PCROP Mode for undesired sectors, please follow the
    996            *         below safety sequence :       
    997            *         - Disable PCROP for all Sectors using FLASH_OB_PCROPConfig(OB_PCROP_Sector_All, DISABLE) function 
    998            *           for Bank1 or FLASH_OB_PCROP1Config(OB_PCROP_Sector_All, DISABLE) function for Bank2   
    999            *         - Enable PCROP for the desired Sector i using FLASH_OB_PCROPConfig(Sector i, ENABLE) function
   1000            *         - Activate the PCROP Mode FLASH_OB_PCROPSelectionConfig() function. 
   1001            * 
   1002            * @param  OB_PCROP:  Select the Protection Mode of nWPRi bits 
   1003            *          This parameter can be one of the following values:
   1004            *            @arg OB_PcROP_Disable: nWRPi control the write protection of respective user sectors.
   1005            *            @arg OB_PcROP_Enable: nWRPi control the  read&write protection (PCROP) of respective user sectors.
   1006            * @retval None
   1007            */
   1008          void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
   1009          {  
   1010            uint8_t optiontmp = 0xFF;
   1011                
   1012            /* Check the parameters */
   1013            assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
   1014            
   1015            /* Mask SPRMOD bit */
   1016            optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
   1017            /* Update Option Byte */
   1018            *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
   1019              
   1020          }
   1021          
   1022          /**
   1023            * @brief  Enables or disables the read/write protection (PCROP) of the desired 
   1024            *         sectors, for the first 1 MB of the Flash.
   1025            * @note   This function can be used only for STM32F429x/439x devices.
   1026            * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
   1027            *          This parameter can be one of the following values:
   1028            *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector11
   1029            *            @arg OB_PCROP_Sector_All                         
   1030            * @param  Newstate: new state of the Write Protection.
   1031            *          This parameter can be: ENABLE or DISABLE.
   1032            * @retval None  
   1033            */
   1034          void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
   1035          { 
   1036            FLASH_Status status = FLASH_COMPLETE;
   1037            
   1038            /* Check the parameters */
   1039            assert_param(IS_OB_PCROP(OB_PCROP));
   1040            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1041              
   1042            status = FLASH_WaitForLastOperation();
   1043          
   1044            if(status == FLASH_COMPLETE)
   1045            { 
   1046              if(NewState != DISABLE)
   1047              {
   1048                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
   1049              }
   1050              else
   1051              {
   1052                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
   1053              }
   1054            }
   1055          }
   1056          
   1057          /**
   1058             * @brief Enables or disables the read/write protection (PCROP) of the desired 
   1059            *         sectors
   1060            * @note   This function can be used only for STM32F429x/439x devices.
   1061            * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
   1062            *          This parameter can be one of the following values:
   1063            *            @arg OB_PCROP: A value between OB_PCROP_Sector12 and OB_PCROP_Sector23 
   1064            *            @arg OB_PCROP_Sector_All                    
   1065            * @param  Newstate: new state of the Write Protection.
   1066            *          This parameter can be: ENABLE or DISABLE.
   1067            * @retval None  
   1068            */
   1069          void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
   1070          { 
   1071            FLASH_Status status = FLASH_COMPLETE;
   1072            
   1073            /* Check the parameters */
   1074            assert_param(IS_OB_PCROP(OB_PCROP));
   1075            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1076              
   1077            status = FLASH_WaitForLastOperation();
   1078          
   1079            if(status == FLASH_COMPLETE)
   1080            { 
   1081              if(NewState != DISABLE)
   1082              {
   1083                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
   1084              }
   1085              else
   1086              {
   1087                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
   1088              }
   1089            }
   1090          }
   1091          #endif /* STM32F429X */
   1092          
   1093          /**
   1094            * @brief  Sets the read protection level.
   1095            * @param  OB_RDP: specifies the read protection level.
   1096            *          This parameter can be one of the following values:
   1097            *            @arg OB_RDP_Level_0: No protection
   1098            *            @arg OB_RDP_Level_1: Read protection of the memory
   1099            *            @arg OB_RDP_Level_2: Full chip protection
   1100            *   
   1101            * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
   1102            *    
   1103            * @retval None
   1104            */

   \                                 In section .text, align 2, keep-with-next
   1105          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
   1106          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1107            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2009             MOVS     R0,#+9
   1108          
   1109            /* Check the parameters */
   1110            assert_param(IS_OB_RDP(OB_RDP));
   1111          
   1112            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1113          
   1114            if(status == FLASH_COMPLETE)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2809             CMP      R0,#+9
   \   0000000E   0xD101             BNE.N    ??FLASH_OB_RDPConfig_0
   1115            {
   1116              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
   \   00000010   0x....             LDR.N    R0,??DataTable30_11  ;; 0x40023c15
   \   00000012   0x7004             STRB     R4,[R0, #+0]
   1117          
   1118            }
   1119          }
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1120          
   1121          /**
   1122            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
   1123            * @param  OB_IWDG: Selects the IWDG mode
   1124            *          This parameter can be one of the following values:
   1125            *            @arg OB_IWDG_SW: Software IWDG selected
   1126            *            @arg OB_IWDG_HW: Hardware IWDG selected
   1127            * @param  OB_STOP: Reset event when entering STOP mode.
   1128            *          This parameter  can be one of the following values:
   1129            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1130            *            @arg OB_STOP_RST: Reset generated when entering in STOP
   1131            * @param  OB_STDBY: Reset event when entering Standby mode.
   1132            *          This parameter  can be one of the following values:
   1133            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1134            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1135            * @retval None
   1136            */

   \                                 In section .text, align 2, keep-with-next
   1137          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1138          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1139            uint8_t optiontmp = 0xFF;
   \   00000008   0x20FF             MOVS     R0,#+255
   1140            FLASH_Status status = FLASH_COMPLETE; 
   \   0000000A   0x2009             MOVS     R0,#+9
   1141          
   1142            /* Check the parameters */
   1143            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1144            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1145            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1146          
   1147            /* Wait for last operation to be completed */
   1148            status = FLASH_WaitForLastOperation();
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1149            
   1150            if(status == FLASH_COMPLETE)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2809             CMP      R0,#+9
   \   00000014   0xD108             BNE.N    ??FLASH_OB_UserConfig_0
   1151            { 
   1152          #if defined (STM32F427X) || defined (STM32F429X)     
   1153              /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
   1154              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
   1155          #endif /* STM32F427X || STM32F429X */
   1156          
   1157          #ifdef STM32F40XX 
   1158              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
   1159              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
   \   00000016   0x....             LDR.N    R0,??DataTable30_5  ;; 0x40023c14
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF010 0x000F      ANDS     R0,R0,#0xF
   1160          #endif /* STM32F40XX */ 
   1161          
   1162              /* Update User Option Byte */
   1163              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
   \   0000001E   0x4328             ORRS     R0,R0,R5
   \   00000020   0x4330             ORRS     R0,R0,R6
   \   00000022   0x4320             ORRS     R0,R0,R4
   \   00000024   0x....             LDR.N    R1,??DataTable30_5  ;; 0x40023c14
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1164            }  
   1165          }
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1166          
   1167          #if defined (STM32F429X)
   1168          /**
   1169            * @brief  Configure the Dual Bank Boot.
   1170            * @note   This function can be used only for STM32F429x/439x device.
   1171            *      
   1172            * @param  OB_BOOT: specifies the Dual Bank Boot Option byte.
   1173            *          This parameter can be one of the following values:
   1174            *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable
   1175            *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled
   1176            * @retval None
   1177            */
   1178          void FLASH_OB_BootConfig(uint8_t OB_BOOT)
   1179          {
   1180            /* Check the parameters */
   1181            assert_param(IS_OB_BOOT(OB_BOOT));
   1182          
   1183            /* Set Dual Bank Boot */
   1184            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
   1185            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
   1186          
   1187          }
   1188          #endif /* STM32F429X */
   1189          
   1190          /**
   1191            * @brief  Sets the BOR Level. 
   1192            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
   1193            *          This parameter can be one of the following values:
   1194            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1195            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1196            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1197            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
   1198            * @retval None
   1199            */

   \                                 In section .text, align 2, keep-with-next
   1200          void FLASH_OB_BORConfig(uint8_t OB_BOR)
   1201          {
   1202            /* Check the parameters */
   1203            assert_param(IS_OB_BOR(OB_BOR));
   1204          
   1205            /* Set the BOR Level */
   1206            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable30_5  ;; 0x40023c14
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   00000008   0x....             LDR.N    R2,??DataTable30_5  ;; 0x40023c14
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   1207            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
   \   0000000C   0x....             LDR.N    R1,??DataTable30_5  ;; 0x40023c14
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x4308             ORRS     R0,R0,R1
   \   00000012   0x....             LDR.N    R1,??DataTable30_5  ;; 0x40023c14
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   1208          
   1209          }
   \   00000016   0x4770             BX       LR               ;; return
   1210          
   1211          /**
   1212            * @brief  Launch the option byte loading.
   1213            * @param  None
   1214            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1215            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1216            */

   \                                 In section .text, align 2, keep-with-next
   1217          FLASH_Status FLASH_OB_Launch(void)
   1218          {
   \                     FLASH_OB_Launch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1219            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2009             MOVS     R0,#+9
   1220          
   1221            /* Set the OPTSTRT bit in OPTCR register */
   1222            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \   00000004   0x....             LDR.N    R0,??DataTable30_5  ;; 0x40023c14
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000C   0x....             LDR.N    R1,??DataTable30_5  ;; 0x40023c14
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   1223          
   1224            /* Wait for last operation to be completed */
   1225            status = FLASH_WaitForLastOperation();
   \   00000010   0x.... 0x....      BL       FLASH_WaitForLastOperation
   1226          
   1227            return status;
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
   1228          }
   1229          
   1230          /**
   1231            * @brief  Returns the FLASH User Option Bytes values.
   1232            * @param  None
   1233            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
   1234            *         and RST_STDBY(Bit2).
   1235            */

   \                                 In section .text, align 2, keep-with-next
   1236          uint8_t FLASH_OB_GetUser(void)
   1237          {
   1238            /* Return the User Option Byte */
   1239            return (uint8_t)(FLASH->OPTCR >> 5);
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_5  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0940             LSRS     R0,R0,#+5
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
   1240          }
   1241          
   1242          /**
   1243            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1244            * @param  None
   1245            * @retval The FLASH Write Protection  Option Bytes value
   1246            */

   \                                 In section .text, align 2, keep-with-next
   1247          uint16_t FLASH_OB_GetWRP(void)
   1248          {
   1249            /* Return the FLASH write protection Register value */
   1250            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_9  ;; 0x40023c16
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0x4770             BX       LR               ;; return
   1251          }
   1252          
   1253          /**
   1254            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1255            * @note   This function can be used only for STM32F427x/437x and STM32F429x/439x devices.  
   1256            * @param  None
   1257            * @retval The FLASH Write Protection  Option Bytes value
   1258            */

   \                                 In section .text, align 2, keep-with-next
   1259          uint16_t FLASH_OB_GetWRP1(void)
   1260          {
   1261            /* Return the FLASH write protection Register value */
   1262            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP1: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_10  ;; 0x40023c1a
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0x4770             BX       LR               ;; return
   1263          }
   1264          
   1265          #if defined (STM32F429X)
   1266          /**
   1267            * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
   1268            * @note   This function can be used only for STM32F429x/439x devices.  
   1269            * @param  None
   1270            * @retval The FLASH PC Read/Write Protection Option Bytes value
   1271            */
   1272          uint16_t FLASH_OB_GetPCROP(void)
   1273          {
   1274            /* Return the FLASH PC Read/write protection Register value */
   1275            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   1276          }
   1277          
   1278          /**
   1279            * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
   1280            * @note   This function can be used only for STM32F429x/439x devices.   
   1281            * @param  None
   1282            * @retval The FLASH PC Read/Write Protection Option Bytes value
   1283            */
   1284          uint16_t FLASH_OB_GetPCROP1(void)
   1285          {
   1286            /* Return the FLASH write protection Register value */
   1287            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
   1288          }
   1289          #endif /* STM32F429X */
   1290          
   1291          /**
   1292            * @brief  Returns the FLASH Read Protection level.
   1293            * @param  None
   1294            * @retval FLASH ReadOut Protection Status:
   1295            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
   1296            *           - RESET, when OB_RDP_Level_0 is set
   1297            */

   \                                 In section .text, align 2, keep-with-next
   1298          FlagStatus FLASH_OB_GetRDP(void)
   1299          {
   1300            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   1301          
   1302            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
   \   00000002   0x....             LDR.N    R0,??DataTable30_11  ;; 0x40023c15
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x28AA             CMP      R0,#+170
   \   0000000A   0xD001             BEQ.N    ??FLASH_OB_GetRDP_0
   1303            {
   1304              readstatus = SET;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??FLASH_OB_GetRDP_1
   1305            }
   1306            else
   1307            {
   1308              readstatus = RESET;
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   1309            }
   1310            return readstatus;
   \                     ??FLASH_OB_GetRDP_1: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1311          }
   1312          
   1313          /**
   1314            * @brief  Returns the FLASH BOR level.
   1315            * @param  None
   1316            * @retval The FLASH BOR level:
   1317            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1318            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1319            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1320            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
   1321            */

   \                                 In section .text, align 2, keep-with-next
   1322          uint8_t FLASH_OB_GetBOR(void)
   1323          {
   1324            /* Return the FLASH BOR level */
   1325            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable30_5  ;; 0x40023c14
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000008   0x4770             BX       LR               ;; return
   1326          }
   1327          
   1328          /**
   1329            * @}
   1330            */
   1331          
   1332          /** @defgroup FLASH_Group4 Interrupts and flags management functions
   1333           *  @brief   Interrupts and flags management functions
   1334           *
   1335          @verbatim   
   1336           ===============================================================================
   1337                        ##### Interrupts and flags management functions #####
   1338           ===============================================================================  
   1339          @endverbatim
   1340            * @{
   1341            */
   1342          
   1343          /**
   1344            * @brief  Enables or disables the specified FLASH interrupts.
   1345            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
   1346            *          This parameter can be any combination of the following values:
   1347            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
   1348            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
   1349            * @retval None 
   1350            */

   \                                 In section .text, align 2, keep-with-next
   1351          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1352          {
   1353            /* Check the parameters */
   1354            assert_param(IS_FLASH_IT(FLASH_IT)); 
   1355            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1356          
   1357            if(NewState != DISABLE)
   \                     FLASH_ITConfig: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??FLASH_ITConfig_0
   1358            {
   1359              /* Enable the interrupt sources */
   1360              FLASH->CR |= FLASH_IT;
   \   00000006   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE005             B.N      ??FLASH_ITConfig_1
   1361            }
   1362            else
   1363            {
   1364              /* Disable the interrupt sources */
   1365              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable30_1  ;; 0x40023c10
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1366            }
   1367          }
   \                     ??FLASH_ITConfig_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1368          
   1369          /**
   1370            * @brief  Checks whether the specified FLASH flag is set or not.
   1371            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1372            *          This parameter can be one of the following values:
   1373            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
   1374            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
   1375            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1376            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
   1377            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
   1378            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
   1379            *            @arg FLASH_FLAG_RDERR: FLASH (PCROP) Read Protection error flag (STM32F429x/439x devices) 
   1380            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
   1381            * @retval The new state of FLASH_FLAG (SET or RESET).
   1382            */

   \                                 In section .text, align 2, keep-with-next
   1383          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1384          {
   1385            FlagStatus bitstatus = RESET;
   \                     FLASH_GetFlagStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1386            /* Check the parameters */
   1387            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
   1388          
   1389            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \   00000002   0x....             LDR.N    R1,??DataTable30_12  ;; 0x40023c0c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x4201             TST      R1,R0
   \   00000008   0xD001             BEQ.N    ??FLASH_GetFlagStatus_0
   1390            {
   1391              bitstatus = SET;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xE000             B.N      ??FLASH_GetFlagStatus_1
   1392            }
   1393            else
   1394            {
   1395              bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   1396            }
   1397            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1398            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_1: (+1)
   \   00000010   0x0008             MOVS     R0,R1
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1399          }
   1400          
   1401          /**
   1402            * @brief  Clears the FLASH's pending flags.
   1403            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1404            *          This parameter can be any combination of the following values:
   1405            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
   1406            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
   1407            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1408            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
   1409            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
   1410            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
   1411            *            @arg FLASH_FLAG_RDERR: FLASH Read Protection error flag (STM32F429x/439x devices)  
   1412            * @retval None
   1413            */

   \                                 In section .text, align 2, keep-with-next
   1414          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1415          {
   1416            /* Check the parameters */
   1417            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
   1418            
   1419            /* Clear the flags */
   1420            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable30_12  ;; 0x40023c0c
   \   00000002   0x6008             STR      R0,[R1, #+0]
   1421          }
   \   00000004   0x4770             BX       LR               ;; return
   1422          
   1423          /**
   1424            * @brief  Returns the FLASH Status.
   1425            * @param  None
   1426            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1427            *                       FLASH_ERROR_WRP, FLASH_ERROR_RD, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1428            */

   \                                 In section .text, align 2, keep-with-next
   1429          FLASH_Status FLASH_GetStatus(void)
   1430          {
   1431            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \   00000000   0x2009             MOVS     R0,#+9
   1432            
   1433            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R0,??DataTable30_12  ;; 0x40023c0c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x03C0             LSLS     R0,R0,#+15
   \   00000008   0xD501             BPL.N    ??FLASH_GetStatus_0
   1434            {
   1435              flashstatus = FLASH_BUSY;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE019             B.N      ??FLASH_GetStatus_1
   1436            }
   1437            else 
   1438            {  
   1439              if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable30_12  ;; 0x40023c0c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x06C0             LSLS     R0,R0,#+27
   \   00000014   0xD501             BPL.N    ??FLASH_GetStatus_2
   1440              { 
   1441                flashstatus = FLASH_ERROR_WRP;
   \   00000016   0x2006             MOVS     R0,#+6
   \   00000018   0xE013             B.N      ??FLASH_GetStatus_1
   1442              }
   1443              else
   1444              {
   1445                if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable30_12  ;; 0x40023c0c
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x05C0             LSLS     R0,R0,#+23
   \   00000020   0xD501             BPL.N    ??FLASH_GetStatus_3
   1446                { 
   1447                  flashstatus = FLASH_ERROR_RD;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE00D             B.N      ??FLASH_GetStatus_1
   1448                } 
   1449                else 
   1450                {
   1451                  if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_3: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable30_12  ;; 0x40023c0c
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF010 0x0FEF      TST      R0,#0xEF
   \   0000002E   0xD001             BEQ.N    ??FLASH_GetStatus_4
   1452                  {
   1453                    flashstatus = FLASH_ERROR_PROGRAM; 
   \   00000030   0x2007             MOVS     R0,#+7
   \   00000032   0xE006             B.N      ??FLASH_GetStatus_1
   1454                  }
   1455                  else
   1456                  {
   1457                    if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_4: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable30_12  ;; 0x40023c0c
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x0780             LSLS     R0,R0,#+30
   \   0000003A   0xD501             BPL.N    ??FLASH_GetStatus_5
   1458                    {
   1459                      flashstatus = FLASH_ERROR_OPERATION;
   \   0000003C   0x2008             MOVS     R0,#+8
   \   0000003E   0xE000             B.N      ??FLASH_GetStatus_1
   1460                    }
   1461                    else
   1462                    {
   1463                      flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_5: (+1)
   \   00000040   0x2009             MOVS     R0,#+9
   1464                    }
   1465                  }
   1466                }
   1467              }
   1468            }
   1469            /* Return the FLASH Status */
   1470            return flashstatus;
   \                     ??FLASH_GetStatus_1: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x4770             BX       LR               ;; return
   1471          }
   1472          
   1473          /**
   1474            * @brief  Waits for a FLASH operation to complete.
   1475            * @param  None
   1476            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1477            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1478            */

   \                                 In section .text, align 2, keep-with-next
   1479          FLASH_Status FLASH_WaitForLastOperation(void)
   1480          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1481            __IO FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2009             MOVS     R0,#+9
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1482             
   1483            /* Check for the FLASH Status */
   1484            status = FLASH_GetStatus();
   \   00000008   0x.... 0x....      BL       FLASH_GetStatus
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE003             B.N      ??FLASH_WaitForLastOperation_0
   1485          
   1486            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1487               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1488               flag will be set */
   1489            while(status == FLASH_BUSY)
   1490            {
   1491              status = FLASH_GetStatus();
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   00000012   0x.... 0x....      BL       FLASH_GetStatus
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1492            }
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD0F7             BEQ.N    ??FLASH_WaitForLastOperation_1
   1493            /* Return the operation status */
   1494            return status;
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   1495          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x40023C16         DC32     0x40023c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x40023C1A         DC32     0x40023c1a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x40023C15         DC32     0x40023c15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x40023C0C         DC32     0x40023c0c
   1496          
   1497          /**
   1498            * @}
   1499            */ 
   1500          
   1501          /**
   1502            * @}
   1503            */ 
   1504          
   1505          /**
   1506            * @}
   1507            */ 
   1508          
   1509          /**
   1510            * @}
   1511            */
   1512          
   1513          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
       0   FLASH_DataCacheCmd
       0   FLASH_DataCacheReset
       8   FLASH_EraseAllSectors
         8   -> FLASH_WaitForLastOperation
      16   FLASH_EraseSector
        16   -> FLASH_WaitForLastOperation
       0   FLASH_GetFlagStatus
       0   FLASH_GetStatus
       0   FLASH_ITConfig
       0   FLASH_InstructionCacheCmd
       0   FLASH_InstructionCacheReset
       0   FLASH_Lock
       0   FLASH_OB_BORConfig
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       0   FLASH_OB_GetWRP1
       8   FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Lock
       8   FLASH_OB_RDPConfig
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Unlock
      16   FLASH_OB_UserConfig
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRP1Config
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_PrefetchBufferCmd
      16   FLASH_ProgramByte
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramDoubleWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
       6  FLASH_ClearFlag
      42  FLASH_DataCacheCmd
      18  FLASH_DataCacheReset
     134  FLASH_EraseAllSectors
     176  FLASH_EraseSector
      22  FLASH_GetFlagStatus
      70  FLASH_GetStatus
      32  FLASH_ITConfig
      42  FLASH_InstructionCacheCmd
      18  FLASH_InstructionCacheReset
      18  FLASH_Lock
      24  FLASH_OB_BORConfig
      10  FLASH_OB_GetBOR
      22  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       8  FLASH_OB_GetWRP
       8  FLASH_OB_GetWRP1
      24  FLASH_OB_Launch
      14  FLASH_OB_Lock
      22  FLASH_OB_RDPConfig
      22  FLASH_OB_Unlock
      42  FLASH_OB_UserConfig
      48  FLASH_OB_WRP1Config
      48  FLASH_OB_WRPConfig
      42  FLASH_PrefetchBufferCmd
      72  FLASH_ProgramByte
      80  FLASH_ProgramDoubleWord
      76  FLASH_ProgramHalfWord
      76  FLASH_ProgramWord
       8  FLASH_SetLatency
      32  FLASH_Unlock
      40  FLASH_WaitForLastOperation

 
 1 358 bytes in section .text
 
 1 358 bytes of CODE memory

Errors: none
Warnings: none
