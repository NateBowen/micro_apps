###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       23/Jan/2017  19:20:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Utilities\STM32_EVAL\STM3240_41_G_EVAL\stm324xg_eval_ioe.c
#    Command line =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Utilities\STM32_EVAL\STM3240_41_G_EVAL\stm324xg_eval_ioe.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\STM324xG_EVAL\List
#        -o
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\..\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\STM324xG_EVAL\List\stm324xg_eval_ioe.lst
#    Object file  =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\STM32F4xx_StdPeriph_Templates\EWARM\STM324xG_EVAL\Obj\stm324xg_eval_ioe.o
#
###############################################################################

C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Utilities\STM32_EVAL\STM3240_41_G_EVAL\stm324xg_eval_ioe.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm324xg_eval_ioe.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    11-January-2013
      7            * @brief   This file provides a set of functions needed to manage the STMPE811
      8            *          IO Expander devices mounted on STM324xG-EVAL evaluation board.
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */ 
     28          
     29            /* File Info : ---------------------------------------------------------------
     30            
     31              Note:
     32              -----
     33              - This driver uses the DMA method for sending and receiving data on I2C bus
     34                which allow higher efficiency and reliability of the communication.  
     35            
     36              SUPPORTED FEATURES:
     37                - IO Read/write : Set/Reset and Read (Polling/Interrupt)
     38                - Joystick: config and Read (Polling/Interrupt)
     39                - Touch Screen Features: Single point mode (Polling/Interrupt)
     40                - TempSensor Feature: accuracy not determined (Polling).
     41          
     42              UNSUPPORTED FEATURES:
     43                - Row ADC Feature is not supported (not implemented on STM324xG_EVAL board)
     44            ----------------------------------------------------------------------------*/
     45          
     46          /* Includes ------------------------------------------------------------------*/
     47          #include "stm324xg_eval_ioe.h"
     48          
     49          /** @addtogroup Utilities
     50            * @{
     51            */
     52          
     53          /** @addtogroup STM32_EVAL
     54            * @{
     55            */ 
     56          
     57          /** @addtogroup STM324xG_EVAL
     58            * @{
     59            */
     60              
     61          /** @defgroup STM324xG_EVAL_IOE 
     62            * @brief  This file includes the IO Expander driver for STMPE811 IO Expander 
     63            *         devices.
     64            * @{
     65            */ 
     66            
     67          
     68          /** @defgroup STM324xG_EVAL_IOE_Private_TypesDefinitions
     69            * @{
     70            */ 
     71          /**
     72            * @}
     73            */ 
     74          
     75          
     76          /** @defgroup STM324xG_EVAL_IOE_Private_Defines
     77            * @{
     78            */ 
     79          #define TIMEOUT_MAX    0x3000 /*<! The value of the maximal timeout for I2C waiting loops */
     80          /**
     81            * @}
     82            */ 
     83          
     84          
     85          /** @defgroup STM324xG_EVAL_IOE_Private_Macros
     86            * @{
     87            */ 
     88          /**
     89            * @}
     90            */ 
     91          
     92          /** @defgroup STM324xG_EVAL_IOE_Private_Variables
     93            * @{
     94            */ 

   \                                 In section .bss, align 4
     95          TS_STATE TS_State;              /* The global structure holding the TS state */
   \                     TS_State:
   \   00000000                      DS8 8
     96          

   \                                 In section .data, align 4
     97          uint32_t IOE_TimeOut = TIMEOUT_MAX; /* Value of Timeout when I2C communication fails */
   \                     IOE_TimeOut:
   \   00000000   0x00003000         DC32 12288
     98          /**
     99            * @}
    100            */ 
    101          
    102          
    103          /** @defgroup STM324xG_EVAL_IOE_Private_FunctionPrototypes
    104            * @{
    105            */ 
    106          static uint16_t IOE_TS_Read_X(void);
    107          static uint16_t IOE_TS_Read_Y(void);
    108          static uint16_t IOE_TS_Read_Z(void);
    109          
    110          static void IOE_GPIO_Config(void);
    111          static void IOE_I2C_Config(void);
    112          static void IOE_DMA_Config(IOE_DMADirection_TypeDef Direction, uint8_t* buffer);
    113          static void IOE_EXTI_Config(void);
    114          
    115          #ifndef USE_Delay
    116          static void delay(__IO uint32_t nCount);
    117          #endif /* USE_Delay*/
    118          /**
    119            * @}
    120            */ 
    121          
    122          
    123          /** @defgroup STM324xG_EVAL_IOE_Private_Functions
    124            * @{
    125            */ 
    126          
    127          
    128          /**
    129            * @brief  Initializes and Configures the two IO_Expanders Functionalities 
    130            *         (IOs, Touch Screen ..) and configures all STM324xG_EVAL necessary
    131            *         hardware (GPIOs, APB clocks ..).
    132            * @param  None
    133            * @retval IOE_OK if all initializations done correctly. Other value if error.
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          uint8_t IOE_Config(void)
    136          {
   \                     IOE_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    137            /* Configure the needed pins */
    138            IOE_GPIO_Config(); 
   \   00000002   0x.... 0x....      BL       IOE_GPIO_Config
    139            
    140            IOE_I2C_Config();
   \   00000006   0x.... 0x....      BL       IOE_I2C_Config
    141              
    142            /* Read IO Expander 1 ID  */
    143            if(IOE_IsOperational(IOE_1_ADDR))
   \   0000000A   0x2082             MOVS     R0,#+130
   \   0000000C   0x.... 0x....      BL       IOE_IsOperational
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??IOE_Config_0
    144            {
    145              return IOE1_NOT_OPERATIONAL;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE05E             B.N      ??IOE_Config_1
    146            }
    147            if(IOE_IsOperational(IOE_2_ADDR))
   \                     ??IOE_Config_0: (+1)
   \   00000018   0x2088             MOVS     R0,#+136
   \   0000001A   0x.... 0x....      BL       IOE_IsOperational
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??IOE_Config_2
    148            {
    149              return IOE2_NOT_OPERATIONAL;
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0xE057             B.N      ??IOE_Config_1
    150            }
    151            
    152            /* Generate IOExpander Software reset */
    153            IOE_Reset(IOE_1_ADDR); 
   \                     ??IOE_Config_2: (+1)
   \   00000026   0x2082             MOVS     R0,#+130
   \   00000028   0x.... 0x....      BL       IOE_Reset
    154            IOE_Reset(IOE_2_ADDR);
   \   0000002C   0x2088             MOVS     R0,#+136
   \   0000002E   0x.... 0x....      BL       IOE_Reset
    155            
    156            /* ---------------------- IO Expander 1 configuration --------------------- */
    157            /* Enable the GPIO, Touch Screen, MEMS and ADC functionalities */
    158            IOE_FnctCmd(IOE_1_ADDR, IOE_IO_FCT | IOE_ADC_FCT, ENABLE);
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x2105             MOVS     R1,#+5
   \   00000036   0x2082             MOVS     R0,#+130
   \   00000038   0x.... 0x....      BL       IOE_FnctCmd
    159          
    160            /* Configure the VBAT pin in output mode pin*/
    161            IOE_IOPinConfig(IOE_1_ADDR, VBAT_DIV_PIN , Direction_OUT);  
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x2082             MOVS     R0,#+130
   \   00000042   0x.... 0x....      BL       IOE_IOPinConfig
    162            /* ENABLE the alternate function for IN1 pin */
    163            IOE_IOAFConfig(IOE_1_ADDR, VBAT_DIV_PIN, ENABLE);
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x2082             MOVS     R0,#+130
   \   0000004C   0x.... 0x....      BL       IOE_IOAFConfig
    164            /* Apply the default state for the out pins */
    165            IOE_WriteIOPin(VBAT_DIV_PIN, BitReset);
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       IOE_WriteIOPin
    166          
    167            /* Touch Screen controller configuration */
    168            IOE_TS_Config();
   \   00000058   0x.... 0x....      BL       IOE_TS_Config
    169            
    170            /* Configure the MEMS interrupt pins in Input mode */
    171            IOE_IOPinConfig(IOE_1_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), Direction_IN); 
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x210C             MOVS     R1,#+12
   \   00000060   0x2082             MOVS     R0,#+130
   \   00000062   0x.... 0x....      BL       IOE_IOPinConfig
    172            /* ENABLE the alternate function for the MEMS interrupt pins */
    173            IOE_IOAFConfig(IOE_1_ADDR, (uint32_t)IOE_INMEMS_IT, ENABLE);
   \   00000066   0x2201             MOVS     R2,#+1
   \   00000068   0x210C             MOVS     R1,#+12
   \   0000006A   0x2082             MOVS     R0,#+130
   \   0000006C   0x.... 0x....      BL       IOE_IOAFConfig
    174            /* Configure the IOs to detect Falling and Rising Edges */
    175            IOE_IOEdgeConfig(IOE_1_ADDR, (uint32_t)IOE_INMEMS_IT, (uint32_t)(EDGE_FALLING | EDGE_RISING));
   \   00000070   0x2203             MOVS     R2,#+3
   \   00000072   0x210C             MOVS     R1,#+12
   \   00000074   0x2082             MOVS     R0,#+130
   \   00000076   0x.... 0x....      BL       IOE_IOEdgeConfig
    176          
    177          
    178            /* ---------------------- IO Expander 2 configuration --------------------- */
    179            /* Enable the GPIO, Temperature Sensor and ADC functionalities */
    180            IOE_FnctCmd(IOE_2_ADDR, IOE_IO_FCT | IOE_ADC_FCT, ENABLE);
   \   0000007A   0x2201             MOVS     R2,#+1
   \   0000007C   0x2105             MOVS     R1,#+5
   \   0000007E   0x2088             MOVS     R0,#+136
   \   00000080   0x.... 0x....      BL       IOE_FnctCmd
    181            
    182            /* Configure the Audio Codec Reset pin in output mode pin*/
    183            IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN), Direction_OUT);
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x2104             MOVS     R1,#+4
   \   00000088   0x2088             MOVS     R0,#+136
   \   0000008A   0x.... 0x....      BL       IOE_IOPinConfig
    184            IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(MII_INT_PIN), Direction_IN);
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x2088             MOVS     R0,#+136
   \   00000094   0x.... 0x....      BL       IOE_IOPinConfig
    185                
    186            /* ENABLE the alternate function for IN1 pin */
    187            IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN | MII_INT_PIN), ENABLE);
   \   00000098   0x2201             MOVS     R2,#+1
   \   0000009A   0x2105             MOVS     R1,#+5
   \   0000009C   0x2088             MOVS     R0,#+136
   \   0000009E   0x.... 0x....      BL       IOE_IOAFConfig
    188              
    189            /* Apply the default state for the out pins */
    190            IOE_WriteIOPin(AUDIO_RESET_PIN, BitReset);
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x2004             MOVS     R0,#+4
   \   000000A6   0x.... 0x....      BL       IOE_WriteIOPin
    191            IOE_WriteIOPin(MII_INT_PIN, BitReset);
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      BL       IOE_WriteIOPin
    192            
    193            /* Configure the Joystick pins in Input mode */
    194            IOE_IOPinConfig(IOE_2_ADDR, JOY_IO_PINS , Direction_IN); 
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x21F8             MOVS     R1,#+248
   \   000000B6   0x2088             MOVS     R0,#+136
   \   000000B8   0x.... 0x....      BL       IOE_IOPinConfig
    195            /* ENABLE the alternate function for the Joystick pins */
    196            IOE_IOAFConfig(IOE_2_ADDR, JOY_IO_PINS, ENABLE);
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0x21F8             MOVS     R1,#+248
   \   000000C0   0x2088             MOVS     R0,#+136
   \   000000C2   0x.... 0x....      BL       IOE_IOAFConfig
    197            /* Configure the IOs to detect Falling and Rising Edges */
    198            IOE_IOEdgeConfig(IOE_2_ADDR, JOY_IO_PINS, (uint8_t)(EDGE_FALLING | EDGE_RISING));
   \   000000C6   0x2203             MOVS     R2,#+3
   \   000000C8   0x21F8             MOVS     R1,#+248
   \   000000CA   0x2088             MOVS     R0,#+136
   \   000000CC   0x.... 0x....      BL       IOE_IOEdgeConfig
    199           
    200            /* Temperature Sensor module configuration */
    201            IOE_TempSens_Config();
   \   000000D0   0x.... 0x....      BL       IOE_TempSens_Config
    202            
    203            /* Configuration is OK */
    204            return IOE_OK;
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??IOE_Config_1: (+1)
   \   000000D6   0xBD02             POP      {R1,PC}          ;; return
    205          }
    206          
    207          /**
    208            * @brief  Configures The selected interrupts on the IO Expanders.
    209            * @param  IOE_ITSRC_Source: the source of the interrupts. Could be one or a 
    210            *         combination of the following parameters:
    211            *   @arg  IOE_ITSRC_JOYSTICK: Joystick IO intputs.
    212            *   @arg  IOE_ITSRC_TSC: Touch Screen interrupts.
    213            *   @arg  IOE_ITSRC_INMEMS: MEMS interrupt lines.
    214            * @retval IOE_OK: if all initializations are OK. Other value if error.
    215            */

   \                                 In section .text, align 2, keep-with-next
    216          uint8_t IOE_ITConfig(uint32_t IOE_ITSRC_Source)
    217          {   
   \                     IOE_ITConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    218            /* Configure the Interrupt output pin to generate low level (INT_CTRL) */
    219            IOE_ITOutConfig(Polarity_Low, Type_Level);  
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       IOE_ITOutConfig
    220            
    221            /* Manage the Joystick Interrupts */  
    222            if (IOE_ITSRC_Source & IOE_ITSRC_JOYSTICK)
   \   0000000C   0x0760             LSLS     R0,R4,#+29
   \   0000000E   0xD51A             BPL.N    ??IOE_ITConfig_0
    223            {   
    224              /* Enable the Global interrupt */  
    225              IOE_GITCmd(IOE_2_ADDR, ENABLE);     
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x2088             MOVS     R0,#+136
   \   00000014   0x.... 0x....      BL       IOE_GITCmd
    226                  
    227              /* Enable the Joystick pins to generate interrupt (GPIO_INT_EN) */
    228              IOE_IOITConfig(IOE_2_ADDR, IOE_JOY_IT, ENABLE);   
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x21F8             MOVS     R1,#+248
   \   0000001C   0x2088             MOVS     R0,#+136
   \   0000001E   0x.... 0x....      BL       IOE_IOITConfig
    229              
    230              /* Enable the Global GPIO Interrupt */
    231              IOE_GITConfig(IOE_2_ADDR, IOE_GIT_GPIO, ENABLE);    
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2180             MOVS     R1,#+128
   \   00000026   0x2088             MOVS     R0,#+136
   \   00000028   0x.... 0x....      BL       IOE_GITConfig
    232              
    233              /* Read the GPIO_IT_STA to clear all pending bits if any */
    234              I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_INT_STA);    
   \   0000002C   0x210D             MOVS     R1,#+13
   \   0000002E   0x2088             MOVS     R0,#+136
   \   00000030   0x.... 0x....      BL       I2C_ReadDeviceRegister
    235              
    236              /* Enable the Joystick pins to generate interrupt */
    237              IOE_IOITConfig(IOE_2_ADDR, IOE_JOY_IT, ENABLE);  
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x21F8             MOVS     R1,#+248
   \   00000038   0x2088             MOVS     R0,#+136
   \   0000003A   0x.... 0x....      BL       IOE_IOITConfig
    238              
    239              /* Read the GPIO_IT_STA to clear all pending bits if any */
    240              I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_INT_STA);     
   \   0000003E   0x210D             MOVS     R1,#+13
   \   00000040   0x2088             MOVS     R0,#+136
   \   00000042   0x.... 0x....      BL       I2C_ReadDeviceRegister
    241            }
    242          
    243            /* Manage the MEMS Interrupts lines  */  
    244            if (IOE_ITSRC_Source & IOE_ITSRC_INMEMS)
   \                     ??IOE_ITConfig_0: (+1)
   \   00000046   0x07A0             LSLS     R0,R4,#+30
   \   00000048   0xD51A             BPL.N    ??IOE_ITConfig_1
    245            {   
    246              /* Enable the Global interrupt */  
    247              IOE_GITCmd(IOE_1_ADDR, ENABLE);     
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x2082             MOVS     R0,#+130
   \   0000004E   0x.... 0x....      BL       IOE_GITCmd
    248                  
    249              /* Enable the pins to generate interrupt (GPIO_INT_EN) */
    250              IOE_IOITConfig(IOE_1_ADDR, IOE_INMEMS_IT, ENABLE);   
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x210C             MOVS     R1,#+12
   \   00000056   0x2082             MOVS     R0,#+130
   \   00000058   0x.... 0x....      BL       IOE_IOITConfig
    251              
    252              /* Enable the Global GPIO Interrupt */
    253              IOE_GITConfig(IOE_1_ADDR, IOE_GIT_GPIO, ENABLE);    
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x2180             MOVS     R1,#+128
   \   00000060   0x2082             MOVS     R0,#+130
   \   00000062   0x.... 0x....      BL       IOE_GITConfig
    254              
    255              /* Read the GPIO_IT_STA to clear all pending bits if any */
    256              I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA);    
   \   00000066   0x210D             MOVS     R1,#+13
   \   00000068   0x2082             MOVS     R0,#+130
   \   0000006A   0x.... 0x....      BL       I2C_ReadDeviceRegister
    257              
    258              /* Enable the pins to generate interrupt */
    259              IOE_IOITConfig(IOE_1_ADDR, IOE_INMEMS_IT, ENABLE);  
   \   0000006E   0x2201             MOVS     R2,#+1
   \   00000070   0x210C             MOVS     R1,#+12
   \   00000072   0x2082             MOVS     R0,#+130
   \   00000074   0x.... 0x....      BL       IOE_IOITConfig
    260              
    261              /* Read the GPIO_IT_STA to clear all pending bits if any */
    262              I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA);     
   \   00000078   0x210D             MOVS     R1,#+13
   \   0000007A   0x2082             MOVS     R0,#+130
   \   0000007C   0x.... 0x....      BL       I2C_ReadDeviceRegister
    263            }  
    264            
    265            /* Manage the Touch Screen Interrupts */  
    266            if (IOE_ITSRC_Source & IOE_ITSRC_TSC)
   \                     ??IOE_ITConfig_1: (+1)
   \   00000080   0x07E0             LSLS     R0,R4,#+31
   \   00000082   0xD50C             BPL.N    ??IOE_ITConfig_2
    267            {   
    268              /* Enable the Global interrupt */  
    269              IOE_GITCmd(IOE_1_ADDR, ENABLE);     
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x2082             MOVS     R0,#+130
   \   00000088   0x.... 0x....      BL       IOE_GITCmd
    270                     
    271              /* Enable the Global GPIO Interrupt */
    272              IOE_GITConfig(IOE_1_ADDR, (uint8_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV), ENABLE);    
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x2107             MOVS     R1,#+7
   \   00000090   0x2082             MOVS     R0,#+130
   \   00000092   0x.... 0x....      BL       IOE_GITConfig
    273              
    274              /* Read the GPIO_IT_STA to clear all pending bits if any */
    275              I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA); 
   \   00000096   0x210D             MOVS     R1,#+13
   \   00000098   0x2082             MOVS     R0,#+130
   \   0000009A   0x.... 0x....      BL       I2C_ReadDeviceRegister
    276            }
    277            
    278            /* Configure the Interrupt line as EXTI source */
    279            IOE_EXTI_Config();    
   \                     ??IOE_ITConfig_2: (+1)
   \   0000009E   0x.... 0x....      BL       IOE_EXTI_Config
    280            
    281            /* If all OK return IOE_OK */
    282            return IOE_OK;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xBD10             POP      {R4,PC}          ;; return
    283          }
    284          
    285          /**
    286            * @brief  Writes a bit value to an output IO pin.
    287            * @param IO_Pin: The output pin to be set or reset. This parameter can be one 
    288            *        of the following values:
    289            *   @arg  AUDIO_RESET_PIN: Audio codec reset pin
    290            *   @arg  MII_INT_PIN: Ethernet Phy MII interrupt pin
    291            *   @arg  VBAT_DIV_PIN: Battery divider pin
    292            * @param BitVal: The value to be set. This parameter can be one of the
    293            *        following values: BitSet or BitReset. See IOE_BitVal_TypeDef.
    294            * @retval IOE_OK or PARAM_ERROR
    295            */

   \                                 In section .text, align 2, keep-with-next
    296          uint8_t IOE_WriteIOPin(uint8_t IO_Pin, IOE_BitValue_TypeDef BitVal)
    297          {
   \                     IOE_WriteIOPin: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    298            uint8_t DeviceAddr = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    299            
    300            /* Get the IO expander Address according to which pin is to be controlled */
    301            if (IO_Pin & IO1_OUT_ALL_PINS)
   \   00000004   0x07C2             LSLS     R2,R0,#+31
   \   00000006   0xD50B             BPL.N    ??IOE_WriteIOPin_0
    302            {
    303              DeviceAddr = IOE_1_ADDR;
   \   00000008   0x2382             MOVS     R3,#+130
    304            }
    305            else if (IO_Pin & IO2_OUT_ALL_PINS)
    306            {
    307              DeviceAddr = IOE_2_ADDR;
    308            }
    309            else
    310            {
    311              return PARAM_ERROR;
    312            }
    313            
    314            /* Apply the bit value to the selected pin */
    315            if (BitVal == BitReset)
   \                     ??IOE_WriteIOPin_1: (+1)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD10E             BNE.N    ??IOE_WriteIOPin_2
    316            {
    317              /* Set the register */
    318              I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_CLR_PIN, IO_Pin);
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x2111             MOVS     R1,#+17
   \   00000016   0x0018             MOVS     R0,R3
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       I2C_WriteDeviceRegister
   \   0000001E   0xE00D             B.N      ??IOE_WriteIOPin_3
    319            }
   \                     ??IOE_WriteIOPin_0: (+1)
   \   00000020   0x2205             MOVS     R2,#+5
   \   00000022   0x4210             TST      R0,R2
   \   00000024   0xD001             BEQ.N    ??IOE_WriteIOPin_4
   \   00000026   0x2388             MOVS     R3,#+136
   \   00000028   0xE7EF             B.N      ??IOE_WriteIOPin_1
   \                     ??IOE_WriteIOPin_4: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE007             B.N      ??IOE_WriteIOPin_5
    320            else
    321            {
    322              /* Set the register */
    323              I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_SET_PIN, IO_Pin);
   \                     ??IOE_WriteIOPin_2: (+1)
   \   0000002E   0x0002             MOVS     R2,R0
   \   00000030   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000032   0x2110             MOVS     R1,#+16
   \   00000034   0x0018             MOVS     R0,R3
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       I2C_WriteDeviceRegister
    324            }
    325            
    326            return IOE_OK;
   \                     ??IOE_WriteIOPin_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??IOE_WriteIOPin_5: (+1)
   \   0000003E   0xBD02             POP      {R1,PC}          ;; return
    327          }
    328          
    329          
    330          /**
    331            * @brief  Returns the status of the selected input IO pin.
    332            * @param IO_Pin: The input pin to be read. This parameter can be one 
    333            *  of the following values:
    334            *   @arg  MEMS_INT1_PIN: MEMS interrupt line 1.
    335            *   @arg  MEMS_INT2_PIN: MEMS interrupt line 2.
    336            *   @arg  JOY_IO_PINS: Joystick IO pins (use IOE_JoyStickGetState for these pins)  
    337            * @retval None
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          uint8_t IOE_ReadIOPin(uint32_t IO_Pin)
    340          {
   \                     IOE_ReadIOPin: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    341            uint8_t DeviceAddr = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    342            uint8_t tmp = 0;  
   \   00000006   0x2000             MOVS     R0,#+0
    343            if (IO_Pin & IO1_IN_ALL_PINS)
   \   00000008   0xF014 0x0F0C      TST      R4,#0xC
   \   0000000C   0xD009             BEQ.N    ??IOE_ReadIOPin_0
    344            {
    345              DeviceAddr = IOE_1_ADDR;
   \   0000000E   0x2082             MOVS     R0,#+130
    346            }
    347            else if (IO_Pin & IO2_IN_ALL_PINS)
    348            {
    349              DeviceAddr = IOE_2_ADDR;
    350            }
    351            else 
    352            {
    353              return PARAM_ERROR;
    354            }
    355            
    356            /* Get all the Pins status */
    357            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_MP_STA);
   \                     ??IOE_ReadIOPin_1: (+1)
   \   00000010   0x2112             MOVS     R1,#+18
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       I2C_ReadDeviceRegister
    358            if ((tmp & (uint8_t)IO_Pin) != 0)
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4220             TST      R0,R4
   \   0000001C   0xD008             BEQ.N    ??IOE_ReadIOPin_2
    359            {
    360              return BitSet;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE007             B.N      ??IOE_ReadIOPin_3
    361            }  
   \                     ??IOE_ReadIOPin_0: (+1)
   \   00000022   0xF014 0x0FF8      TST      R4,#0xF8
   \   00000026   0xD001             BEQ.N    ??IOE_ReadIOPin_4
   \   00000028   0x2088             MOVS     R0,#+136
   \   0000002A   0xE7F1             B.N      ??IOE_ReadIOPin_1
   \                     ??IOE_ReadIOPin_4: (+1)
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xE000             B.N      ??IOE_ReadIOPin_3
    362            else 
    363            {
    364              return BitReset;
   \                     ??IOE_ReadIOPin_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??IOE_ReadIOPin_3: (+1)
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    365            }
    366          }
    367          
    368          
    369          /**
    370            * @brief  Returns the current Joystick status.
    371            * @param  None
    372            * @retval The code of the Joystick key pressed: 
    373            *   @arg  JOY_NONE
    374            *   @arg  JOY_SEL
    375            *   @arg  JOY_DOWN
    376            *   @arg  JOY_LEFT
    377            *   @arg  JOY_RIGHT
    378            *   @arg  JOY_UP
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          JOYState_TypeDef IOE_JoyStickGetState(void)
    381          {
   \                     IOE_JoyStickGetState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    382            uint8_t tmp = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    383            /* Read the status of all pins */
    384            tmp = (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_MP_STA);
   \   00000004   0x2112             MOVS     R1,#+18
   \   00000006   0x2088             MOVS     R0,#+136
   \   00000008   0x.... 0x....      BL       I2C_ReadDeviceRegister
    385             
    386            /* Check the pressed keys */
    387            if ((tmp & JOY_IO_NONE) == JOY_IO_NONE)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xF010 0x01F8      ANDS     R1,R0,#0xF8
   \   00000012   0x29F8             CMP      R1,#+248
   \   00000014   0xD101             BNE.N    ??IOE_JoyStickGetState_0
    388            {
    389              return (JOYState_TypeDef) JOY_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE014             B.N      ??IOE_JoyStickGetState_1
    390            }
    391            else if (!(tmp & JOY_IO_SEL))
   \                     ??IOE_JoyStickGetState_0: (+1)
   \   0000001A   0x0601             LSLS     R1,R0,#+24
   \   0000001C   0xD401             BMI.N    ??IOE_JoyStickGetState_2
    392            {
    393              return (JOYState_TypeDef) JOY_SEL;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE010             B.N      ??IOE_JoyStickGetState_1
    394            }
    395            else if (!(tmp & JOY_IO_DOWN))
   \                     ??IOE_JoyStickGetState_2: (+1)
   \   00000022   0x0641             LSLS     R1,R0,#+25
   \   00000024   0xD401             BMI.N    ??IOE_JoyStickGetState_3
    396            {
    397              return (JOYState_TypeDef) JOY_DOWN;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE00C             B.N      ??IOE_JoyStickGetState_1
    398            }
    399            else if (!(tmp & JOY_IO_LEFT))
   \                     ??IOE_JoyStickGetState_3: (+1)
   \   0000002A   0x0681             LSLS     R1,R0,#+26
   \   0000002C   0xD401             BMI.N    ??IOE_JoyStickGetState_4
    400            {
    401              return (JOYState_TypeDef) JOY_LEFT;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xE008             B.N      ??IOE_JoyStickGetState_1
    402            }
    403            else if (!(tmp & JOY_IO_RIGHT))
   \                     ??IOE_JoyStickGetState_4: (+1)
   \   00000032   0x06C1             LSLS     R1,R0,#+27
   \   00000034   0xD401             BMI.N    ??IOE_JoyStickGetState_5
    404            {
    405              return (JOYState_TypeDef) JOY_RIGHT;
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0xE004             B.N      ??IOE_JoyStickGetState_1
    406            }
    407            else if (!(tmp & JOY_IO_UP))
   \                     ??IOE_JoyStickGetState_5: (+1)
   \   0000003A   0x0700             LSLS     R0,R0,#+28
   \   0000003C   0xD401             BMI.N    ??IOE_JoyStickGetState_6
    408            {
    409              return (JOYState_TypeDef) JOY_UP;
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0xE000             B.N      ??IOE_JoyStickGetState_1
    410            }
    411            else
    412            { 
    413              return (JOYState_TypeDef) JOY_NONE;
   \                     ??IOE_JoyStickGetState_6: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??IOE_JoyStickGetState_1: (+1)
   \   00000044   0xBD02             POP      {R1,PC}          ;; return
    414            }
    415          }
    416          
    417          /**
    418            * @brief  Returns Status and positions of the Touch screen.
    419            * @param  None
    420            * @retval Pointer to TS_STATE structure holding Touch Screen information.
    421            */

   \                                 In section .text, align 2, keep-with-next
    422          TS_STATE* IOE_TS_GetState(void)
    423          {
   \                     IOE_TS_GetState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    424            uint32_t xDiff, yDiff , x , y;
    425            static uint32_t _x = 0, _y = 0;
    426            
    427            /* Check if the Touch detect event happened */
    428            TS_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL) & 0x80);
   \   00000002   0x2140             MOVS     R1,#+64
   \   00000004   0x2082             MOVS     R0,#+130
   \   00000006   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   0000000A   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    429            if(TS_State.TouchDetected) 
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD029             BEQ.N    ??IOE_TS_GetState_0
    430            {
    431              x = IOE_TS_Read_X();
   \   0000001E   0x.... 0x....      BL       IOE_TS_Read_X
   \   00000022   0x0004             MOVS     R4,R0
    432              y = IOE_TS_Read_Y();
   \   00000024   0x.... 0x....      BL       IOE_TS_Read_Y
    433              xDiff = x > _x? (x - _x): (_x - x);
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x42A1             CMP      R1,R4
   \   00000030   0xD204             BCS.N    ??IOE_TS_GetState_1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x1A61             SUBS     R1,R4,R1
   \   0000003A   0xE003             B.N      ??IOE_TS_GetState_2
   \                     ??IOE_TS_GetState_1: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x1B09             SUBS     R1,R1,R4
    434              yDiff = y > _y? (y - _y): (_y - y);       
   \                     ??IOE_TS_GetState_2: (+1)
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable10_1
   \   00000048   0x6812             LDR      R2,[R2, #+0]
   \   0000004A   0x4282             CMP      R2,R0
   \   0000004C   0xD204             BCS.N    ??IOE_TS_GetState_3
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable10_1
   \   00000052   0x6812             LDR      R2,[R2, #+0]
   \   00000054   0x1A82             SUBS     R2,R0,R2
   \   00000056   0xE003             B.N      ??IOE_TS_GetState_4
   \                     ??IOE_TS_GetState_3: (+1)
   \   00000058   0x.... 0x....      LDR.W    R2,??DataTable10_1
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0x1A12             SUBS     R2,R2,R0
    435              if (xDiff + yDiff > 5)
   \                     ??IOE_TS_GetState_4: (+1)
   \   00000060   0x1851             ADDS     R1,R2,R1
   \   00000062   0x2906             CMP      R1,#+6
   \   00000064   0xD305             BCC.N    ??IOE_TS_GetState_0
    436              {
    437                _x = x;
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000006A   0x600C             STR      R4,[R1, #+0]
    438                _y = y;       
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000070   0x6008             STR      R0,[R1, #+0]
    439              }
    440            }  
    441            /* Update the X position */
    442            TS_State.X = _x;
   \                     ??IOE_TS_GetState_0: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000007C   0x8048             STRH     R0,[R1, #+2]
    443              
    444            /* Update the Y position */  
    445            TS_State.Y = _y;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000088   0x8088             STRH     R0,[R1, #+4]
    446            /* Update the Z Pression index */  
    447            TS_State.Z = IOE_TS_Read_Z();  
   \   0000008A   0x.... 0x....      BL       IOE_TS_Read_Z
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000092   0x80C8             STRH     R0,[R1, #+6]
    448            
    449            /* Clear the interrupt pending bit and enable the FIFO again */
    450            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
   \   00000094   0x2201             MOVS     R2,#+1
   \   00000096   0x214B             MOVS     R1,#+75
   \   00000098   0x2082             MOVS     R0,#+130
   \   0000009A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    451            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x00);
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x214B             MOVS     R1,#+75
   \   000000A2   0x2082             MOVS     R0,#+130
   \   000000A4   0x.... 0x....      BL       I2C_WriteDeviceRegister
    452            
    453            /* Return pointer to the updated structure */
    454            return &TS_State; 
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000000AC   0xBD10             POP      {R4,PC}          ;; return
    455          }

   \                                 In section .bss, align 4
   \                     `IOE_TS_GetState::_x`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `IOE_TS_GetState::_y`:
   \   00000000                      DS8 4
    456          
    457          /**
    458            * @brief  Returns the temperature row value (in 16 bit format).
    459            * @param  None
    460            * @retval The temperature row value.
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          uint32_t IOE_TempSens_GetData(void)
    463          {  
   \                     IOE_TempSens_GetData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    464            static __IO uint32_t tmp = 0;  
    465              
    466            /* Acquire data enable */
    467            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x03);
   \   00000002   0x2203             MOVS     R2,#+3
   \   00000004   0x2160             MOVS     R1,#+96
   \   00000006   0x2088             MOVS     R0,#+136
   \   00000008   0x.... 0x....      BL       I2C_WriteDeviceRegister
    468            
    469            /* Enable the TEMPSENS module */
    470            tmp = (uint32_t)((I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_DATA) & 0x03) << 8); 
   \   0000000C   0x2161             MOVS     R1,#+97
   \   0000000E   0x2088             MOVS     R0,#+136
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   00000014   0x0200             LSLS     R0,R0,#+8
   \   00000016   0xF410 0x7040      ANDS     R0,R0,#0x300
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    471            tmp |= (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_DATA + 1); 
   \   00000020   0x2162             MOVS     R1,#+98
   \   00000022   0x2088             MOVS     R0,#+136
   \   00000024   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x4308             ORRS     R0,R0,R1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000036   0x6008             STR      R0,[R1, #+0]
    472            
    473            tmp = (uint32_t)((33 * tmp * 100) / 751);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000042   0x4348             MULS     R0,R1,R0
   \   00000044   0xF240 0x21EF      MOVW     R1,#+751
   \   00000048   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000050   0x6008             STR      R0,[R1, #+0]
    474            tmp = (uint32_t)((tmp + 5) / 10);
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1D40             ADDS     R0,R0,#+5
   \   0000005A   0x210A             MOVS     R1,#+10
   \   0000005C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000064   0x6008             STR      R0,[R1, #+0]
    475            
    476            /* return the temperature row value */
    477            return tmp;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xBD02             POP      {R1,PC}          ;; return
    478          }

   \                                 In section .bss, align 4
   \                     `IOE_TempSens_GetData::tmp`:
   \   00000000                      DS8 4
    479          
    480          /**
    481            * @brief  Checks the selected Global interrupt source pending bit
    482            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    483            *         or IOE_2_ADDR.
    484            * @param  Global_IT: the Global interrupt source to be checked, could be:
    485            *   @arg  Global_IT_GPIO : All IOs interrupt
    486            *   @arg  Global_IT_ADC : ADC interrupt
    487            *   @arg  Global_IT_TEMP : Temperature Sensor interrupts      
    488            *   @arg  Global_IT_FE : Touch Screen Controller FIFO Error interrupt
    489            *   @arg  Global_IT_FF : Touch Screen Controller FIFO Full interrupt      
    490            *   @arg  Global_IT_FOV : Touch Screen Controller FIFO Overrun interrupt     
    491            *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
    492            *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt      
    493            * @retval Status of the checked flag. Could be SET or RESET.
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          FlagStatus IOE_GetGITStatus(uint8_t DeviceAddr, uint8_t Global_IT)
    496          {
   \                     IOE_GetGITStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    497            __IO uint8_t tmp = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF88D 0x1000      STRB     R1,[SP, #+0]
    498           
    499            /* get the Interrupt status */
    500            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_STA);
   \   0000000C   0x210B             MOVS     R1,#+11
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    501            
    502            if ((tmp & (uint8_t)Global_IT) != 0)
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x4220             TST      R0,R4
   \   0000001E   0xD001             BEQ.N    ??IOE_GetGITStatus_0
    503            {
    504              return SET;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??IOE_GetGITStatus_1
    505            }
    506            else
    507            {
    508              return RESET;
   \                     ??IOE_GetGITStatus_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??IOE_GetGITStatus_1: (+1)
   \   00000026   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    509            }
    510          }
    511          
    512          /**
    513            * @brief  Clears the selected Global interrupt pending bit(s)
    514            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    515            *         or IOE_2_ADDR.
    516            * @param  Global_IT: the Global interrupt to be cleared, could be any combination
    517            *         of the following values:   
    518            *   @arg  Global_IT_GPIO : All IOs interrupt
    519            *   @arg  Global_IT_ADC : ADC interrupt
    520            *   @arg  Global_IT_TEMP : Temperature Sensor interrupts      
    521            *   @arg  Global_IT_FE : Touch Screen Controller FIFO Error interrupt
    522            *   @arg  Global_IT_FF : Touch Screen Controller FIFO Full interrupt      
    523            *   @arg  Global_IT_FOV : Touch Screen Controller FIFO Overrun interrupt     
    524            *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
    525            *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
    526            * @retval IOE_OK: if all initializations are OK. Other value if error.
    527            */

   \                                 In section .text, align 2, keep-with-next
    528          uint8_t IOE_ClearGITPending(uint8_t DeviceAddr, uint8_t Global_IT)
    529          {
   \                     IOE_ClearGITPending: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    530            /* Write 1 to the bits that have to be cleared */
    531            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_STA, Global_IT); 
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x210B             MOVS     R1,#+11
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    532          
    533            /* If all OK return IOE_OK */
    534            return IOE_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    535          }
    536          
    537          /**
    538            * @brief  Checks the status of the selected IO interrupt pending bit
    539            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    540            *         or IOE_2_ADDR.
    541            * @param  IO_IT: the IO interrupt to be checked could be IO_ITx Where x can be 
    542            *         from 0 to 7.             
    543            * @retval Status of the checked flag. Could be SET or RESET.
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          FlagStatus IOE_GetIOITStatus(uint8_t DeviceAddr, uint8_t IO_IT)
    546          {
   \                     IOE_GetIOITStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    547            uint8_t tmp = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    548           
    549            /* get the Interrupt status */
    550            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_STA);
   \   00000006   0x210D             MOVS     R1,#+13
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   0000000E   0x0001             MOVS     R1,R0
    551            
    552            if ((tmp & (uint8_t)IO_IT) != 0)
   \   00000010   0x0008             MOVS     R0,R1
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4220             TST      R0,R4
   \   00000016   0xD001             BEQ.N    ??IOE_GetIOITStatus_0
    553            {
    554              return SET;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??IOE_GetIOITStatus_1
    555            }
    556            else
    557            {
    558              return RESET;
   \                     ??IOE_GetIOITStatus_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??IOE_GetIOITStatus_1: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    559            }
    560          }
    561          
    562          /**
    563            * @brief  Clears the selected IO interrupt pending bit(s).
    564            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    565            *         or IOE_2_ADDR.
    566            * @param  IO_IT: the IO interrupt to be checked could be IO_ITx Where x can be 
    567            *         from 0 to 7.              
    568            * @retval IOE_OK: if all initializations are OK. Other value if error.
    569            */

   \                                 In section .text, align 2, keep-with-next
    570          uint8_t IOE_ClearIOITPending(uint8_t DeviceAddr, uint8_t IO_IT)
    571          {
   \                     IOE_ClearIOITPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    572            /* Write 1 to the bits that have to be cleared */
    573            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_STA, IO_IT);  
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x210D             MOVS     R1,#+13
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_WriteDeviceRegister
    574          
    575            /* Clear the Edge detection pending bit*/
    576            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_ED, IO_IT);
   \   00000014   0x002A             MOVS     R2,R5
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x2114             MOVS     R1,#+20
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       I2C_WriteDeviceRegister
    577          
    578            /* Clear the Rising edge pending bit */
    579            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE, IO_IT);
   \   00000022   0x002A             MOVS     R2,R5
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2115             MOVS     R1,#+21
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       I2C_WriteDeviceRegister
    580          
    581            /* Clear the Falling edge pending bit */
    582            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE, IO_IT);  
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000034   0x2116             MOVS     R1,#+22
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    583          
    584            /* If all OK return IOE_OK */
    585            return IOE_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    586          }
    587          
    588          /**
    589            * @brief  Checks if the selected device is correctly configured and 
    590            *         communicates correctly ont the I2C bus.
    591            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    592            *         or IOE_2_ADDR.
    593            * @retval IOE_OK if IOE is operational. Other value if failure.
    594            */

   \                                 In section .text, align 2, keep-with-next
    595          uint8_t IOE_IsOperational(uint8_t DeviceAddr)
    596          {
   \                     IOE_IsOperational: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    597            /* Return Error if the ID is not correct */
    598            if( IOE_ReadID(DeviceAddr) != (uint16_t)STMPE811_ID )
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x.... 0x....      BL       IOE_ReadID
   \   00000008   0xF640 0x0111      MOVW     R1,#+2065
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD009             BEQ.N    ??IOE_IsOperational_0
    599            {
    600              /* Check if a Timeout occurred */
    601              if (IOE_TimeOut == 0)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD102             BNE.N    ??IOE_IsOperational_1
    602              {
    603                return(IOE_TimeoutUserCallback());
   \   0000001A   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000001E   0xE002             B.N      ??IOE_IsOperational_2
    604              }
    605              else
    606              {
    607                return IOE_FAILURE; /* ID is not Correct */
   \                     ??IOE_IsOperational_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??IOE_IsOperational_2
    608              }
    609            } 
    610            else 
    611            {
    612              return IOE_OK; /* ID is correct */
   \                     ??IOE_IsOperational_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??IOE_IsOperational_2: (+1)
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    613            }
    614          }
    615          
    616          /**
    617            * @brief  Resets the IO Expander by Software (SYS_CTRL1, RESET bit).
    618            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    619            *         or IOE_2_ADDR.
    620            * @retval IOE_OK: if all initializations are OK. Other value if error.
    621            */

   \                                 In section .text, align 2, keep-with-next
    622          uint8_t IOE_Reset(uint8_t DeviceAddr)
    623          {
   \                     IOE_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    624            /* Power Down the IO_Expander */
    625            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x02);
   \   00000004   0x2202             MOVS     R2,#+2
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       I2C_WriteDeviceRegister
    626          
    627            /* wait for a delay to insure registers erasing */
    628            _delay_(2); 
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x.... 0x....      BL       delay
    629            
    630            /* Power On the Codec after the power off => all registers are reinitialized*/
    631            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x00);
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       I2C_WriteDeviceRegister
    632            
    633            /* If all OK return IOE_OK */
    634            return IOE_OK;    
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    635          }
    636          
    637          /**
    638            * @brief  Reads the selected device's ID.
    639            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    640            *         or IOE_2_ADDR.
    641            * @retval The Device ID (two bytes).
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          uint16_t IOE_ReadID(uint8_t DeviceAddr)
    644          {
   \                     IOE_ReadID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    645            uint16_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    646          
    647            /* Read device ID  */
    648            tmp = I2C_ReadDeviceRegister(DeviceAddr, 0);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   00000010   0x0005             MOVS     R5,R0
    649            tmp = (uint32_t)(tmp << 8);
   \   00000012   0x022D             LSLS     R5,R5,#+8
    650            tmp |= (uint32_t)I2C_ReadDeviceRegister(DeviceAddr, 1);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   0000001E   0x4305             ORRS     R5,R0,R5
    651            
    652            /* Return the ID */
    653            return (uint16_t)tmp;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    654          }
    655          
    656          /**
    657            * @brief  Configures the selected IO Expander functionalities.
    658            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    659            *         or IOE_2_ADDR.
    660            * @param  IOE_TEMPSENS_FCT: the functions to be configured. could be any 
    661            *         combination of the following values:
    662            *   @arg  IOE_IO_FCT : IO function
    663            *   @arg  IOE_TS_FCT : Touch Screen function
    664            *   @arg  IOE_ADC_FCT : ADC function
    665            *   @arg  IOE_TEMPSENS_FCT : Temperature Sensor function
    666            * @param  NewState: can be ENABLE pr DISABLE   
    667            * @retval IOE_OK: if all initializations are OK. Other value if error.
    668            */

   \                                 In section .text, align 2, keep-with-next
    669          uint8_t IOE_FnctCmd(uint8_t DeviceAddr, uint8_t Fct, FunctionalState NewState)
    670          {
   \                     IOE_FnctCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    671            uint8_t tmp = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    672            
    673            /* Get the register value */
    674            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2);
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
    675            
    676            if (NewState != DISABLE)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD001             BEQ.N    ??IOE_FnctCmd_0
    677            {
    678              /* Set the Functionalities to be Enabled */    
    679              tmp &= ~(uint8_t)Fct;
   \   0000001A   0x43A8             BICS     R0,R0,R5
   \   0000001C   0xE000             B.N      ??IOE_FnctCmd_1
    680            }
    681            else
    682            {
    683              /* Set the Functionalities to be Disabled */    
    684              tmp |= (uint8_t)Fct;  
   \                     ??IOE_FnctCmd_0: (+1)
   \   0000001E   0x4328             ORRS     R0,R5,R0
    685            }
    686            
    687            /* Set the register value */
    688            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2, tmp);
   \                     ??IOE_FnctCmd_1: (+1)
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    689            
    690            /* If all OK return IOE_OK */
    691            return IOE_OK;    
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    692          }
    693          
    694          /**
    695            * @brief  Configures the selected pin direction (to be an input or an output)
    696            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    697            *         or IOE_2_ADDR.
    698            * @param  IO_Pin: IO_Pin_x: Where x can be from 0 to 7.   
    699            * @param  Direction: could be Direction_IN or Direction_OUT.      
    700            * @retval IOE_OK: if all initializations are OK. Other value if error.
    701            */

   \                                 In section .text, align 2, keep-with-next
    702          uint8_t IOE_IOPinConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Direction)
    703          {
   \                     IOE_IOPinConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    704            uint8_t tmp = 0;   
   \   00000008   0x2000             MOVS     R0,#+0
    705            
    706            /* Get all the Pins direction */
    707            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR);
   \   0000000A   0x2113             MOVS     R1,#+19
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
    708            
    709            if (Direction != Direction_IN)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD001             BEQ.N    ??IOE_IOPinConfig_0
    710            {
    711              tmp |= (uint8_t)IO_Pin;
   \   0000001A   0x4328             ORRS     R0,R5,R0
   \   0000001C   0xE000             B.N      ??IOE_IOPinConfig_1
    712            }  
    713            else 
    714            {
    715              tmp &= ~(uint8_t)IO_Pin;
   \                     ??IOE_IOPinConfig_0: (+1)
   \   0000001E   0x43A8             BICS     R0,R0,R5
    716            }
    717            
    718            /* Write the register new value */
    719            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR, tmp);
   \                     ??IOE_IOPinConfig_1: (+1)
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x2113             MOVS     R1,#+19
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    720            
    721            /* If all OK return IOE_OK */
    722            return IOE_OK;      
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    723          }
    724          
    725          /**
    726            * @brief  Enables or disables the Global interrupt.
    727            * @param  DeviceAddr: The address of the IOExpander, could be :I OE_1_ADDR
    728            *         or IOE_2_ADDR.
    729            * @param  NewState: could be ENABLE or DISABLE.        
    730            * @retval IOE_OK: if all initializations are OK. Other value if error.
    731            */

   \                                 In section .text, align 2, keep-with-next
    732          uint8_t IOE_GITCmd(uint8_t DeviceAddr, FunctionalState NewState)
    733          {
   \                     IOE_GITCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    734            uint8_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    735            
    736            /* Read the Interrupt Control register  */
    737            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_CTRL);
   \   00000008   0x2109             MOVS     R1,#+9
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       I2C_ReadDeviceRegister
    738            
    739            if (NewState != DISABLE)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD002             BEQ.N    ??IOE_GITCmd_0
    740            {
    741              /* Set the global interrupts to be Enabled */    
    742              tmp |= (uint8_t)IOE_GIT_EN;
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0xE001             B.N      ??IOE_GITCmd_1
    743            }
    744            else
    745            {
    746              /* Set the global interrupts to be Disabled */    
    747              tmp &= ~(uint8_t)IOE_GIT_EN;
   \                     ??IOE_GITCmd_0: (+1)
   \   0000001E   0xF010 0x00FE      ANDS     R0,R0,#0xFE
    748            }  
    749            
    750            /* Write Back the Interrupt Control register */
    751            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_CTRL, tmp);
   \                     ??IOE_GITCmd_1: (+1)
   \   00000022   0x0002             MOVS     R2,R0
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2109             MOVS     R1,#+9
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       I2C_WriteDeviceRegister
    752          
    753            /* If all OK return IOE_OK */
    754            return IOE_OK;     
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    755          }
    756          
    757          /**
    758            * @brief  Configures the selected source to generate or not a global interrupt
    759            * @param DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    760            *        or IOE_2_ADDR.
    761            * @param Global_IT: the interrupt source to be configured, could be:
    762            *   @arg  Global_IT_GPIO : All IOs interrupt
    763            *   @arg  Global_IT_ADC : ADC interrupt
    764            *   @arg  Global_IT_TEMP : Temperature Sensor interrupts      
    765            *   @arg  Global_IT_FE : Touch Screen Controller FIFO Error interrupt
    766            *   @arg  Global_IT_FF : Touch Screen Controller FIFO Full interrupt      
    767            *   @arg  Global_IT_FOV : Touch Screen Controller FIFO Overrun interrupt     
    768            *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
    769            *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
    770            * @param  NewState: can be ENABLE pr DISABLE   
    771            * @retval IOE_OK: if all initializations are OK. Other value if error.
    772            */

   \                                 In section .text, align 2, keep-with-next
    773          uint8_t IOE_GITConfig(uint8_t DeviceAddr, uint8_t Global_IT, FunctionalState NewState)
    774          {
   \                     IOE_GITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    775            uint8_t tmp = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    776            
    777            /* Get the current value of the INT_EN register */
    778            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_EN);
   \   0000000A   0x210A             MOVS     R1,#+10
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
    779            
    780            if (NewState != DISABLE)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD001             BEQ.N    ??IOE_GITConfig_0
    781            {
    782              /* Set the interrupts to be Enabled */    
    783              tmp |= (uint8_t)Global_IT;  
   \   0000001A   0x4328             ORRS     R0,R5,R0
   \   0000001C   0xE000             B.N      ??IOE_GITConfig_1
    784            }
    785            else
    786            {
    787              /* Set the interrupts to be Disabled */    
    788              tmp &= ~(uint8_t)Global_IT;
   \                     ??IOE_GITConfig_0: (+1)
   \   0000001E   0x43A8             BICS     R0,R0,R5
    789            }
    790            /* Set the register */
    791            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_EN, tmp);
   \                     ??IOE_GITConfig_1: (+1)
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    792            
    793            /* If all OK return IOE_OK */
    794            return IOE_OK;  
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    795          }
    796          
    797          /**
    798            * @brief  Configures the selected pins to generate an interrupt or not.
    799            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    800            *         or IOE_2_ADDR.
    801            * @param  IO_IT: The IO interrupt to be configured. This parameter could be any
    802            *         combination of the following values:
    803            *   @arg  IO_IT_x: where x can be from 0 to 7.
    804            * @param  NewState: could be ENABLE or DISABLE.  
    805            * @retval IOE_OK: if all initializations are OK. Other value if error.
    806            */

   \                                 In section .text, align 2, keep-with-next
    807          uint8_t IOE_IOITConfig(uint8_t DeviceAddr, uint8_t IO_IT, FunctionalState NewState)
    808          {
   \                     IOE_IOITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    809            uint8_t tmp = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    810           
    811            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN);
   \   0000000A   0x210C             MOVS     R1,#+12
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
    812            
    813            if (NewState != DISABLE)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD001             BEQ.N    ??IOE_IOITConfig_0
    814            {
    815              /* Set the interrupts to be Enabled */    
    816              tmp |= (uint8_t)IO_IT;
   \   0000001A   0x4328             ORRS     R0,R5,R0
   \   0000001C   0xE000             B.N      ??IOE_IOITConfig_1
    817            }
    818            else
    819            {
    820              /* Set the interrupts to be Disabled */    
    821              tmp &= ~(uint8_t)IO_IT;
   \                     ??IOE_IOITConfig_0: (+1)
   \   0000001E   0x43A8             BICS     R0,R0,R5
    822            }
    823            
    824            /* Set the register */
    825            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN, tmp);
   \                     ??IOE_IOITConfig_1: (+1)
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x210C             MOVS     R1,#+12
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    826            
    827            /* If all OK return IOE_OK */
    828            return IOE_OK;   
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    829          }
    830          
    831          /**
    832            * @brief  Configures the touch Screen Controller (Single point detection)
    833            * @param  None
    834            * @retval IOE_OK if all initializations are OK. Other value if error.
    835            */

   \                                 In section .text, align 2, keep-with-next
    836          uint8_t IOE_TS_Config(void)
    837          { 
   \                     IOE_TS_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    838            /* Enable touch screen functionality */
    839            IOE_FnctCmd(IOE_1_ADDR, IOE_TS_FCT, ENABLE);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x2082             MOVS     R0,#+130
   \   00000008   0x.... 0x....      BL       IOE_FnctCmd
    840            
    841            /* Select Sample Time, bit number and ADC Reference */
    842            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_ADC_CTRL1, 0x49);
   \   0000000C   0x2249             MOVS     R2,#+73
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x2082             MOVS     R0,#+130
   \   00000012   0x.... 0x....      BL       I2C_WriteDeviceRegister
    843            
    844            /* Wait for ~20 ms */
    845            _delay_(2);  
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       delay
    846            
    847            /* Select the ADC clock speed: 3.25 MHz */
    848            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_ADC_CTRL2, 0x01);
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x2121             MOVS     R1,#+33
   \   00000020   0x2082             MOVS     R0,#+130
   \   00000022   0x.... 0x....      BL       I2C_WriteDeviceRegister
    849            
    850            /* Select TSC pins in non default mode */  
    851            IOE_IOAFConfig(IOE_1_ADDR, (uint8_t)TOUCH_IO_ALL, DISABLE);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x211E             MOVS     R1,#+30
   \   0000002A   0x2082             MOVS     R0,#+130
   \   0000002C   0x.... 0x....      BL       IOE_IOAFConfig
    852            
    853            /* Select 2 nF filter capacitor */
    854            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CFG, 0x9A);   
   \   00000030   0x229A             MOVS     R2,#+154
   \   00000032   0x2141             MOVS     R1,#+65
   \   00000034   0x2082             MOVS     R0,#+130
   \   00000036   0x.... 0x....      BL       I2C_WriteDeviceRegister
    855            
    856            /* Select single point reading  */
    857            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_TH, 0x01);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x214A             MOVS     R1,#+74
   \   0000003E   0x2082             MOVS     R0,#+130
   \   00000040   0x.... 0x....      BL       I2C_WriteDeviceRegister
    858            
    859            /* Write 0x01 to clear the FIFO memory content. */
    860            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x214B             MOVS     R1,#+75
   \   00000048   0x2082             MOVS     R0,#+130
   \   0000004A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    861            
    862            /* Write 0x00 to put the FIFO back into operation mode  */
    863            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x00);
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x214B             MOVS     R1,#+75
   \   00000052   0x2082             MOVS     R0,#+130
   \   00000054   0x.... 0x....      BL       I2C_WriteDeviceRegister
    864            
    865            /* set the data format for Z value: 7 fractional part and 1 whole part */
    866            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_FRACT_XYZ, 0x01);
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x2156             MOVS     R1,#+86
   \   0000005C   0x2082             MOVS     R0,#+130
   \   0000005E   0x.... 0x....      BL       I2C_WriteDeviceRegister
    867            
    868            /* set the driving capability of the device for TSC pins: 50mA */
    869            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_I_DRIVE, 0x01);
   \   00000062   0x2201             MOVS     R2,#+1
   \   00000064   0x2158             MOVS     R1,#+88
   \   00000066   0x2082             MOVS     R0,#+130
   \   00000068   0x.... 0x....      BL       I2C_WriteDeviceRegister
    870            
    871            /* Use no tracking index, touch-screen controller operation mode (XYZ) and 
    872               enable the TSC */
    873            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL, 0x03);
   \   0000006C   0x2203             MOVS     R2,#+3
   \   0000006E   0x2140             MOVS     R1,#+64
   \   00000070   0x2082             MOVS     R0,#+130
   \   00000072   0x.... 0x....      BL       I2C_WriteDeviceRegister
    874            
    875            /*  Clear all the status pending bits */
    876            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_STA, 0xFF); 
   \   00000076   0x22FF             MOVS     R2,#+255
   \   00000078   0x210B             MOVS     R1,#+11
   \   0000007A   0x2082             MOVS     R0,#+130
   \   0000007C   0x.... 0x....      BL       I2C_WriteDeviceRegister
    877            
    878            /* Initialize the TS structure to their default values */ 
    879            TS_State.TouchDetected = TS_State.X = TS_State.Y = TS_State.Z = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000086   0x80C8             STRH     R0,[R1, #+6]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000008C   0x8088             STRH     R0,[R1, #+4]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000092   0x8048             STRH     R0,[R1, #+2]
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000098   0x8008             STRH     R0,[R1, #+0]
    880            
    881            /* All configuration done */
    882            return IOE_OK;  
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xBD02             POP      {R1,PC}          ;; return
    883          }
    884          
    885          /**
    886            * @brief  Configures and enables the Temperature sensor module.
    887            * @param  None
    888            * @retval IOE_OK if all initializations are OK. Other value if error.
    889            */

   \                                 In section .text, align 2, keep-with-next
    890          uint8_t IOE_TempSens_Config(void)
    891          {
   \                     IOE_TempSens_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    892            __IO uint8_t tmp = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    893            
    894            /* Enable Temperature Sensor Fct */
    895            IOE_FnctCmd(IOE_2_ADDR, (IOE_TEMPSENS_FCT | IOE_ADC_FCT), ENABLE);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x2109             MOVS     R1,#+9
   \   0000000C   0x2088             MOVS     R0,#+136
   \   0000000E   0x.... 0x....      BL       IOE_FnctCmd
    896            
    897            /* Enable the TEMPSENS module */
    898            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x01);
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2160             MOVS     R1,#+96
   \   00000016   0x2088             MOVS     R0,#+136
   \   00000018   0x.... 0x....      BL       I2C_WriteDeviceRegister
    899            
    900            /* Aquire data enable */
    901            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x02);
   \   0000001C   0x2202             MOVS     R2,#+2
   \   0000001E   0x2160             MOVS     R1,#+96
   \   00000020   0x2088             MOVS     R0,#+136
   \   00000022   0x.... 0x....      BL       I2C_WriteDeviceRegister
    902            
    903            /* All configuration done */
    904            return IOE_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    905          }
    906          
    907          /**
    908            * @brief  Configures the selected pin to be in Alternate function or not
    909            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    910            *         or IOE_2_ADDR.
    911            * @param  IO_Pin: IO_Pin_x, Where x can be from 0 to 7.   
    912            * @param  NewState: State of the AF for the selected pin, could be 
    913            *         ENABLE or DISABLE.       
    914            * @retval IOE_OK: if all initializations are OK. Other value if error.
    915            */

   \                                 In section .text, align 2, keep-with-next
    916          uint8_t IOE_IOAFConfig(uint8_t DeviceAddr, uint8_t IO_Pin, FunctionalState NewState)
    917          {
   \                     IOE_IOAFConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    918            uint8_t tmp = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    919            
    920            /* Get the current state of the GPIO_AF register */
    921            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF);
   \   0000000A   0x2117             MOVS     R1,#+23
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       I2C_ReadDeviceRegister
    922            
    923            if (NewState != DISABLE)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD001             BEQ.N    ??IOE_IOAFConfig_0
    924            {
    925              /* Enable the selected pins alternate function */
    926              tmp |= (uint8_t)IO_Pin;
   \   0000001A   0x4328             ORRS     R0,R5,R0
   \   0000001C   0xE000             B.N      ??IOE_IOAFConfig_1
    927            }
    928            else
    929            {
    930              /* Disable the selected pins alternate function */   
    931              tmp &= ~(uint8_t)IO_Pin;   
   \                     ??IOE_IOAFConfig_0: (+1)
   \   0000001E   0x43A8             BICS     R0,R0,R5
    932            }
    933            
    934            /* Write back the new value in GPIO_AF register */  
    935            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF, tmp);  
   \                     ??IOE_IOAFConfig_1: (+1)
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x2117             MOVS     R1,#+23
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       I2C_WriteDeviceRegister
    936          
    937            /* If all OK return IOE_OK */
    938            return IOE_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    939          }
    940          
    941          /**
    942            * @brief  Configures the Edge for which a transition is detectable for the
    943            *         the selected pin.
    944            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    945            *         or IOE_2_ADDR.
    946            * @param  IO_Pin: IO_Pin_x, Where x can be from 0 to 7.   
    947            * @param  Edge: The edge which will be detected. This parameter can be one or a
    948            *         a combination of following values: EDGE_FALLING and EDGE_RISING .
    949            * @retval IOE_OK: if all initializations are OK. Other value if error.
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          uint8_t IOE_IOEdgeConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Edge)
    952          {
   \                     IOE_IOEdgeConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    953            uint8_t tmp1 = 0, tmp2 = 0;   
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    954            
    955            /* Get the registers values */
    956            tmp1 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE);
   \   00000010   0x2116             MOVS     R1,#+22
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   0000001A   0x0007             MOVS     R7,R0
    957            tmp2 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE);
   \   0000001C   0x2115             MOVS     R1,#+21
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       I2C_ReadDeviceRegister
   \   00000026   0x4680             MOV      R8,R0
    958          
    959            /* Disable the Falling Edge */
    960            tmp1 &= ~(uint8_t)IO_Pin;
   \   00000028   0x43AF             BICS     R7,R7,R5
    961            /* Disable the Falling Edge */
    962            tmp2 &= ~(uint8_t)IO_Pin;
   \   0000002A   0xEA38 0x0805      BICS     R8,R8,R5
    963          
    964            /* Enable the Falling edge if selected */
    965            if (Edge & EDGE_FALLING)
   \   0000002E   0x07F0             LSLS     R0,R6,#+31
   \   00000030   0xD500             BPL.N    ??IOE_IOEdgeConfig_0
    966            {
    967              tmp1 |= (uint8_t)IO_Pin;
   \   00000032   0x432F             ORRS     R7,R5,R7
    968            }
    969          
    970            /* Enable the Rising edge if selected */
    971            if (Edge & EDGE_RISING)
   \                     ??IOE_IOEdgeConfig_0: (+1)
   \   00000034   0x07B0             LSLS     R0,R6,#+30
   \   00000036   0xD501             BPL.N    ??IOE_IOEdgeConfig_1
    972            {
    973              tmp2 |= (uint8_t)IO_Pin;
   \   00000038   0xEA55 0x0808      ORRS     R8,R5,R8
    974            }
    975          
    976            /* Write back the registers values */
    977            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE, tmp1);
   \                     ??IOE_IOEdgeConfig_1: (+1)
   \   0000003C   0x003A             MOVS     R2,R7
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x2116             MOVS     R1,#+22
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       I2C_WriteDeviceRegister
    978            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE, tmp2);
   \   0000004A   0x4642             MOV      R2,R8
   \   0000004C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004E   0x2115             MOVS     R1,#+21
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x.... 0x....      BL       I2C_WriteDeviceRegister
    979            
    980            /* if OK return 0 */
    981            return IOE_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    982          }
    983          
    984          /**
    985            * @brief  Configures the Interrupt line active state and format (level/edge)
    986            * @param  Polarity: could be
    987            *   @arg  Polarity_Low: Interrupt line is active Low/Falling edge      
    988            *   @arg  Polarity_High: Interrupt line is active High/Rising edge      
    989            * @param  Type: Interrupt line activity type, could be one of the following values
    990            *   @arg  Type_Level: Interrupt line is active in level model         
    991            *   @arg  Type_Edge: Interrupt line is active in edge model           
    992            * @retval IOE_OK: if all initializations are OK. Other value if error.
    993            */

   \                                 In section .text, align 2, keep-with-next
    994          uint8_t IOE_ITOutConfig(uint8_t Polarity, uint8_t Type)
    995          {
   \                     IOE_ITOutConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    996            uint8_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    997            
    998            /*  Get the register IOE_REG_INT_CTRL value */ 
    999            tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL);
   \   00000008   0x2109             MOVS     R1,#+9
   \   0000000A   0x2082             MOVS     R0,#+130
   \   0000000C   0x.... 0x....      BL       I2C_ReadDeviceRegister
   1000            
   1001            /* Mask the polarity and type bits */
   1002            tmp &= ~(uint8_t)0x06;
   \   00000010   0xF010 0x00F9      ANDS     R0,R0,#0xF9
   1003              
   1004            /* Modify the Interrupt Output line configuration */
   1005            tmp |= (uint8_t)(Polarity | Type);
   \   00000014   0xEA55 0x0104      ORRS     R1,R5,R4
   \   00000018   0x4308             ORRS     R0,R1,R0
   1006            
   1007            /* Set the register */
   1008            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL, tmp);
   \   0000001A   0x0002             MOVS     R2,R0
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x2109             MOVS     R1,#+9
   \   00000020   0x2082             MOVS     R0,#+130
   \   00000022   0x.... 0x....      BL       I2C_WriteDeviceRegister
   1009            
   1010            
   1011            /*  Get the register IOE_REG_INT_CTRL value */ 
   1012            tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_INT_CTRL);
   \   00000026   0x2109             MOVS     R1,#+9
   \   00000028   0x2088             MOVS     R0,#+136
   \   0000002A   0x.... 0x....      BL       I2C_ReadDeviceRegister
   1013            /* Mask the polarity and type bits */
   1014            tmp &= ~(uint8_t)0x06;
   \   0000002E   0xF010 0x00F9      ANDS     R0,R0,#0xF9
   1015              
   1016            /* Modify the Interrupt Output line configuration */
   1017            tmp |= (uint8_t)(Polarity | Type);
   \   00000032   0xEA55 0x0104      ORRS     R1,R5,R4
   \   00000036   0x4308             ORRS     R0,R1,R0
   1018            
   1019            /* Set the register */
   1020            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_INT_CTRL, tmp);  
   \   00000038   0x0002             MOVS     R2,R0
   \   0000003A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003C   0x2109             MOVS     R1,#+9
   \   0000003E   0x2088             MOVS     R0,#+136
   \   00000040   0x.... 0x....      BL       I2C_WriteDeviceRegister
   1021            
   1022            /* If all OK return IOE_OK */
   1023            return IOE_OK;  
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1024          }
   1025          
   1026          /**
   1027            * @brief  Writes a value in a register of the device through I2C.
   1028            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
   1029            *         or IOE_2_ADDR. 
   1030            * @param  RegisterAddr: The target register address
   1031            * @param  RegisterValue: The target register value to be written 
   1032            * @retval IOE_OK: if all operations are OK. Other value if error.
   1033            */

   \                                 In section .text, align 2, keep-with-next
   1034          uint8_t I2C_DMA_WriteDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr, uint8_t RegisterValue)
   1035          {
   \                     I2C_DMA_WriteDeviceRegister: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000D             MOVS     R5,R1
   1036            uint32_t read_verif = 0;  
   \   00000008   0x2400             MOVS     R4,#+0
   1037            uint8_t IOE_BufferTX = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1038            
   1039            /* Get Value to be written */
   1040            IOE_BufferTX = RegisterValue;
   \   00000010   0xF88D 0x2000      STRB     R2,[SP, #+0]
   1041            
   1042            /* Configure DMA Peripheral */
   1043            IOE_DMA_Config(IOE_DMA_TX, (uint8_t*)(&IOE_BufferTX));
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       IOE_DMA_Config
   1044            
   1045            /* Enable the I2C peripheral */
   1046            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000022   0x.... 0x....      BL       I2C_GenerateSTART
   1047            
   1048            /* Test on SB Flag */
   1049            IOE_TimeOut = TIMEOUT_MAX;
   \   00000026   0xF44F 0x5040      MOV      R0,#+12288
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1050            while (I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB) == RESET) 
   \                     ??I2C_DMA_WriteDeviceRegister_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000038   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD10B             BNE.N    ??I2C_DMA_WriteDeviceRegister_1
   1051            {
   1052              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x1E41             SUBS     R1,R0,#+1
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable11
   \   0000004C   0x6011             STR      R1,[R2, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD1EE             BNE.N    ??I2C_DMA_WriteDeviceRegister_0
   \   00000052   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000056   0xE099             B.N      ??I2C_DMA_WriteDeviceRegister_2
   1053            }
   1054            
   1055            /* Transmit the slave address and enable writing operation */
   1056            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_DMA_WriteDeviceRegister_1: (+1)
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x0031             MOVS     R1,R6
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000062   0x.... 0x....      BL       I2C_Send7bitAddress
   1057            
   1058            /* Test on ADDR Flag */
   1059            IOE_TimeOut = TIMEOUT_MAX;
   \   00000066   0xF44F 0x5040      MOV      R0,#+12288
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   1060            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??I2C_DMA_WriteDeviceRegister_3: (+1)
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x70082
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000078   0x.... 0x....      BL       I2C_CheckEvent
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD10B             BNE.N    ??I2C_DMA_WriteDeviceRegister_4
   1061            {
   1062              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x1E41             SUBS     R1,R0,#+1
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable11
   \   0000008C   0x6011             STR      R1,[R2, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD1EE             BNE.N    ??I2C_DMA_WriteDeviceRegister_3
   \   00000092   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000096   0xE079             B.N      ??I2C_DMA_WriteDeviceRegister_2
   1063            }
   1064            
   1065            /* Transmit the first address for r/w operations */
   1066            I2C_SendData(IOE_I2C, RegisterAddr);
   \                     ??I2C_DMA_WriteDeviceRegister_4: (+1)
   \   00000098   0x0029             MOVS     R1,R5
   \   0000009A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000A0   0x.... 0x....      BL       I2C_SendData
   1067            
   1068            /* Test on TXE FLag (data dent) */
   1069            IOE_TimeOut = TIMEOUT_MAX;
   \   000000A4   0xF44F 0x5040      MOV      R0,#+12288
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000AC   0x6008             STR      R0,[R1, #+0]
   1070            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_DMA_WriteDeviceRegister_5: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000B6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD113             BNE.N    ??I2C_DMA_WriteDeviceRegister_6
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x10000004
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000C6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD10B             BNE.N    ??I2C_DMA_WriteDeviceRegister_6
   1071            {
   1072              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x1E41             SUBS     R1,R0,#+1
   \   000000D6   0x.... 0x....      LDR.W    R2,??DataTable11
   \   000000DA   0x6011             STR      R1,[R2, #+0]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD1E6             BNE.N    ??I2C_DMA_WriteDeviceRegister_5
   \   000000E0   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000E4   0xE052             B.N      ??I2C_DMA_WriteDeviceRegister_2
   1073            }
   1074            
   1075            /* Enable I2C DMA request */
   1076            I2C_DMACmd(IOE_I2C,ENABLE);
   \                     ??I2C_DMA_WriteDeviceRegister_6: (+1)
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000EC   0x.... 0x....      BL       I2C_DMACmd
   1077            
   1078            /* Enable DMA TX Channel */
   1079            DMA_Cmd(IOE_DMA_TX_STREAM, ENABLE);
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x400260a0
   \   000000F6   0x.... 0x....      BL       DMA_Cmd
   1080            
   1081            /* Wait until DMA Transfer Complete */
   1082            IOE_TimeOut = TIMEOUT_MAX;
   \   000000FA   0xF44F 0x5040      MOV      R0,#+12288
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000102   0x6008             STR      R0,[R1, #+0]
   1083            while (!DMA_GetFlagStatus(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG))
   \                     ??I2C_DMA_WriteDeviceRegister_7: (+1)
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x20200000
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x400260a0
   \   0000010C   0x.... 0x....      BL       DMA_GetFlagStatus
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD10B             BNE.N    ??I2C_DMA_WriteDeviceRegister_8
   1084            {
   1085              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x1E41             SUBS     R1,R0,#+1
   \   0000011C   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000120   0x6011             STR      R1,[R2, #+0]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1EE             BNE.N    ??I2C_DMA_WriteDeviceRegister_7
   \   00000126   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000012A   0xE02F             B.N      ??I2C_DMA_WriteDeviceRegister_2
   1086            }  
   1087            
   1088            /* Wait until BTF Flag is set before generating STOP */
   1089            IOE_TimeOut = 0xFF * TIMEOUT_MAX;
   \                     ??I2C_DMA_WriteDeviceRegister_8: (+1)
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x2fd000
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000134   0x6008             STR      R0,[R1, #+0]
   1090            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_DMA_WriteDeviceRegister_9: (+1)
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x10000004
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000013E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD10B             BNE.N    ??I2C_DMA_WriteDeviceRegister_10
   1091            {
   1092              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x1E41             SUBS     R1,R0,#+1
   \   0000014E   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000152   0x6011             STR      R1,[R2, #+0]
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD1EE             BNE.N    ??I2C_DMA_WriteDeviceRegister_9
   \   00000158   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000015C   0xE016             B.N      ??I2C_DMA_WriteDeviceRegister_2
   1093            }
   1094            
   1095            /* Send STOP Condition */
   1096            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_DMA_WriteDeviceRegister_10: (+1)
   \   0000015E   0x2101             MOVS     R1,#+1
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000164   0x.... 0x....      BL       I2C_GenerateSTOP
   1097            
   1098            /* Disable DMA TX Channel */
   1099            DMA_Cmd(IOE_DMA_TX_STREAM, DISABLE);
   \   00000168   0x2100             MOVS     R1,#+0
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x400260a0
   \   0000016E   0x.... 0x....      BL       DMA_Cmd
   1100            
   1101            /* Disable I2C DMA request */  
   1102            I2C_DMACmd(IOE_I2C,DISABLE);
   \   00000172   0x2100             MOVS     R1,#+0
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000178   0x.... 0x....      BL       I2C_DMACmd
   1103            
   1104            /* Clear DMA TX Transfer Complete Flag */
   1105            DMA_ClearFlag(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG);
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x20200000
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x400260a0
   \   00000184   0x.... 0x....      BL       DMA_ClearFlag
   1106            
   1107          #ifdef VERIFY_WRITTENDATA
   1108            /* Verify (if needed) that the loaded data is correct  */
   1109            
   1110            /* Read the just written register*/
   1111            read_verif = I2C_ReadDeviceRegister(DeviceAddr, RegisterAddr);
   1112            /* Load the register and verify its value  */
   1113            if (read_verif != RegisterValue)
   1114            {
   1115              /* Control data wrongly transferred */
   1116              read_verif = IOE_FAILURE;
   1117            }
   1118            else
   1119            {
   1120              /* Control data correctly transferred */
   1121              read_verif = 0;
   1122            }
   1123          #endif
   1124            
   1125            /* Return the verifying value: 0 (Passed) or 1 (Failed) */
   1126            return read_verif;
   \   00000188   0x0020             MOVS     R0,R4
   \   0000018A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??I2C_DMA_WriteDeviceRegister_2: (+1)
   \   0000018C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1127          }
   1128          
   1129          /**
   1130            * @brief  Reads a register of the device through I2C.
   1131            * @param  DeviceAddr: The address of the device, could be : IOE_1_ADDR
   1132            *         or IOE_2_ADDR. 
   1133            * @param  RegisterAddr: The target register address (between 00x and 0x24)
   1134            * @retval The value of the read register (0xAA if Timeout occurred)   
   1135            */

   \                                 In section .text, align 2, keep-with-next
   1136          uint8_t I2C_DMA_ReadDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr)
   1137          {
   \                     I2C_DMA_ReadDeviceRegister: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1138            uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1139            
   1140            /* Configure DMA Peripheral */
   1141            IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       IOE_DMA_Config
   1142            
   1143            /* Enable DMA NACK automatic generation */
   1144            I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000001A   0x.... 0x....      BL       I2C_DMALastTransferCmd
   1145            
   1146            /* Enable the I2C peripheral */
   1147            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000024   0x.... 0x....      BL       I2C_GenerateSTART
   1148            
   1149            /* Test on SB Flag */
   1150            IOE_TimeOut = TIMEOUT_MAX;
   \   00000028   0xF44F 0x5040      MOV      R0,#+12288
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1151            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_DMA_ReadDeviceRegister_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000003A   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10B             BNE.N    ??I2C_DMA_ReadDeviceRegister_1
   1152            {
   1153              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x1E41             SUBS     R1,R0,#+1
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable11
   \   0000004E   0x6011             STR      R1,[R2, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD1EE             BNE.N    ??I2C_DMA_ReadDeviceRegister_0
   \   00000054   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000058   0xE0BE             B.N      ??I2C_DMA_ReadDeviceRegister_2
   1154            }
   1155            
   1156            /* Send device address for write */
   1157            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_DMA_ReadDeviceRegister_1: (+1)
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x0021             MOVS     R1,R4
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000064   0x.... 0x....      BL       I2C_Send7bitAddress
   1158            
   1159            /* Test on ADDR Flag */
   1160            IOE_TimeOut = TIMEOUT_MAX;
   \   00000068   0xF44F 0x5040      MOV      R0,#+12288
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000070   0x6008             STR      R0,[R1, #+0]
   1161            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) 
   \                     ??I2C_DMA_ReadDeviceRegister_3: (+1)
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x70082
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000007A   0x.... 0x....      BL       I2C_CheckEvent
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD10B             BNE.N    ??I2C_DMA_ReadDeviceRegister_4
   1162            {
   1163              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x1E41             SUBS     R1,R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable11
   \   0000008E   0x6011             STR      R1,[R2, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD1EE             BNE.N    ??I2C_DMA_ReadDeviceRegister_3
   \   00000094   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000098   0xE09E             B.N      ??I2C_DMA_ReadDeviceRegister_2
   1164            }
   1165            
   1166            /* Send the device's internal address to write to */
   1167            I2C_SendData(IOE_I2C, RegisterAddr);  
   \                     ??I2C_DMA_ReadDeviceRegister_4: (+1)
   \   0000009A   0x0029             MOVS     R1,R5
   \   0000009C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000A2   0x.... 0x....      BL       I2C_SendData
   1168            
   1169            /* Test on TXE FLag (data dent) */
   1170            IOE_TimeOut = TIMEOUT_MAX;
   \   000000A6   0xF44F 0x5040      MOV      R0,#+12288
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1171            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_DMA_ReadDeviceRegister_5: (+1)
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000B8   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD113             BNE.N    ??I2C_DMA_ReadDeviceRegister_6
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x10000004
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000C8   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD10B             BNE.N    ??I2C_DMA_ReadDeviceRegister_6
   1172            {
   1173              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x1E41             SUBS     R1,R0,#+1
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable11
   \   000000DC   0x6011             STR      R1,[R2, #+0]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD1E6             BNE.N    ??I2C_DMA_ReadDeviceRegister_5
   \   000000E2   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000E6   0xE077             B.N      ??I2C_DMA_ReadDeviceRegister_2
   1174            }
   1175            
   1176            /* Send START condition a second time */  
   1177            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \                     ??I2C_DMA_ReadDeviceRegister_6: (+1)
   \   000000E8   0x2101             MOVS     R1,#+1
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000EE   0x.... 0x....      BL       I2C_GenerateSTART
   1178            
   1179            /* Test on SB Flag */
   1180            IOE_TimeOut = TIMEOUT_MAX;
   \   000000F2   0xF44F 0x5040      MOV      R0,#+12288
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000FA   0x6008             STR      R0,[R1, #+0]
   1181            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_DMA_ReadDeviceRegister_7: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000104   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD10B             BNE.N    ??I2C_DMA_ReadDeviceRegister_8
   1182            {
   1183              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x1E41             SUBS     R1,R0,#+1
   \   00000114   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000118   0x6011             STR      R1,[R2, #+0]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD1EE             BNE.N    ??I2C_DMA_ReadDeviceRegister_7
   \   0000011E   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000122   0xE059             B.N      ??I2C_DMA_ReadDeviceRegister_2
   1184            }
   1185            
   1186            /* Send IOExpander address for read */
   1187            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
   \                     ??I2C_DMA_ReadDeviceRegister_8: (+1)
   \   00000124   0x2201             MOVS     R2,#+1
   \   00000126   0x0021             MOVS     R1,R4
   \   00000128   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000012E   0x.... 0x....      BL       I2C_Send7bitAddress
   1188            
   1189            /* Test on ADDR Flag */
   1190            IOE_TimeOut = TIMEOUT_MAX;
   \   00000132   0xF44F 0x5040      MOV      R0,#+12288
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000013A   0x6008             STR      R0,[R1, #+0]
   1191            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
   \                     ??I2C_DMA_ReadDeviceRegister_9: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x30002
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000144   0x.... 0x....      BL       I2C_CheckEvent
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD10B             BNE.N    ??I2C_DMA_ReadDeviceRegister_10
   1192            {
   1193              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x1E41             SUBS     R1,R0,#+1
   \   00000154   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000158   0x6011             STR      R1,[R2, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD1EE             BNE.N    ??I2C_DMA_ReadDeviceRegister_9
   \   0000015E   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000162   0xE039             B.N      ??I2C_DMA_ReadDeviceRegister_2
   1194            }
   1195              
   1196            /* Enable I2C DMA request */
   1197            I2C_DMACmd(IOE_I2C,ENABLE);
   \                     ??I2C_DMA_ReadDeviceRegister_10: (+1)
   \   00000164   0x2101             MOVS     R1,#+1
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000016A   0x.... 0x....      BL       I2C_DMACmd
   1198            
   1199            /* Enable DMA RX Channel */
   1200            DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
   \   0000016E   0x2101             MOVS     R1,#+1
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   00000174   0x.... 0x....      BL       DMA_Cmd
   1201            
   1202            /* Wait until DMA Transfer Complete */
   1203            IOE_TimeOut = 2 * TIMEOUT_MAX;
   \   00000178   0xF44F 0x40C0      MOV      R0,#+24576
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000180   0x6008             STR      R0,[R1, #+0]
   1204            while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG))
   \                     ??I2C_DMA_ReadDeviceRegister_11: (+1)
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x10000020
   \   00000186   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   0000018A   0x.... 0x....      BL       DMA_GetFlagStatus
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD10B             BNE.N    ??I2C_DMA_ReadDeviceRegister_12
   1205            {
   1206              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0x1E41             SUBS     R1,R0,#+1
   \   0000019A   0x.... 0x....      LDR.W    R2,??DataTable11
   \   0000019E   0x6011             STR      R1,[R2, #+0]
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD1EE             BNE.N    ??I2C_DMA_ReadDeviceRegister_11
   \   000001A4   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000001A8   0xE016             B.N      ??I2C_DMA_ReadDeviceRegister_2
   1207            }        
   1208            
   1209            /* Send STOP Condition */
   1210            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_DMA_ReadDeviceRegister_12: (+1)
   \   000001AA   0x2101             MOVS     R1,#+1
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000001B0   0x.... 0x....      BL       I2C_GenerateSTOP
   1211            
   1212            /* Disable DMA RX Channel */
   1213            DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
   \   000001B4   0x2100             MOVS     R1,#+0
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   000001BA   0x.... 0x....      BL       DMA_Cmd
   1214            
   1215            /* Disable I2C DMA request */  
   1216            I2C_DMACmd(IOE_I2C,DISABLE);
   \   000001BE   0x2100             MOVS     R1,#+0
   \   000001C0   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000001C4   0x.... 0x....      BL       I2C_DMACmd
   1217            
   1218            /* Clear DMA RX Transfer Complete Flag */
   1219           DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x10000020
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   000001D0   0x.... 0x....      BL       DMA_ClearFlag
   1220            
   1221            /* return a pointer to the IOE_Buffer */
   1222            return (uint8_t)IOE_BufferRX[0];
   \   000001D4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \                     ??I2C_DMA_ReadDeviceRegister_2: (+1)
   \   000001D8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1223          }
   1224          
   1225          
   1226          /**
   1227            * @brief  Reads a buffer of 2 bytes from the device registers.
   1228            * @param  DeviceAddr: The address of the device, could be : IOE_1_ADDR
   1229            *         or IOE_2_ADDR. 
   1230            * @param  RegisterAddr: The target register address (between 00x and 0x24)
   1231            * @retval The data in the buffer containing the two returned bytes (in halfword).  
   1232            */

   \                                 In section .text, align 2, keep-with-next
   1233          uint16_t I2C_DMA_ReadDataBuffer(uint8_t DeviceAddr, uint32_t RegisterAddr)
   1234          { 
   \                     I2C_DMA_ReadDataBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1235            uint8_t tmp= 0;
   \   00000006   0x2000             MOVS     R0,#+0
   1236            uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1237            
   1238            /* Configure DMA Peripheral */
   1239            IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       IOE_DMA_Config
   1240            
   1241            /* Enable DMA NACK automatic generation */
   1242            I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000001C   0x.... 0x....      BL       I2C_DMALastTransferCmd
   1243            
   1244            /* Enable the I2C peripheral */
   1245            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000026   0x.... 0x....      BL       I2C_GenerateSTART
   1246            
   1247            /* Test on SB Flag */
   1248            IOE_TimeOut = TIMEOUT_MAX;
   \   0000002A   0xF44F 0x5040      MOV      R0,#+12288
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1249            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_DMA_ReadDataBuffer_0: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000003C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD10C             BNE.N    ??I2C_DMA_ReadDataBuffer_1
   1250            {
   1251              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1E41             SUBS     R1,R0,#+1
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000050   0x6011             STR      R1,[R2, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1EE             BNE.N    ??I2C_DMA_ReadDataBuffer_0
   \   00000056   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0xE0D0             B.N      ??I2C_DMA_ReadDataBuffer_2
   1252            }
   1253            
   1254            /* Send device address for write */
   1255            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_DMA_ReadDataBuffer_1: (+1)
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x0021             MOVS     R1,R4
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000068   0x.... 0x....      BL       I2C_Send7bitAddress
   1256            
   1257            /* Test on ADDR Flag */
   1258            IOE_TimeOut = TIMEOUT_MAX;
   \   0000006C   0xF44F 0x5040      MOV      R0,#+12288
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000074   0x6008             STR      R0,[R1, #+0]
   1259            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??I2C_DMA_ReadDataBuffer_3: (+1)
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x70082
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000007E   0x.... 0x....      BL       I2C_CheckEvent
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD10C             BNE.N    ??I2C_DMA_ReadDataBuffer_4
   1260            {
   1261              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1E41             SUBS     R1,R0,#+1
   \   0000008E   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000092   0x6011             STR      R1,[R2, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1EE             BNE.N    ??I2C_DMA_ReadDataBuffer_3
   \   00000098   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000009C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009E   0xE0AF             B.N      ??I2C_DMA_ReadDataBuffer_2
   1262            }
   1263            
   1264            /* Send the device's internal address to write to */
   1265            I2C_SendData(IOE_I2C, RegisterAddr);  
   \                     ??I2C_DMA_ReadDataBuffer_4: (+1)
   \   000000A0   0x0029             MOVS     R1,R5
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000A8   0x.... 0x....      BL       I2C_SendData
   1266            
   1267            /* Test on TXE FLag (data dent) */
   1268            IOE_TimeOut = TIMEOUT_MAX;
   \   000000AC   0xF44F 0x5040      MOV      R0,#+12288
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000B4   0x6008             STR      R0,[R1, #+0]
   1269            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_DMA_ReadDataBuffer_5: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000BE   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD114             BNE.N    ??I2C_DMA_ReadDataBuffer_6
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x10000004
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000CE   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD10C             BNE.N    ??I2C_DMA_ReadDataBuffer_6
   1270            {
   1271              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x1E41             SUBS     R1,R0,#+1
   \   000000DE   0x.... 0x....      LDR.W    R2,??DataTable11
   \   000000E2   0x6011             STR      R1,[R2, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD1E6             BNE.N    ??I2C_DMA_ReadDataBuffer_5
   \   000000E8   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000EC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EE   0xE087             B.N      ??I2C_DMA_ReadDataBuffer_2
   1272            }
   1273            
   1274            /* Send START condition a second time */  
   1275            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \                     ??I2C_DMA_ReadDataBuffer_6: (+1)
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000F6   0x.... 0x....      BL       I2C_GenerateSTART
   1276            
   1277            /* Test on SB Flag */
   1278            IOE_TimeOut = TIMEOUT_MAX;
   \   000000FA   0xF44F 0x5040      MOV      R0,#+12288
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000102   0x6008             STR      R0,[R1, #+0]
   1279            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_DMA_ReadDataBuffer_7: (+1)
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000010C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD10C             BNE.N    ??I2C_DMA_ReadDataBuffer_8
   1280            {
   1281              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x1E41             SUBS     R1,R0,#+1
   \   0000011C   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000120   0x6011             STR      R1,[R2, #+0]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1EE             BNE.N    ??I2C_DMA_ReadDataBuffer_7
   \   00000126   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000012A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000012C   0xE068             B.N      ??I2C_DMA_ReadDataBuffer_2
   1282            }
   1283            
   1284            /* Send IOExpander address for read */
   1285            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
   \                     ??I2C_DMA_ReadDataBuffer_8: (+1)
   \   0000012E   0x2201             MOVS     R2,#+1
   \   00000130   0x0021             MOVS     R1,R4
   \   00000132   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000138   0x.... 0x....      BL       I2C_Send7bitAddress
   1286            
   1287            /* Test on ADDR Flag */
   1288            IOE_TimeOut = TIMEOUT_MAX;
   \   0000013C   0xF44F 0x5040      MOV      R0,#+12288
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000144   0x6008             STR      R0,[R1, #+0]
   1289            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
   \                     ??I2C_DMA_ReadDataBuffer_9: (+1)
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0x30002
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000014E   0x.... 0x....      BL       I2C_CheckEvent
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD10C             BNE.N    ??I2C_DMA_ReadDataBuffer_10
   1290            {
   1291              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0x1E41             SUBS     R1,R0,#+1
   \   0000015E   0x.... 0x....      LDR.W    R2,??DataTable11
   \   00000162   0x6011             STR      R1,[R2, #+0]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD1EE             BNE.N    ??I2C_DMA_ReadDataBuffer_9
   \   00000168   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000016C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000016E   0xE047             B.N      ??I2C_DMA_ReadDataBuffer_2
   1292            }
   1293            
   1294            /* Enable I2C DMA request */
   1295            I2C_DMACmd(IOE_I2C,ENABLE);
   \                     ??I2C_DMA_ReadDataBuffer_10: (+1)
   \   00000170   0x2101             MOVS     R1,#+1
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000176   0x.... 0x....      BL       I2C_DMACmd
   1296            
   1297            /* Enable DMA RX Channel */
   1298            DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
   \   0000017A   0x2101             MOVS     R1,#+1
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   00000180   0x.... 0x....      BL       DMA_Cmd
   1299            
   1300            /* Wait until DMA Transfer Complete */
   1301            IOE_TimeOut = 2 * TIMEOUT_MAX;
   \   00000184   0xF44F 0x40C0      MOV      R0,#+24576
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000018C   0x6008             STR      R0,[R1, #+0]
   1302            while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM, IOE_DMA_RX_TCFLAG))
   \                     ??I2C_DMA_ReadDataBuffer_11: (+1)
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x10000020
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   00000196   0x.... 0x....      BL       DMA_GetFlagStatus
   \   0000019A   0x2800             CMP      R0,#+0
   \   0000019C   0xD10C             BNE.N    ??I2C_DMA_ReadDataBuffer_12
   1303            {
   1304              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000001A2   0x6800             LDR      R0,[R0, #+0]
   \   000001A4   0x1E41             SUBS     R1,R0,#+1
   \   000001A6   0x.... 0x....      LDR.W    R2,??DataTable11
   \   000001AA   0x6011             STR      R1,[R2, #+0]
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD1EE             BNE.N    ??I2C_DMA_ReadDataBuffer_11
   \   000001B0   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000001B4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001B6   0xE023             B.N      ??I2C_DMA_ReadDataBuffer_2
   1305            }        
   1306            
   1307            /* Send STOP Condition */
   1308            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_DMA_ReadDataBuffer_12: (+1)
   \   000001B8   0x2101             MOVS     R1,#+1
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000001BE   0x.... 0x....      BL       I2C_GenerateSTOP
   1309            
   1310            /* Disable DMA RX Channel */
   1311            DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
   \   000001C2   0x2100             MOVS     R1,#+0
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   000001C8   0x.... 0x....      BL       DMA_Cmd
   1312            
   1313            /* Disable I2C DMA request */  
   1314            I2C_DMACmd(IOE_I2C,DISABLE);
   \   000001CC   0x2100             MOVS     R1,#+0
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000001D2   0x.... 0x....      BL       I2C_DMACmd
   1315            
   1316            /* Clear DMA RX Transfer Complete Flag */
   1317            DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0x10000020
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   000001DE   0x.... 0x....      BL       DMA_ClearFlag
   1318            
   1319            /* Reorganize received data */  
   1320            tmp = IOE_BufferRX[0];
   \   000001E2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   1321            IOE_BufferRX[0] = IOE_BufferRX[1];
   \   000001E6   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000001EA   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1322            IOE_BufferRX[1] = tmp;
   \   000001EE   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1323            
   1324            /* return the data */
   1325            return ((uint16_t) IOE_BufferRX[0] | ((uint16_t)IOE_BufferRX[1]<< 8));
   \   000001F2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001F6   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000001FA   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000001FE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??I2C_DMA_ReadDataBuffer_2: (+1)
   \   00000200   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1326          }
   1327          
   1328          /**
   1329            * @brief  Return Touch Screen X position value
   1330            * @param  None
   1331            * @retval X position.
   1332            */

   \                                 In section .text, align 2, keep-with-next
   1333          static uint16_t IOE_TS_Read_X(void)
   1334          {
   \                     IOE_TS_Read_X: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1335            int32_t x, xr;
   1336           
   1337            x = I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_Y);
   \   00000002   0x214F             MOVS     R1,#+79
   \   00000004   0x2082             MOVS     R0,#+130
   \   00000006   0x.... 0x....      BL       I2C_ReadDataBuffer
   1338            
   1339            /* first correction */
   1340            xr =  (x * 320) >> 12;
   \   0000000A   0xF44F 0x71A0      MOV      R1,#+320
   \   0000000E   0x4348             MULS     R0,R1,R0
   \   00000010   0x1300             ASRS     R0,R0,#+12
   1341            /* second correction */
   1342            xr = ((xr * 32)/29) - 17;
   \   00000012   0x0140             LSLS     R0,R0,#+5
   \   00000014   0x211D             MOVS     R1,#+29
   \   00000016   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001A   0x3811             SUBS     R0,R0,#+17
   1343            
   1344            if(xr <= 0)
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xDA00             BGE.N    ??IOE_TS_Read_X_0
   1345              xr = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   1346            
   1347            return (uint16_t)(xr); 
   \                     ??IOE_TS_Read_X_0: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
   1348          }
   1349          
   1350          /**
   1351            * @brief  Return Touch Screen Y position value
   1352            * @param  None
   1353            * @retval Y position.
   1354            */

   \                                 In section .text, align 2, keep-with-next
   1355          static uint16_t IOE_TS_Read_Y(void)
   1356          {
   \                     IOE_TS_Read_Y: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1357            int32_t y, yr;
   1358            y= I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_X);
   \   00000002   0x214D             MOVS     R1,#+77
   \   00000004   0x2082             MOVS     R0,#+130
   \   00000006   0x.... 0x....      BL       I2C_ReadDataBuffer
   1359            
   1360            yr= (y * 240) >> 12;
   \   0000000A   0x21F0             MOVS     R1,#+240
   \   0000000C   0x4348             MULS     R0,R1,R0
   \   0000000E   0x1300             ASRS     R0,R0,#+12
   1361            yr = ((yr * 240) / 217) - 12;
   \   00000010   0x21F0             MOVS     R1,#+240
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014   0x21D9             MOVS     R1,#+217
   \   00000016   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001A   0x380C             SUBS     R0,R0,#+12
   1362            
   1363            if(yr <= 0)
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xDA00             BGE.N    ??IOE_TS_Read_Y_0
   1364              yr = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   1365            
   1366            return (uint16_t)(yr); 
   \                     ??IOE_TS_Read_Y_0: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
   1367          }
   1368          
   1369          /**
   1370            * @brief  Return Touch Screen Z position value
   1371            * @param  None
   1372            * @retval Z position.
   1373            */

   \                                 In section .text, align 2, keep-with-next
   1374          static uint16_t IOE_TS_Read_Z(void)
   1375          {
   \                     IOE_TS_Read_Z: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1376            uint32_t z;
   1377            z = I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_Z);
   \   00000002   0x2151             MOVS     R1,#+81
   \   00000004   0x2082             MOVS     R0,#+130
   \   00000006   0x.... 0x....      BL       I2C_ReadDataBuffer
   1378            
   1379            
   1380            if(z <= 0)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD100             BNE.N    ??IOE_TS_Read_Z_0
   1381              z = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   1382            
   1383            return (uint16_t)(z); 
   \                     ??IOE_TS_Read_Z_0: (+1)
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
   1384          }
   1385          
   1386          /**
   1387            * @brief  Initializes the GPIO pins used by the IO expander.
   1388            * @param  None
   1389            * @retval None
   1390            */

   \                                 In section .text, align 2, keep-with-next
   1391          static void IOE_GPIO_Config(void)
   1392          {
   \                     IOE_GPIO_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1393            GPIO_InitTypeDef GPIO_InitStructure;
   1394            
   1395            /* Enable IOE_I2C and IOE_I2C_GPIO_PORT & Alternate Function clocks */
   1396            RCC_APB1PeriphClockCmd(IOE_I2C_CLK, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000000A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   1397            RCC_AHB1PeriphClockCmd(IOE_I2C_SCL_GPIO_CLK | IOE_I2C_SDA_GPIO_CLK |
   1398                                   IOE_IT_GPIO_CLK, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF44F 0x7081      MOV      R0,#+258
   \   00000014   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   1399            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   1400            
   1401            /* Reset IOE_I2C IP */
   1402            RCC_APB1PeriphResetCmd(IOE_I2C_CLK, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000028   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   1403            /* Release reset signal of IOE_I2C IP */
   1404            RCC_APB1PeriphResetCmd(IOE_I2C_CLK, DISABLE);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000032   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   1405          
   1406            /* Connect PXx to I2C_SCL*/
   1407            GPIO_PinAFConfig(IOE_I2C_SCL_GPIO_PORT, IOE_I2C_SCL_SOURCE, IOE_I2C_SCL_AF);
   \   00000036   0x2204             MOVS     R2,#+4
   \   00000038   0x2106             MOVS     R1,#+6
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40020400
   \   0000003E   0x.... 0x....      BL       GPIO_PinAFConfig
   1408            /* Connect PXx to I2C_SDA*/
   1409            GPIO_PinAFConfig(IOE_I2C_SDA_GPIO_PORT, IOE_I2C_SDA_SOURCE, IOE_I2C_SDA_AF); 
   \   00000042   0x2204             MOVS     R2,#+4
   \   00000044   0x2109             MOVS     R1,#+9
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40020400
   \   0000004A   0x.... 0x....      BL       GPIO_PinAFConfig
   1410              
   1411            /* IOE_I2C SCL and SDA pins configuration */
   1412            GPIO_InitStructure.GPIO_Pin = IOE_I2C_SCL_PIN;
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x9000             STR      R0,[SP, #+0]
   1413            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1414            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1415            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1416            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1417            GPIO_Init(IOE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   0000006A   0x4669             MOV      R1,SP
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40020400
   \   00000070   0x.... 0x....      BL       GPIO_Init
   1418          
   1419            GPIO_InitStructure.GPIO_Pin = IOE_I2C_SDA_PIN;
   \   00000074   0xF44F 0x7000      MOV      R0,#+512
   \   00000078   0x9000             STR      R0,[SP, #+0]
   1420            GPIO_Init(IOE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   0000007A   0x4669             MOV      R1,SP
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x40020400
   \   00000080   0x.... 0x....      BL       GPIO_Init
   1421          
   1422            /* Set EXTI pin as Input PullUp - IO_Expander_INT */
   1423            GPIO_InitStructure.GPIO_Pin = IOE_IT_PIN;
   \   00000084   0x2004             MOVS     R0,#+4
   \   00000086   0x9000             STR      R0,[SP, #+0]
   1424            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1425            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1426            GPIO_Init(IOE_IT_GPIO_PORT, &GPIO_InitStructure);
   \   00000094   0x4669             MOV      R1,SP
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable15_8  ;; 0x40022000
   \   0000009A   0x.... 0x....      BL       GPIO_Init
   1427          
   1428            /* Connect Button EXTI Line to Button GPIO Pin */
   1429            SYSCFG_EXTILineConfig(IOE_IT_EXTI_PORT_SOURCE, IOE_IT_EXTI_PIN_SOURCE);  
   \   0000009E   0x2102             MOVS     R1,#+2
   \   000000A0   0x2008             MOVS     R0,#+8
   \   000000A2   0x.... 0x....      BL       SYSCFG_EXTILineConfig
   1430          }
   \   000000A6   0xBD07             POP      {R0-R2,PC}       ;; return
   1431          
   1432          /**
   1433            * @brief  Configure the I2C Peripheral used to communicate with IO_Expanders.
   1434            * @param  None
   1435            * @retval None
   1436            */

   \                                 In section .text, align 2, keep-with-next
   1437          static void IOE_I2C_Config(void)
   1438          {
   \                     IOE_I2C_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1439            I2C_InitTypeDef I2C_InitStructure;
   1440            
   1441            /* IOE_I2C configuration */
   1442            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1443            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000A   0xF64B 0x70FF      MOVW     R0,#+49151
   \   0000000E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1444            I2C_InitStructure.I2C_OwnAddress1 = 0x00;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1445            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   00000018   0xF44F 0x6080      MOV      R0,#+1024
   \   0000001C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1446            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000020   0xF44F 0x4080      MOV      R0,#+16384
   \   00000024   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   1447            I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15_9  ;; 0x186a0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   1448            
   1449            /* Initialize the I2C peripheral */
   1450            I2C_Init(IOE_I2C, &I2C_InitStructure);
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000034   0x.... 0x....      BL       I2C_Init
   1451            
   1452            /* Enable the I2C peripheral */
   1453            I2C_Cmd(IOE_I2C, ENABLE);
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000003E   0x.... 0x....      BL       I2C_Cmd
   1454          }
   \   00000042   0xB005             ADD      SP,SP,#+20
   \   00000044   0xBD00             POP      {PC}             ;; return
   1455          
   1456          /**
   1457            * @brief  Configure the DMA Peripheral used to handle communication via I2C.
   1458            * @param  None
   1459            * @retval None
   1460            */
   1461          

   \                                 In section .text, align 2, keep-with-next
   1462          static void IOE_DMA_Config(IOE_DMADirection_TypeDef Direction, uint8_t* buffer)
   1463          {
   \                     IOE_DMA_Config: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1464            DMA_InitTypeDef DMA_InitStructure;
   1465            
   1466            RCC_AHB1PeriphClockCmd(IOE_DMA_CLK, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000000E   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   1467            
   1468            /* Initialize the DMA_Channel member */
   1469            DMA_InitStructure.DMA_Channel = IOE_DMA_CHANNEL;
   \   00000012   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000016   0x9000             STR      R0,[SP, #+0]
   1470            
   1471            /* Initialize the DMA_PeripheralBaseAddr member */
   1472            DMA_InitStructure.DMA_PeripheralBaseAddr = IOE_I2C_DR;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15_10  ;; 0x40005410
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   1473            
   1474            /* Initialize the DMA_Memory0BaseAddr member */
   1475            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
   \   0000001E   0x9502             STR      R5,[SP, #+8]
   1476            
   1477            /* Initialize the DMA_PeripheralInc member */
   1478            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9005             STR      R0,[SP, #+20]
   1479            
   1480            /* Initialize the DMA_MemoryInc member */
   1481            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000024   0xF44F 0x6080      MOV      R0,#+1024
   \   00000028   0x9006             STR      R0,[SP, #+24]
   1482            
   1483            /* Initialize the DMA_PeripheralDataSize member */
   1484            DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9007             STR      R0,[SP, #+28]
   1485            
   1486            /* Initialize the DMA_MemoryDataSize member */
   1487            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9008             STR      R0,[SP, #+32]
   1488            
   1489            /* Initialize the DMA_Mode member */
   1490            DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x9009             STR      R0,[SP, #+36]
   1491            
   1492            /* Initialize the DMA_Priority member */
   1493            DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x900A             STR      R0,[SP, #+40]
   1494            
   1495            /* Initialize the DMA_FIFOMode member */
   1496            DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x900B             STR      R0,[SP, #+44]
   1497            
   1498            /* Initialize the DMA_FIFOThreshold member */
   1499            DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x900C             STR      R0,[SP, #+48]
   1500            
   1501            /* Initialize the DMA_MemoryBurst member */
   1502            DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x900D             STR      R0,[SP, #+52]
   1503            
   1504            /* Initialize the DMA_PeripheralBurst member */
   1505            DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x900E             STR      R0,[SP, #+56]
   1506            
   1507            /* If using DMA for Reception */
   1508            if (Direction == IOE_DMA_RX)
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xD10D             BNE.N    ??IOE_DMA_Config_0
   1509            {    
   1510              /* Initialize the DMA_DIR member */
   1511              DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x9003             STR      R0,[SP, #+12]
   1512              
   1513              /* Initialize the DMA_BufferSize member */
   1514              DMA_InitStructure.DMA_BufferSize = 2;
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x9004             STR      R0,[SP, #+16]
   1515              
   1516              DMA_DeInit(IOE_DMA_RX_STREAM);
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   0000005C   0x.... 0x....      BL       DMA_DeInit
   1517              
   1518              DMA_Init(IOE_DMA_RX_STREAM, &DMA_InitStructure);
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40026010
   \   00000066   0x.... 0x....      BL       DMA_Init
   \   0000006A   0xE00F             B.N      ??IOE_DMA_Config_1
   1519            }
   1520            /* If using DMA for Transmission */
   1521            else if (Direction == IOE_DMA_TX)
   \                     ??IOE_DMA_Config_0: (+1)
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD10C             BNE.N    ??IOE_DMA_Config_1
   1522            { 
   1523              /* Initialize the DMA_DIR member */
   1524              DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
   \   00000072   0x2040             MOVS     R0,#+64
   \   00000074   0x9003             STR      R0,[SP, #+12]
   1525              
   1526              /* Initialize the DMA_BufferSize member */
   1527              DMA_InitStructure.DMA_BufferSize = 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x9004             STR      R0,[SP, #+16]
   1528              
   1529              DMA_DeInit(IOE_DMA_TX_STREAM);
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x400260a0
   \   0000007E   0x.... 0x....      BL       DMA_DeInit
   1530              
   1531              DMA_Init(IOE_DMA_TX_STREAM, &DMA_InitStructure);
   \   00000082   0x4669             MOV      R1,SP
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x400260a0
   \   00000088   0x.... 0x....      BL       DMA_Init
   1532            }
   1533          }
   \                     ??IOE_DMA_Config_1: (+1)
   \   0000008C   0xB00F             ADD      SP,SP,#+60
   \   0000008E   0xBD30             POP      {R4,R5,PC}       ;; return
   1534          
   1535          /**
   1536            * @brief  Writes a value in a register of the device through I2C.
   1537            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
   1538            *         or IOE_2_ADDR. 
   1539            * @param  RegisterAddr: The target register address
   1540            * @param  RegisterValue: The target register value to be written 
   1541            * @retval IOE_OK: if all operations are OK. Other value if error.
   1542            */

   \                                 In section .text, align 2, keep-with-next
   1543          uint8_t I2C_WriteDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr, uint8_t RegisterValue)
   1544          {
   \                     I2C_WriteDeviceRegister: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   1545            uint32_t read_verif = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   1546          
   1547            /* Begin the configuration sequence */
   1548            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000010   0x.... 0x....      BL       I2C_GenerateSTART
   1549          
   1550            /* Test on EV5 and clear it */
   1551            IOE_TimeOut = TIMEOUT_MAX;
   \   00000014   0xF44F 0x5040      MOV      R0,#+12288
   \   00000018   0x....             LDR.N    R1,??DataTable11
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1552            while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB))
   \                     ??I2C_WriteDeviceRegister_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000024   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD109             BNE.N    ??I2C_WriteDeviceRegister_1
   1553            {
   1554              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000002C   0x....             LDR.N    R0,??DataTable11
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x1E41             SUBS     R1,R0,#+1
   \   00000032   0x....             LDR.N    R2,??DataTable11
   \   00000034   0x6011             STR      R1,[R2, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F0             BNE.N    ??I2C_WriteDeviceRegister_0
   \   0000003A   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000003E   0xE07C             B.N      ??I2C_WriteDeviceRegister_2
   1555            }
   1556          
   1557            /* Transmit the slave address and enable writing operation */
   1558            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_WriteDeviceRegister_1: (+1)
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x0039             MOVS     R1,R7
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000004A   0x.... 0x....      BL       I2C_Send7bitAddress
   1559            
   1560            /* Test on EV6 and clear it */
   1561            IOE_TimeOut = TIMEOUT_MAX;  
   \   0000004E   0xF44F 0x5040      MOV      R0,#+12288
   \   00000052   0x....             LDR.N    R1,??DataTable11
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1562            while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR))
   \                     ??I2C_WriteDeviceRegister_3: (+1)
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x10000002
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000005E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD109             BNE.N    ??I2C_WriteDeviceRegister_4
   1563            {
   1564              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000066   0x....             LDR.N    R0,??DataTable11
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x1E41             SUBS     R1,R0,#+1
   \   0000006C   0x....             LDR.N    R2,??DataTable11
   \   0000006E   0x6011             STR      R1,[R2, #+0]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1F0             BNE.N    ??I2C_WriteDeviceRegister_3
   \   00000074   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000078   0xE05F             B.N      ??I2C_WriteDeviceRegister_2
   1565            }
   1566            
   1567            /* Read status register 2 to clear ADDR flag */
   1568            I2C1->SR2;
   \                     ??I2C_WriteDeviceRegister_4: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable15_12  ;; 0x40005418
   \   0000007E   0x8800             LDRH     R0,[R0, #+0]
   1569            
   1570            /* Test on EV8_1 and clear it */
   1571            IOE_TimeOut = TIMEOUT_MAX;
   \   00000080   0xF44F 0x5040      MOV      R0,#+12288
   \   00000084   0x....             LDR.N    R1,??DataTable11
   \   00000086   0x6008             STR      R0,[R1, #+0]
   1572            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
   \                     ??I2C_WriteDeviceRegister_5: (+1)
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000090   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD109             BNE.N    ??I2C_WriteDeviceRegister_6
   1573            {
   1574              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000098   0x....             LDR.N    R0,??DataTable11
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x1E41             SUBS     R1,R0,#+1
   \   0000009E   0x....             LDR.N    R2,??DataTable11
   \   000000A0   0x6011             STR      R1,[R2, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD1F0             BNE.N    ??I2C_WriteDeviceRegister_5
   \   000000A6   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000AA   0xE046             B.N      ??I2C_WriteDeviceRegister_2
   1575            }
   1576            
   1577            /* Transmit the first address for r/w operations */
   1578            I2C_SendData(IOE_I2C, RegisterAddr);
   \                     ??I2C_WriteDeviceRegister_6: (+1)
   \   000000AC   0x0031             MOVS     R1,R6
   \   000000AE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000B4   0x.... 0x....      BL       I2C_SendData
   1579            
   1580            /* Test on EV8 and clear it */
   1581            IOE_TimeOut = TIMEOUT_MAX;
   \   000000B8   0xF44F 0x5040      MOV      R0,#+12288
   \   000000BC   0x....             LDR.N    R1,??DataTable11
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   1582            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
   \                     ??I2C_WriteDeviceRegister_7: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000C8   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD109             BNE.N    ??I2C_WriteDeviceRegister_8
   1583            {
   1584              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000D0   0x....             LDR.N    R0,??DataTable11
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x1E41             SUBS     R1,R0,#+1
   \   000000D6   0x....             LDR.N    R2,??DataTable11
   \   000000D8   0x6011             STR      R1,[R2, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD1F0             BNE.N    ??I2C_WriteDeviceRegister_7
   \   000000DE   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000E2   0xE02A             B.N      ??I2C_WriteDeviceRegister_2
   1585            }
   1586            
   1587            /* Prepare the register value to be sent */
   1588            I2C_SendData(IOE_I2C, RegisterValue);
   \                     ??I2C_WriteDeviceRegister_8: (+1)
   \   000000E4   0x0021             MOVS     R1,R4
   \   000000E6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   000000EC   0x.... 0x....      BL       I2C_SendData
   1589            
   1590            /* Test on EV8_2 and clear it */
   1591            IOE_TimeOut = TIMEOUT_MAX;
   \   000000F0   0xF44F 0x5040      MOV      R0,#+12288
   \   000000F4   0x....             LDR.N    R1,??DataTable11
   \   000000F6   0x6008             STR      R0,[R1, #+0]
   1592            while ((!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF)))
   \                     ??I2C_WriteDeviceRegister_9: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000100   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD007             BEQ.N    ??I2C_WriteDeviceRegister_10
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x10000004
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000110   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD109             BNE.N    ??I2C_WriteDeviceRegister_11
   1593            {
   1594              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \                     ??I2C_WriteDeviceRegister_10: (+1)
   \   00000118   0x....             LDR.N    R0,??DataTable11
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0x1E41             SUBS     R1,R0,#+1
   \   0000011E   0x....             LDR.N    R2,??DataTable11
   \   00000120   0x6011             STR      R1,[R2, #+0]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1E8             BNE.N    ??I2C_WriteDeviceRegister_9
   \   00000126   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000012A   0xE006             B.N      ??I2C_WriteDeviceRegister_2
   1595            }
   1596            
   1597            /* End the configuration sequence */
   1598            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_WriteDeviceRegister_11: (+1)
   \   0000012C   0x2101             MOVS     R1,#+1
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000132   0x.... 0x....      BL       I2C_GenerateSTOP
   1599            
   1600          #ifdef VERIFY_WRITTENDATA
   1601            /* Verify (if needed) that the loaded data is correct  */
   1602            
   1603            /* Read the just written register*/
   1604            read_verif = IOE_I2C_ReadDeviceRegister(DeviceAddr, RegisterAddr);
   1605          
   1606            /* Load the register and verify its value  */
   1607            if (read_verif != RegisterValue)
   1608            {
   1609              /* Control data wrongly transferred */
   1610              read_verif = IOE_FAILURE;
   1611            }
   1612            else
   1613            {
   1614              /* Control data correctly transferred */
   1615              read_verif = 0;
   1616            }
   1617          #endif
   1618            
   1619            /* Return the verifying value: 0 (Passed) or 1 (Failed) */
   1620            return read_verif;
   \   00000136   0x0028             MOVS     R0,R5
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??I2C_WriteDeviceRegister_2: (+1)
   \   0000013A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1621            
   1622          }
   1623          
   1624          
   1625          /**
   1626            * @brief  Reads a register of the device through I2C without DMA.
   1627            * @param  DeviceAddr: The address of the device, could be : IOE_1_ADDR
   1628            *         or IOE_2_ADDR. 
   1629            * @param  RegisterAddr: The target register address (between 00x and 0x24)
   1630            * @retval The value of the read register (0xAA if Timeout occurred)   
   1631            */ 

   \                                 In section .text, align 2, keep-with-next
   1632          uint8_t I2C_ReadDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr)
   1633          {
   \                     I2C_ReadDeviceRegister: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1634            uint8_t tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1635            
   1636            /* Enable the I2C peripheral */
   1637            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   0000000E   0x.... 0x....      BL       I2C_GenerateSTART
   1638            
   1639              /* Test on EV5 and clear it */
   1640            IOE_TimeOut = TIMEOUT_MAX;
   \   00000012   0xF44F 0x5040      MOV      R0,#+12288
   \   00000016   0x....             LDR.N    R1,??DataTable11
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1641            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
   \                     ??I2C_ReadDeviceRegister_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x10000001
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000022   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD109             BNE.N    ??I2C_ReadDeviceRegister_1
   1642            {
   1643              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000002A   0x....             LDR.N    R0,??DataTable11
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1E41             SUBS     R1,R0,#+1
   \   00000030   0x....             LDR.N    R2,??DataTable11
   \   00000032   0x6011             STR      R1,[R2, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1F0             BNE.N    ??I2C_ReadDeviceRegister_0
   \   00000038   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000003C   0xE0B2             B.N      ??I2C_ReadDeviceRegister_2
   1644            }
   1645            /* Disable Acknowledgement */
   1646            I2C_AcknowledgeConfig(IOE_I2C, DISABLE);
   \                     ??I2C_ReadDeviceRegister_1: (+1)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000044   0x.... 0x....      BL       I2C_AcknowledgeConfig
   1647            
   1648            /* Transmit the slave address and enable writing operation */
   1649            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000052   0x.... 0x....      BL       I2C_Send7bitAddress
   1650            
   1651            /* Test on EV6 and clear it */
   1652            IOE_TimeOut = TIMEOUT_MAX;  
   \   00000056   0xF44F 0x5040      MOV      R0,#+12288
   \   0000005A   0x....             LDR.N    R1,??DataTable11
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1653            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
   \                     ??I2C_ReadDeviceRegister_3: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x10000002
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000066   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD109             BNE.N    ??I2C_ReadDeviceRegister_4
   1654            {
   1655              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000006E   0x....             LDR.N    R0,??DataTable11
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x1E41             SUBS     R1,R0,#+1
   \   00000074   0x....             LDR.N    R2,??DataTable11
   \   00000076   0x6011             STR      R1,[R2, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD1F0             BNE.N    ??I2C_ReadDeviceRegister_3
   \   0000007C   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000080   0xE090             B.N      ??I2C_ReadDeviceRegister_2
   1656            }
   1657            
   1658            /* Read status register 2 to clear ADDR flag */
   1659            IOE_I2C->SR2;
   \                     ??I2C_ReadDeviceRegister_4: (+1)
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable15_12  ;; 0x40005418
   \   00000086   0x8800             LDRH     R0,[R0, #+0]
   1660            
   1661            /* Test on EV8 and clear it */
   1662            IOE_TimeOut = TIMEOUT_MAX;
   \   00000088   0xF44F 0x5040      MOV      R0,#+12288
   \   0000008C   0x....             LDR.N    R1,??DataTable11
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   1663            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
   \                     ??I2C_ReadDeviceRegister_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40005400
   \   00000098   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD109             BNE.N    ??I2C_ReadDeviceRegister_6
   1664            {
   1665              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000A0   0x....             LDR.N    R0,??DataTable11
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x1E41             SUBS     R1,R0,#+1
   \   000000A6   0x....             LDR.N    R2,??DataTable11
   \   000000A8   0x6011             STR      R1,[R2, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD1F0             BNE.N    ??I2C_ReadDeviceRegister_5
   \   000000AE   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000B2   0xE077             B.N      ??I2C_ReadDeviceRegister_2
   1666            }
   1667            
   1668            /* Transmit the first address for r/w operations */
   1669            I2C_SendData(IOE_I2C, RegisterAddr);
   \                     ??I2C_ReadDeviceRegister_6: (+1)
   \   000000B4   0x0029             MOVS     R1,R5
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000BA   0x.... 0x....      BL       I2C_SendData
   1670            
   1671            /* Test on EV8 and clear it */
   1672            IOE_TimeOut = TIMEOUT_MAX;
   \   000000BE   0xF44F 0x5040      MOV      R0,#+12288
   \   000000C2   0x....             LDR.N    R1,??DataTable11
   \   000000C4   0x6008             STR      R0,[R1, #+0]
   1673            while ((!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF)))
   \                     ??I2C_ReadDeviceRegister_7: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10000080
   \   000000CA   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000CC   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD006             BEQ.N    ??I2C_ReadDeviceRegister_8
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x10000004
   \   000000D8   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000DA   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD109             BNE.N    ??I2C_ReadDeviceRegister_9
   1674            {
   1675              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \                     ??I2C_ReadDeviceRegister_8: (+1)
   \   000000E2   0x....             LDR.N    R0,??DataTable11
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x1E41             SUBS     R1,R0,#+1
   \   000000E8   0x....             LDR.N    R2,??DataTable11
   \   000000EA   0x6011             STR      R1,[R2, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD1EA             BNE.N    ??I2C_ReadDeviceRegister_7
   \   000000F0   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000F4   0xE056             B.N      ??I2C_ReadDeviceRegister_2
   1676            }
   1677            
   1678            /* Regenerate a start condition */
   1679            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDeviceRegister_9: (+1)
   \   000000F6   0x2101             MOVS     R1,#+1
   \   000000F8   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000FA   0x.... 0x....      BL       I2C_GenerateSTART
   1680            
   1681            /* Test on EV5 and clear it */
   1682            IOE_TimeOut = TIMEOUT_MAX;
   \   000000FE   0xF44F 0x5040      MOV      R0,#+12288
   \   00000102   0x....             LDR.N    R1,??DataTable11
   \   00000104   0x6008             STR      R0,[R1, #+0]
   1683            while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB))
   \                     ??I2C_ReadDeviceRegister_10: (+1)
   \   00000106   0x....             LDR.N    R1,??DataTable13_1  ;; 0x10000001
   \   00000108   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000010A   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD109             BNE.N    ??I2C_ReadDeviceRegister_11
   1684            {
   1685              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000112   0x....             LDR.N    R0,??DataTable11
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x1E41             SUBS     R1,R0,#+1
   \   00000118   0x....             LDR.N    R2,??DataTable11
   \   0000011A   0x6011             STR      R1,[R2, #+0]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD1F2             BNE.N    ??I2C_ReadDeviceRegister_10
   \   00000120   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000124   0xE03E             B.N      ??I2C_ReadDeviceRegister_2
   1686            }
   1687            
   1688            /* Transmit the slave address and enable writing operation */
   1689            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
   \                     ??I2C_ReadDeviceRegister_11: (+1)
   \   00000126   0x2201             MOVS     R2,#+1
   \   00000128   0x0021             MOVS     R1,R4
   \   0000012A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012C   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000012E   0x.... 0x....      BL       I2C_Send7bitAddress
   1690            
   1691            /* Test on EV6 and clear it */
   1692            IOE_TimeOut = TIMEOUT_MAX;
   \   00000132   0xF44F 0x5040      MOV      R0,#+12288
   \   00000136   0x....             LDR.N    R1,??DataTable11
   \   00000138   0x6008             STR      R0,[R1, #+0]
   1693            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
   \                     ??I2C_ReadDeviceRegister_12: (+1)
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable15_11  ;; 0x10000002
   \   0000013E   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000140   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD109             BNE.N    ??I2C_ReadDeviceRegister_13
   1694            {
   1695              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000148   0x....             LDR.N    R0,??DataTable11
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x1E41             SUBS     R1,R0,#+1
   \   0000014E   0x....             LDR.N    R2,??DataTable11
   \   00000150   0x6011             STR      R1,[R2, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD1F1             BNE.N    ??I2C_ReadDeviceRegister_12
   \   00000156   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000015A   0xE023             B.N      ??I2C_ReadDeviceRegister_2
   1696            }
   1697            
   1698              /* Read status register 2 to clear ADDR flag */
   1699            IOE_I2C->SR2;
   \                     ??I2C_ReadDeviceRegister_13: (+1)
   \   0000015C   0x....             LDR.N    R0,??DataTable15_12  ;; 0x40005418
   \   0000015E   0x8800             LDRH     R0,[R0, #+0]
   1700            
   1701            /* Test on EV7 and clear it */
   1702            IOE_TimeOut = TIMEOUT_MAX;
   \   00000160   0xF44F 0x5040      MOV      R0,#+12288
   \   00000164   0x....             LDR.N    R1,??DataTable11
   \   00000166   0x6008             STR      R0,[R1, #+0]
   1703            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_RXNE))
   \                     ??I2C_ReadDeviceRegister_14: (+1)
   \   00000168   0x....             LDR.N    R1,??DataTable15_13  ;; 0x10000040
   \   0000016A   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000016C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD109             BNE.N    ??I2C_ReadDeviceRegister_15
   1704            {
   1705              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000174   0x....             LDR.N    R0,??DataTable11
   \   00000176   0x6800             LDR      R0,[R0, #+0]
   \   00000178   0x1E41             SUBS     R1,R0,#+1
   \   0000017A   0x....             LDR.N    R2,??DataTable11
   \   0000017C   0x6011             STR      R1,[R2, #+0]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD1F2             BNE.N    ??I2C_ReadDeviceRegister_14
   \   00000182   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000186   0xE00D             B.N      ??I2C_ReadDeviceRegister_2
   1706            }
   1707            
   1708            /* End the configuration sequence */
   1709            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDeviceRegister_15: (+1)
   \   00000188   0x2101             MOVS     R1,#+1
   \   0000018A   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000018C   0x.... 0x....      BL       I2C_GenerateSTOP
   1710            
   1711            /* Load the register value */
   1712            tmp = I2C_ReceiveData(IOE_I2C);
   \   00000190   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000192   0x.... 0x....      BL       I2C_ReceiveData
   \   00000196   0x0006             MOVS     R6,R0
   1713            
   1714            /* Enable Acknowledgement */
   1715            I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
   \   00000198   0x2101             MOVS     R1,#+1
   \   0000019A   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000019C   0x.... 0x....      BL       I2C_AcknowledgeConfig
   1716            
   1717            /* Return the read value */
   1718            return tmp;
   \   000001A0   0x0030             MOVS     R0,R6
   \   000001A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??I2C_ReadDeviceRegister_2: (+1)
   \   000001A4   0xBD70             POP      {R4-R6,PC}       ;; return
   1719            
   1720          }
   1721          
   1722          /**
   1723            * @brief  Reads a buffer of 2 bytes from the device registers.
   1724            * @param  DeviceAddr: The address of the device, could be : IOE_1_ADDR
   1725            *         or IOE_2_ADDR. 
   1726            * @param  RegisterAddr: The target register adress (between 00x and 0x24)
   1727            * @retval The data in the buffer containing the two returned bytes (in halfword).   
   1728            */

   \                                 In section .text, align 2, keep-with-next
   1729          uint16_t I2C_ReadDataBuffer(uint8_t DeviceAddr, uint32_t RegisterAddr)
   1730          {
   \                     I2C_ReadDataBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1731            uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1732            
   1733            /* Enable the I2C peripheral */
   1734            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000010   0x.... 0x....      BL       I2C_GenerateSTART
   1735           
   1736            /* Test on EV5 and clear it */
   1737            IOE_TimeOut = TIMEOUT_MAX;
   \   00000014   0xF44F 0x5040      MOV      R0,#+12288
   \   00000018   0x....             LDR.N    R1,??DataTable13_3
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1738            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
   \                     ??I2C_ReadDataBuffer_0: (+1)
   \   0000001C   0x....             LDR.N    R1,??DataTable13_1  ;; 0x10000001
   \   0000001E   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000020   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD10A             BNE.N    ??I2C_ReadDataBuffer_1
   1739            {
   1740              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000028   0x....             LDR.N    R0,??DataTable13_3
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1E41             SUBS     R1,R0,#+1
   \   0000002E   0x....             LDR.N    R2,??DataTable13_3
   \   00000030   0x6011             STR      R1,[R2, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1F2             BNE.N    ??I2C_ReadDataBuffer_0
   \   00000036   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0xE0A8             B.N      ??I2C_ReadDataBuffer_2
   1741            }
   1742             
   1743            /* Send device address for write */
   1744            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_ReadDataBuffer_1: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000046   0x.... 0x....      BL       I2C_Send7bitAddress
   1745            
   1746            /* Test on EV6 and clear it */
   1747            IOE_TimeOut = TIMEOUT_MAX;  
   \   0000004A   0xF44F 0x5040      MOV      R0,#+12288
   \   0000004E   0x....             LDR.N    R1,??DataTable13_3
   \   00000050   0x6008             STR      R0,[R1, #+0]
   1748            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
   \                     ??I2C_ReadDataBuffer_3: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable15_11  ;; 0x10000002
   \   00000054   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000056   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD10A             BNE.N    ??I2C_ReadDataBuffer_4
   1749            {
   1750              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000005E   0x....             LDR.N    R0,??DataTable13_3
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x1E41             SUBS     R1,R0,#+1
   \   00000064   0x....             LDR.N    R2,??DataTable13_3
   \   00000066   0x6011             STR      R1,[R2, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1F2             BNE.N    ??I2C_ReadDataBuffer_3
   \   0000006C   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000070   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000072   0xE08D             B.N      ??I2C_ReadDataBuffer_2
   1751            }
   1752            
   1753            /* Read status register 2 to clear ADDR flag */
   1754            IOE_I2C->SR2;
   \                     ??I2C_ReadDataBuffer_4: (+1)
   \   00000074   0x....             LDR.N    R0,??DataTable15_12  ;; 0x40005418
   \   00000076   0x8800             LDRH     R0,[R0, #+0]
   1755            
   1756            /* Test on EV8 and clear it */
   1757            IOE_TimeOut = TIMEOUT_MAX;
   \   00000078   0xF44F 0x5040      MOV      R0,#+12288
   \   0000007C   0x....             LDR.N    R1,??DataTable13_3
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   1758            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
   \                     ??I2C_ReadDataBuffer_5: (+1)
   \   00000080   0x....             LDR.N    R1,??DataTable14  ;; 0x10000080
   \   00000082   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000084   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD10A             BNE.N    ??I2C_ReadDataBuffer_6
   1759            {
   1760              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000008C   0x....             LDR.N    R0,??DataTable13_3
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x1E41             SUBS     R1,R0,#+1
   \   00000092   0x....             LDR.N    R2,??DataTable13_3
   \   00000094   0x6011             STR      R1,[R2, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD1F2             BNE.N    ??I2C_ReadDataBuffer_5
   \   0000009A   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   0000009E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A0   0xE076             B.N      ??I2C_ReadDataBuffer_2
   1761            }
   1762            
   1763            /* Send the device's internal address to write to */
   1764            I2C_SendData(IOE_I2C, RegisterAddr);  
   \                     ??I2C_ReadDataBuffer_6: (+1)
   \   000000A2   0x0029             MOVS     R1,R5
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000A8   0x.... 0x....      BL       I2C_SendData
   1765              
   1766            /* Send START condition a second time */  
   1767            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000B0   0x.... 0x....      BL       I2C_GenerateSTART
   1768            
   1769            /* Test on EV5 and clear it */
   1770            IOE_TimeOut = TIMEOUT_MAX;
   \   000000B4   0xF44F 0x5040      MOV      R0,#+12288
   \   000000B8   0x....             LDR.N    R1,??DataTable13_3
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   1771            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
   \                     ??I2C_ReadDataBuffer_7: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable13_1  ;; 0x10000001
   \   000000BE   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000C0   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD10A             BNE.N    ??I2C_ReadDataBuffer_8
   1772            {
   1773              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000C8   0x....             LDR.N    R0,??DataTable13_3
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x1E41             SUBS     R1,R0,#+1
   \   000000CE   0x....             LDR.N    R2,??DataTable13_3
   \   000000D0   0x6011             STR      R1,[R2, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD1F2             BNE.N    ??I2C_ReadDataBuffer_7
   \   000000D6   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0xE058             B.N      ??I2C_ReadDataBuffer_2
   1774            }
   1775            
   1776            /* Send IO Expander address for read */
   1777            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
   \                     ??I2C_ReadDataBuffer_8: (+1)
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x0021             MOVS     R1,R4
   \   000000E2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E4   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000E6   0x.... 0x....      BL       I2C_Send7bitAddress
   1778            
   1779            /* Test on EV6 and clear it */
   1780            IOE_TimeOut = TIMEOUT_MAX;
   \   000000EA   0xF44F 0x5040      MOV      R0,#+12288
   \   000000EE   0x....             LDR.N    R1,??DataTable13_3
   \   000000F0   0x6008             STR      R0,[R1, #+0]
   1781            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
   \                     ??I2C_ReadDataBuffer_9: (+1)
   \   000000F2   0x....             LDR.N    R1,??DataTable15_11  ;; 0x10000002
   \   000000F4   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   000000F6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD10A             BNE.N    ??I2C_ReadDataBuffer_10
   1782            {
   1783              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000FE   0x....             LDR.N    R0,??DataTable13_3
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x1E41             SUBS     R1,R0,#+1
   \   00000104   0x....             LDR.N    R2,??DataTable13_3
   \   00000106   0x6011             STR      R1,[R2, #+0]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD1F2             BNE.N    ??I2C_ReadDataBuffer_9
   \   0000010C   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000110   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000112   0xE03D             B.N      ??I2C_ReadDataBuffer_2
   1784            }
   1785           
   1786            /* Disable Acknowledgement and set Pos bit */
   1787            I2C_AcknowledgeConfig(IOE_I2C, DISABLE);       
   \                     ??I2C_ReadDataBuffer_10: (+1)
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000118   0x.... 0x....      BL       I2C_AcknowledgeConfig
   1788            I2C_NACKPositionConfig(IOE_I2C, I2C_NACKPosition_Next);
   \   0000011C   0xF44F 0x6100      MOV      R1,#+2048
   \   00000120   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000122   0x.... 0x....      BL       I2C_NACKPositionConfig
   1789            
   1790            /* Read status register 2 to clear ADDR flag */
   1791            IOE_I2C->SR2;
   \   00000126   0x....             LDR.N    R0,??DataTable15_12  ;; 0x40005418
   \   00000128   0x8800             LDRH     R0,[R0, #+0]
   1792          
   1793            /* Test on EV7 and clear it */
   1794            IOE_TimeOut = TIMEOUT_MAX;
   \   0000012A   0xF44F 0x5040      MOV      R0,#+12288
   \   0000012E   0x....             LDR.N    R1,??DataTable13_3
   \   00000130   0x6008             STR      R0,[R1, #+0]
   1795            while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
   \                     ??I2C_ReadDataBuffer_11: (+1)
   \   00000132   0x....             LDR.N    R1,??DataTable15  ;; 0x10000004
   \   00000134   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000136   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD10A             BNE.N    ??I2C_ReadDataBuffer_12
   1796            {
   1797              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000013E   0x....             LDR.N    R0,??DataTable13_3
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x1E41             SUBS     R1,R0,#+1
   \   00000144   0x....             LDR.N    R2,??DataTable13_3
   \   00000146   0x6011             STR      R1,[R2, #+0]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD1F2             BNE.N    ??I2C_ReadDataBuffer_11
   \   0000014C   0x.... 0x....      BL       IOE_TimeoutUserCallback
   \   00000150   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000152   0xE01D             B.N      ??I2C_ReadDataBuffer_2
   1798            }
   1799           
   1800            /* Send STOP Condition */
   1801            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDataBuffer_12: (+1)
   \   00000154   0x2101             MOVS     R1,#+1
   \   00000156   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000158   0x.... 0x....      BL       I2C_GenerateSTOP
   1802             
   1803            /* Read the first byte from the IO Expander */
   1804            IOE_BufferRX[1] = I2C_ReceiveData(IOE_I2C);
   \   0000015C   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000015E   0x.... 0x....      BL       I2C_ReceiveData
   \   00000162   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1805              
   1806            /* Read the second byte from the IO Expander */
   1807            IOE_BufferRX[0] = I2C_ReceiveData(IOE_I2C);
   \   00000166   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000168   0x.... 0x....      BL       I2C_ReceiveData
   \   0000016C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1808                                                   
   1809            /* Enable Acknowledgement and reset POS bit to be ready for another reception */
   1810            I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
   \   00000170   0x2101             MOVS     R1,#+1
   \   00000172   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   00000174   0x.... 0x....      BL       I2C_AcknowledgeConfig
   1811            I2C_NACKPositionConfig(IOE_I2C, I2C_NACKPosition_Current);
   \   00000178   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000017C   0x....             LDR.N    R0,??DataTable13  ;; 0x40005400
   \   0000017E   0x.... 0x....      BL       I2C_NACKPositionConfig
   1812             
   1813            /* return the data */
   1814            return ((uint16_t) IOE_BufferRX[0] | ((uint16_t)IOE_BufferRX[1]<< 8));
   \   00000182   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000186   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000018A   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000018E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??I2C_ReadDataBuffer_2: (+1)
   \   00000190   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1815          
   1816          }
   1817          
   1818          /**
   1819            * @brief  Configures the IO expander Interrupt line and GPIO in EXTI mode.
   1820            * @param  None        
   1821            * @retval None
   1822            */

   \                                 In section .text, align 2, keep-with-next
   1823          static void IOE_EXTI_Config(void)
   1824          {
   \                     IOE_EXTI_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1825            GPIO_InitTypeDef GPIO_InitStructure;
   1826            NVIC_InitTypeDef NVIC_InitStructure;
   1827            EXTI_InitTypeDef EXTI_InitStructure;
   1828           
   1829            /* Enable GPIO clock */
   1830            RCC_AHB1PeriphClockCmd(IOE_IT_GPIO_CLK, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF44F 0x7080      MOV      R0,#+256
   \   0000000A   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
   1831            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF44F 0x4080      MOV      R0,#+16384
   \   00000014   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   1832          
   1833            /* Configure Button pin as input floating */
   1834            GPIO_InitStructure.GPIO_Pin = IOE_IT_PIN;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x9003             STR      R0,[SP, #+12]
   1835            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0010      STRB     R0,[SP, #+16]
   1836            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0013      STRB     R0,[SP, #+19]
   1837            GPIO_Init(IOE_IT_GPIO_PORT, &GPIO_InitStructure);  
   \   00000028   0xA903             ADD      R1,SP,#+12
   \   0000002A   0x....             LDR.N    R0,??DataTable15_8  ;; 0x40022000
   \   0000002C   0x.... 0x....      BL       GPIO_Init
   1838            
   1839            /* Connect Button EXTI Line to Button GPIO Pin */
   1840            SYSCFG_EXTILineConfig(IOE_IT_EXTI_PORT_SOURCE, IOE_IT_EXTI_PIN_SOURCE);  
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0x.... 0x....      BL       SYSCFG_EXTILineConfig
   1841            
   1842            /* Configure Button EXTI line */
   1843            EXTI_InitStructure.EXTI_Line = IOE_IT_EXTI_LINE;
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   1844            EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1845            EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
   \   00000042   0x200C             MOVS     R0,#+12
   \   00000044   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1846            EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1847            EXTI_Init(&EXTI_InitStructure);
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0x.... 0x....      BL       EXTI_Init
   1848            
   1849            /* Enable and set Button EXTI Interrupt to the lowest priority */
   1850            NVIC_InitStructure.NVIC_IRQChannel = IOE_IT_EXTI_IRQn;
   \   00000054   0x2008             MOVS     R0,#+8
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1851            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   \   0000005A   0x200F             MOVS     R0,#+15
   \   0000005C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1852            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   00000060   0x200F             MOVS     R0,#+15
   \   00000062   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1853            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1854            NVIC_Init(&NVIC_InitStructure);
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       NVIC_Init
   1855          }
   \   00000072   0xB005             ADD      SP,SP,#+20
   \   00000074   0xBD00             POP      {PC}             ;; return
   1856          
   1857          #ifndef USE_TIMEOUT_USER_CALLBACK 
   1858          /**
   1859            * @brief  IOE_TIMEOUT_UserCallback
   1860            * @param  None
   1861            * @retval 0
   1862            */

   \                                 In section .text, align 2, keep-with-next
   1863          uint8_t IOE_TimeoutUserCallback(void)
   1864          {
   \                     IOE_TimeoutUserCallback: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1865            I2C_InitTypeDef I2C_InitStructure;
   1866          
   1867            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x....             LDR.N    R0,??DataTable15_14  ;; 0x40005400
   \   00000008   0x.... 0x....      BL       I2C_GenerateSTOP
   1868            I2C_SoftwareResetCmd(IOE_I2C, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x....             LDR.N    R0,??DataTable15_14  ;; 0x40005400
   \   00000010   0x.... 0x....      BL       I2C_SoftwareResetCmd
   1869            I2C_SoftwareResetCmd(IOE_I2C, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R0,??DataTable15_14  ;; 0x40005400
   \   00000018   0x.... 0x....      BL       I2C_SoftwareResetCmd
   1870            
   1871            IOE_GPIO_Config();
   \   0000001C   0x.... 0x....      BL       IOE_GPIO_Config
   1872          
   1873            /* CODEC_I2C peripheral configuration */
   1874            I2C_DeInit(I2C1);
   \   00000020   0x....             LDR.N    R0,??DataTable15_14  ;; 0x40005400
   \   00000022   0x.... 0x....      BL       I2C_DeInit
   1875            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1876            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000002C   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000030   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1877            I2C_InitStructure.I2C_OwnAddress1 = 0x33;
   \   00000034   0x2033             MOVS     R0,#+51
   \   00000036   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1878            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   0000003A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1879            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000042   0xF44F 0x4080      MOV      R0,#+16384
   \   00000046   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   1880            I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   0000004A   0x....             LDR.N    R0,??DataTable15_9  ;; 0x186a0
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   1881            
   1882            /* Enable the I2C peripheral */
   1883            I2C_Cmd(IOE_I2C, ENABLE);  
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x....             LDR.N    R0,??DataTable15_14  ;; 0x40005400
   \   00000052   0x.... 0x....      BL       I2C_Cmd
   1884            I2C_Init(IOE_I2C, &I2C_InitStructure);
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x....             LDR.N    R0,??DataTable15_14  ;; 0x40005400
   \   0000005A   0x.... 0x....      BL       I2C_Init
   1885            
   1886            return 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xB005             ADD      SP,SP,#+20
   \   00000062   0xBD00             POP      {PC}             ;; return
   1887          }
   1888          #endif /* !USE_TIMEOUT_USER_CALLBACK */
   1889          
   1890          #ifndef USE_Delay
   1891          /**
   1892            * @brief  Inserts a delay time.
   1893            * @param  nCount: specifies the delay time length.
   1894            * @retval None
   1895            */

   \                                 In section .text, align 2, keep-with-next
   1896          static void delay(__IO uint32_t nCount)
   1897          {
   \                     delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1898            __IO uint32_t index = 0; 
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1899            for(index = (100000 * nCount); index != 0; index--)
   \   00000008   0x9801             LDR      R0,[SP, #+4]
   \   0000000A   0x....             LDR.N    R1,??DataTable15_9  ;; 0x186a0
   \   0000000C   0x4348             MULS     R0,R1,R0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0xE002             B.N      ??delay_0
   \                     ??delay_1: (+1)
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \                     ??delay_0: (+1)
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F9             BNE.N    ??delay_1
   1900            {
   1901            }
   1902          }
   \   0000001E   0xB002             ADD      SP,SP,#+8
   \   00000020   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     `IOE_TS_GetState::_x`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     TS_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     `IOE_TS_GetState::_y`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     `IOE_TempSens_GetData::tmp`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     IOE_TimeOut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x10000001         DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x00070082         DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     IOE_TimeOut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x10000080         DC32     0x10000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x10000004         DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x400260A0         DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x20200000         DC32     0x20200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x002FD000         DC32     0x2fd000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x00030002         DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40026010         DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x10000020         DC32     0x10000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x40005410         DC32     0x40005410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x10000002         DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x40005418         DC32     0x40005418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x10000040         DC32     0x10000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0
   1903          #endif /* USE_Delay*/
   1904          /**
   1905            * @}
   1906            */ 
   1907          
   1908          /**
   1909            * @}
   1910            */ 
   1911          
   1912          /**
   1913            * @}
   1914            */ 
   1915          
   1916          /**
   1917            * @}
   1918            */ 
   1919          
   1920          /**
   1921            * @}
   1922            */      
   1923          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2C_DMA_ReadDataBuffer
        16   -> DMA_ClearFlag
        16   -> DMA_Cmd
        16   -> DMA_GetFlagStatus
        16   -> I2C_CheckEvent
        16   -> I2C_DMACmd
        16   -> I2C_DMALastTransferCmd
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_Send7bitAddress
        16   -> I2C_SendData
        16   -> IOE_DMA_Config
        16   -> IOE_TimeoutUserCallback
      16   I2C_DMA_ReadDeviceRegister
        16   -> DMA_ClearFlag
        16   -> DMA_Cmd
        16   -> DMA_GetFlagStatus
        16   -> I2C_CheckEvent
        16   -> I2C_DMACmd
        16   -> I2C_DMALastTransferCmd
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_Send7bitAddress
        16   -> I2C_SendData
        16   -> IOE_DMA_Config
        16   -> IOE_TimeoutUserCallback
      24   I2C_DMA_WriteDeviceRegister
        24   -> DMA_ClearFlag
        24   -> DMA_Cmd
        24   -> DMA_GetFlagStatus
        24   -> I2C_CheckEvent
        24   -> I2C_DMACmd
        24   -> I2C_GenerateSTART
        24   -> I2C_GenerateSTOP
        24   -> I2C_GetFlagStatus
        24   -> I2C_Send7bitAddress
        24   -> I2C_SendData
        24   -> IOE_DMA_Config
        24   -> IOE_TimeoutUserCallback
      16   I2C_ReadDataBuffer
        16   -> I2C_AcknowledgeConfig
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_NACKPositionConfig
        16   -> I2C_ReceiveData
        16   -> I2C_Send7bitAddress
        16   -> I2C_SendData
        16   -> IOE_TimeoutUserCallback
      16   I2C_ReadDeviceRegister
        16   -> I2C_AcknowledgeConfig
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_ReceiveData
        16   -> I2C_Send7bitAddress
        16   -> I2C_SendData
        16   -> IOE_TimeoutUserCallback
      24   I2C_WriteDeviceRegister
        24   -> I2C_GenerateSTART
        24   -> I2C_GenerateSTOP
        24   -> I2C_GetFlagStatus
        24   -> I2C_Send7bitAddress
        24   -> I2C_SendData
        24   -> IOE_TimeoutUserCallback
       8   IOE_ClearGITPending
         8   -> I2C_WriteDeviceRegister
      16   IOE_ClearIOITPending
        16   -> I2C_WriteDeviceRegister
       8   IOE_Config
         8   -> IOE_FnctCmd
         8   -> IOE_GPIO_Config
         8   -> IOE_I2C_Config
         8   -> IOE_IOAFConfig
         8   -> IOE_IOEdgeConfig
         8   -> IOE_IOPinConfig
         8   -> IOE_IsOperational
         8   -> IOE_Reset
         8   -> IOE_TS_Config
         8   -> IOE_TempSens_Config
         8   -> IOE_WriteIOPin
      72   IOE_DMA_Config
        72   -> DMA_DeInit
        72   -> DMA_Init
        72   -> RCC_AHB1PeriphClockCmd
      24   IOE_EXTI_Config
        24   -> EXTI_Init
        24   -> GPIO_Init
        24   -> NVIC_Init
        24   -> RCC_AHB1PeriphClockCmd
        24   -> RCC_APB2PeriphClockCmd
        24   -> SYSCFG_EXTILineConfig
      16   IOE_FnctCmd
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
      16   IOE_GITCmd
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
      16   IOE_GITConfig
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
      16   IOE_GPIO_Config
        16   -> GPIO_Init
        16   -> GPIO_PinAFConfig
        16   -> RCC_AHB1PeriphClockCmd
        16   -> RCC_APB1PeriphClockCmd
        16   -> RCC_APB1PeriphResetCmd
        16   -> RCC_APB2PeriphClockCmd
        16   -> SYSCFG_EXTILineConfig
      16   IOE_GetGITStatus
        16   -> I2C_ReadDeviceRegister
       8   IOE_GetIOITStatus
         8   -> I2C_ReadDeviceRegister
      24   IOE_I2C_Config
        24   -> I2C_Cmd
        24   -> I2C_Init
      16   IOE_IOAFConfig
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
      24   IOE_IOEdgeConfig
        24   -> I2C_ReadDeviceRegister
        24   -> I2C_WriteDeviceRegister
      16   IOE_IOITConfig
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
      16   IOE_IOPinConfig
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
       8   IOE_ITConfig
         8   -> I2C_ReadDeviceRegister
         8   -> IOE_EXTI_Config
         8   -> IOE_GITCmd
         8   -> IOE_GITConfig
         8   -> IOE_IOITConfig
         8   -> IOE_ITOutConfig
      16   IOE_ITOutConfig
        16   -> I2C_ReadDeviceRegister
        16   -> I2C_WriteDeviceRegister
       8   IOE_IsOperational
         8   -> IOE_ReadID
         8   -> IOE_TimeoutUserCallback
       8   IOE_JoyStickGetState
         8   -> I2C_ReadDeviceRegister
      16   IOE_ReadID
        16   -> I2C_ReadDeviceRegister
       8   IOE_ReadIOPin
         8   -> I2C_ReadDeviceRegister
       8   IOE_Reset
         8   -> I2C_WriteDeviceRegister
         8   -> delay
       8   IOE_TS_Config
         8   -> I2C_WriteDeviceRegister
         8   -> IOE_FnctCmd
         8   -> IOE_IOAFConfig
         8   -> delay
       8   IOE_TS_GetState
         8   -> I2C_ReadDeviceRegister
         8   -> I2C_WriteDeviceRegister
         8   -> IOE_TS_Read_X
         8   -> IOE_TS_Read_Y
         8   -> IOE_TS_Read_Z
       8   IOE_TS_Read_X
         8   -> I2C_ReadDataBuffer
       8   IOE_TS_Read_Y
         8   -> I2C_ReadDataBuffer
       8   IOE_TS_Read_Z
         8   -> I2C_ReadDataBuffer
       8   IOE_TempSens_Config
         8   -> I2C_WriteDeviceRegister
         8   -> IOE_FnctCmd
       8   IOE_TempSens_GetData
         8   -> I2C_ReadDeviceRegister
         8   -> I2C_WriteDeviceRegister
      24   IOE_TimeoutUserCallback
        24   -> I2C_Cmd
        24   -> I2C_DeInit
        24   -> I2C_GenerateSTOP
        24   -> I2C_Init
        24   -> I2C_SoftwareResetCmd
        24   -> IOE_GPIO_Config
       8   IOE_WriteIOPin
         8   -> I2C_WriteDeviceRegister
       8   delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable9
       2  ?_0
       2  ?_1
       2  ?_2
     514  I2C_DMA_ReadDataBuffer
     474  I2C_DMA_ReadDeviceRegister
     398  I2C_DMA_WriteDeviceRegister
     402  I2C_ReadDataBuffer
     422  I2C_ReadDeviceRegister
     316  I2C_WriteDeviceRegister
      18  IOE_ClearGITPending
      66  IOE_ClearIOITPending
     216  IOE_Config
     144  IOE_DMA_Config
     118  IOE_EXTI_Config
      50  IOE_FnctCmd
      52  IOE_GITCmd
      50  IOE_GITConfig
     168  IOE_GPIO_Config
      40  IOE_GetGITStatus
      32  IOE_GetIOITStatus
      70  IOE_I2C_Config
      50  IOE_IOAFConfig
      94  IOE_IOEdgeConfig
      50  IOE_IOITConfig
      50  IOE_IOPinConfig
     166  IOE_ITConfig
      72  IOE_ITOutConfig
      40  IOE_IsOperational
      70  IOE_JoyStickGetState
      38  IOE_ReadID
      52  IOE_ReadIOPin
      38  IOE_Reset
     158  IOE_TS_Config
     174  IOE_TS_GetState
      38  IOE_TS_Read_X
      38  IOE_TS_Read_Y
      20  IOE_TS_Read_Z
      42  IOE_TempSens_Config
     110  IOE_TempSens_GetData
       4  IOE_TimeOut
     100  IOE_TimeoutUserCallback
      64  IOE_WriteIOPin
       8  TS_State
       4  _x
       4  _y
      34  delay
       4  tmp

 
    20 bytes in section .bss
     4 bytes in section .data
     6 bytes in section .rodata
 5 148 bytes in section .text
 
 5 148 bytes of CODE  memory
     6 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
