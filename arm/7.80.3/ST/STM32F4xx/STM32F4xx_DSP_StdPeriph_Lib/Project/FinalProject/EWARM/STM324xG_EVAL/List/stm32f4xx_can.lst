###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       05/Apr/2017  15:43:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#    Command line =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\STM324xG_EVAL\List
#        -o
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\..\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\STM324xG_EVAL\List\stm32f4xx_can.lst
#    Object file  =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\FinalProject\EWARM\STM324xG_EVAL\Obj\stm32f4xx_can.o
#
###############################################################################

C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           + Initialization and Configuration 
     10            *           + CAN Frames Transmission 
     11            *           + CAN Frames Reception    
     12            *           + Operation modes switch  
     13            *           + Error management          
     14            *           + Interrupts and flags        
     15            *         
     16          @verbatim                                 
     17           ===============================================================================      
     18                                  ##### How to use this driver #####
     19           ===============================================================================
     20              [..]            
     21                (#) Enable the CAN controller interface clock using 
     22                    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     23                    and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     24                -@- In case you are using CAN2 only, you have to enable the CAN1 clock.
     25                 
     26                (#) CAN pins configuration
     27                  (++) Enable the clock for the CAN GPIOs using the following function:
     28                       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     29                  (++) Connect the involved CAN pins to AF9 using the following function 
     30                       GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     31                  (++) Configure these CAN pins in alternate function mode by calling
     32                       the function  GPIO_Init();
     33                
     34                (#) Initialise and configure the CAN using CAN_Init() and 
     35                    CAN_FilterInit() functions.   
     36                           
     37                (#) Transmit the desired CAN frame using CAN_Transmit() function.
     38                     
     39                (#) Check the transmission of a CAN frame using CAN_TransmitStatus()
     40                    function.
     41                           
     42                (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     43                    function.  
     44                        
     45                (#) Receive a CAN frame using CAN_Recieve() function.
     46                     
     47                (#) Release the receive FIFOs using CAN_FIFORelease() function.
     48                           
     49                (#) Return the number of pending received frames using 
     50                    CAN_MessagePending() function.            
     51                               
     52                (#) To control CAN events you can use one of the following two methods:
     53                  (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
     54                  (++) Use CAN interrupts through the function CAN_ITConfig() at 
     55                       initialization phase and CAN_GetITStatus() function into 
     56                       interrupt routines to check if the event has occurred or not.
     57                       After checking on a flag you should clear it using CAN_ClearFlag()
     58                       function. And after checking on an interrupt event you should 
     59                       clear it using CAN_ClearITPendingBit() function.            
     60                           
     61                          
     62          @endverbatim
     63                     
     64            ******************************************************************************
     65            * @attention
     66            *
     67            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     68            *
     69            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     70            * You may not use this file except in compliance with the License.
     71            * You may obtain a copy of the License at:
     72            *
     73            *        http://www.st.com/software_license_agreement_liberty_v2
     74            *
     75            * Unless required by applicable law or agreed to in writing, software 
     76            * distributed under the License is distributed on an "AS IS" BASIS, 
     77            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     78            * See the License for the specific language governing permissions and
     79            * limitations under the License.
     80            *
     81            ******************************************************************************  
     82            */
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32f4xx_can.h"
     86          #include "stm32f4xx_rcc.h"
     87          
     88          /** @addtogroup STM32F4xx_StdPeriph_Driver
     89            * @{
     90            */
     91          
     92          /** @defgroup CAN 
     93            * @brief CAN driver modules
     94            * @{
     95            */ 
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          
     99          /* CAN Master Control Register bits */
    100          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
    101          
    102          /* CAN Mailbox Transmit Request */
    103          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
    104          
    105          /* CAN Filter Master Register bits */
    106          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    107          
    108          /* Time out for INAK bit */
    109          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    110          /* Time out for SLAK bit */
    111          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    112          
    113          /* Flags in TSR register */
    114          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    115          /* Flags in RF1R register */
    116          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    117          /* Flags in RF0R register */
    118          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    119          /* Flags in MSR register */
    120          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    121          /* Flags in ESR register */
    122          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    123          
    124          /* Mailboxes definition */
    125          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    126          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    127          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    128          
    129          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    130          
    131          /* Private macro -------------------------------------------------------------*/
    132          /* Private variables ---------------------------------------------------------*/
    133          /* Private function prototypes -----------------------------------------------*/
    134          /* Private functions ---------------------------------------------------------*/
    135          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    136          
    137          /** @defgroup CAN_Private_Functions
    138            * @{
    139            */
    140          
    141          /** @defgroup CAN_Group1 Initialization and Configuration functions
    142           *  @brief    Initialization and Configuration functions 
    143           *
    144          @verbatim    
    145           ===============================================================================
    146                        ##### Initialization and Configuration functions #####
    147           ===============================================================================  
    148              [..] This section provides functions allowing to 
    149                (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
    150                    number of time quanta to perform resynchronization, the number of time 
    151                    quanta in Bit Segment 1 and 2 and many other modes. 
    152                    Refer to  @ref CAN_InitTypeDef  for more details.
    153                (+) Configures the CAN reception filter.                                      
    154                (+) Select the start bank filter for slave CAN.
    155                (+) Enables or disables the Debug Freeze mode for CAN
    156                (+)Enables or disables the CAN Time Trigger Operation communication mode
    157             
    158          @endverbatim
    159            * @{
    160            */
    161            
    162          /**
    163            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    164            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    165            * @retval None.
    166            */

   \                                 In section .text, align 2, keep-with-next
    167          void CAN_DeInit(CAN_TypeDef* CANx)
    168          {
   \                     CAN_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    169            /* Check the parameters */
    170            assert_param(IS_CAN_ALL_PERIPH(CANx));
    171           
    172            if (CANx == CAN1)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable6  ;; 0x40006400
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD10A             BNE.N    ??CAN_DeInit_0
    173            {
    174              /* Enable CAN1 reset state */
    175              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000010   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    176              /* Release CAN1 from reset state */
    177              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF05F 0x7000      MOVS     R0,#+33554432
   \   0000001A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000001E   0xE009             B.N      ??CAN_DeInit_1
    178            }
    179            else
    180            {  
    181              /* Enable CAN2 reset state */
    182              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_0: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000026   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    183              /* Release CAN2 from reset state */
    184              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000030   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    185            }
    186          }
   \                     ??CAN_DeInit_1: (+1)
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    187          
    188          /**
    189            * @brief  Initializes the CAN peripheral according to the specified
    190            *         parameters in the CAN_InitStruct.
    191            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    192            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    193            *         the configuration information for the CAN peripheral.
    194            * @retval Constant indicates initialization succeed which will be 
    195            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    196            */

   \                                 In section .text, align 2, keep-with-next
    197          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    198          {
    199            uint8_t InitStatus = CAN_InitStatus_Failed;
   \                     CAN_Init: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    200            uint32_t wait_ack = 0x00000000;
   \   00000002   0x2200             MOVS     R2,#+0
    201            /* Check the parameters */
    202            assert_param(IS_CAN_ALL_PERIPH(CANx));
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    204            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    205            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    206            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    207            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    208            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    209            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    210            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    211            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    212            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    213            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    214          
    215            /* Exit from sleep mode */
    216            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
   \   00000004   0x6803             LDR      R3,[R0, #+0]
   \   00000006   0xF033 0x0302      BICS     R3,R3,#0x2
   \   0000000A   0x6003             STR      R3,[R0, #+0]
    217          
    218            /* Request initialisation */
    219            CANx->MCR |= CAN_MCR_INRQ ;
   \   0000000C   0x6803             LDR      R3,[R0, #+0]
   \   0000000E   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000012   0x6003             STR      R3,[R0, #+0]
   \   00000014   0xE000             B.N      ??CAN_Init_0
    220          
    221            /* Wait the acknowledge */
    222            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    223            {
    224              wait_ack++;
   \                     ??CAN_Init_1: (+1)
   \   00000016   0x1C52             ADDS     R2,R2,#+1
    225            }
   \                     ??CAN_Init_0: (+1)
   \   00000018   0x6843             LDR      R3,[R0, #+4]
   \   0000001A   0x07DB             LSLS     R3,R3,#+31
   \   0000001C   0xD403             BMI.N    ??CAN_Init_2
   \   0000001E   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000022   0x429A             CMP      R2,R3
   \   00000024   0xD1F7             BNE.N    ??CAN_Init_1
    226          
    227            /* Check acknowledge */
    228            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_2: (+1)
   \   00000026   0x6842             LDR      R2,[R0, #+4]
   \   00000028   0x07D2             LSLS     R2,R2,#+31
   \   0000002A   0xD401             BMI.N    ??CAN_Init_3
    229            {
    230              InitStatus = CAN_InitStatus_Failed;
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0xE06A             B.N      ??CAN_Init_4
    231            }
    232            else 
    233            {
    234              /* Set the time triggered communication mode */
    235              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_3: (+1)
   \   00000030   0x798A             LDRB     R2,[R1, #+6]
   \   00000032   0x2A01             CMP      R2,#+1
   \   00000034   0xD104             BNE.N    ??CAN_Init_5
    236              {
    237                CANx->MCR |= CAN_MCR_TTCM;
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000003C   0x6002             STR      R2,[R0, #+0]
   \   0000003E   0xE003             B.N      ??CAN_Init_6
    238              }
    239              else
    240              {
    241                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
   \                     ??CAN_Init_5: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0xF032 0x0280      BICS     R2,R2,#0x80
   \   00000046   0x6002             STR      R2,[R0, #+0]
    242              }
    243          
    244              /* Set the automatic bus-off management */
    245              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_6: (+1)
   \   00000048   0x79CA             LDRB     R2,[R1, #+7]
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0xD104             BNE.N    ??CAN_Init_7
    246              {
    247                CANx->MCR |= CAN_MCR_ABOM;
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000054   0x6002             STR      R2,[R0, #+0]
   \   00000056   0xE003             B.N      ??CAN_Init_8
    248              }
    249              else
    250              {
    251                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
   \                     ??CAN_Init_7: (+1)
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0xF032 0x0240      BICS     R2,R2,#0x40
   \   0000005E   0x6002             STR      R2,[R0, #+0]
    252              }
    253          
    254              /* Set the automatic wake-up mode */
    255              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_8: (+1)
   \   00000060   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000062   0x2A01             CMP      R2,#+1
   \   00000064   0xD104             BNE.N    ??CAN_Init_9
    256              {
    257                CANx->MCR |= CAN_MCR_AWUM;
   \   00000066   0x6802             LDR      R2,[R0, #+0]
   \   00000068   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   0000006C   0x6002             STR      R2,[R0, #+0]
   \   0000006E   0xE003             B.N      ??CAN_Init_10
    258              }
    259              else
    260              {
    261                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
   \                     ??CAN_Init_9: (+1)
   \   00000070   0x6802             LDR      R2,[R0, #+0]
   \   00000072   0xF032 0x0220      BICS     R2,R2,#0x20
   \   00000076   0x6002             STR      R2,[R0, #+0]
    262              }
    263          
    264              /* Set the no automatic retransmission */
    265              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_10: (+1)
   \   00000078   0x7A4A             LDRB     R2,[R1, #+9]
   \   0000007A   0x2A01             CMP      R2,#+1
   \   0000007C   0xD104             BNE.N    ??CAN_Init_11
    266              {
    267                CANx->MCR |= CAN_MCR_NART;
   \   0000007E   0x6802             LDR      R2,[R0, #+0]
   \   00000080   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   00000084   0x6002             STR      R2,[R0, #+0]
   \   00000086   0xE003             B.N      ??CAN_Init_12
    268              }
    269              else
    270              {
    271                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
   \                     ??CAN_Init_11: (+1)
   \   00000088   0x6802             LDR      R2,[R0, #+0]
   \   0000008A   0xF032 0x0210      BICS     R2,R2,#0x10
   \   0000008E   0x6002             STR      R2,[R0, #+0]
    272              }
    273          
    274              /* Set the receive FIFO locked mode */
    275              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_12: (+1)
   \   00000090   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000092   0x2A01             CMP      R2,#+1
   \   00000094   0xD104             BNE.N    ??CAN_Init_13
    276              {
    277                CANx->MCR |= CAN_MCR_RFLM;
   \   00000096   0x6802             LDR      R2,[R0, #+0]
   \   00000098   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   0000009C   0x6002             STR      R2,[R0, #+0]
   \   0000009E   0xE003             B.N      ??CAN_Init_14
    278              }
    279              else
    280              {
    281                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
   \                     ??CAN_Init_13: (+1)
   \   000000A0   0x6802             LDR      R2,[R0, #+0]
   \   000000A2   0xF032 0x0208      BICS     R2,R2,#0x8
   \   000000A6   0x6002             STR      R2,[R0, #+0]
    282              }
    283          
    284              /* Set the transmit FIFO priority */
    285              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_14: (+1)
   \   000000A8   0x7ACA             LDRB     R2,[R1, #+11]
   \   000000AA   0x2A01             CMP      R2,#+1
   \   000000AC   0xD104             BNE.N    ??CAN_Init_15
    286              {
    287                CANx->MCR |= CAN_MCR_TXFP;
   \   000000AE   0x6802             LDR      R2,[R0, #+0]
   \   000000B0   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   000000B4   0x6002             STR      R2,[R0, #+0]
   \   000000B6   0xE003             B.N      ??CAN_Init_16
    288              }
    289              else
    290              {
    291                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
   \                     ??CAN_Init_15: (+1)
   \   000000B8   0x6802             LDR      R2,[R0, #+0]
   \   000000BA   0xF032 0x0204      BICS     R2,R2,#0x4
   \   000000BE   0x6002             STR      R2,[R0, #+0]
    292              }
    293          
    294              /* Set the bit timing register */
    295              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    296                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    297                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    298                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    299                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_16: (+1)
   \   000000C0   0x788A             LDRB     R2,[R1, #+2]
   \   000000C2   0x78CB             LDRB     R3,[R1, #+3]
   \   000000C4   0x061B             LSLS     R3,R3,#+24
   \   000000C6   0xEA53 0x7282      ORRS     R2,R3,R2, LSL #+30
   \   000000CA   0x790B             LDRB     R3,[R1, #+4]
   \   000000CC   0xEA52 0x4203      ORRS     R2,R2,R3, LSL #+16
   \   000000D0   0x794B             LDRB     R3,[R1, #+5]
   \   000000D2   0xEA52 0x5203      ORRS     R2,R2,R3, LSL #+20
   \   000000D6   0x8809             LDRH     R1,[R1, #+0]
   \   000000D8   0x1E49             SUBS     R1,R1,#+1
   \   000000DA   0x4311             ORRS     R1,R1,R2
   \   000000DC   0x61C1             STR      R1,[R0, #+28]
    300          
    301              /* Request leave initialisation */
    302              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0x0849             LSRS     R1,R1,#+1
   \   000000E2   0x0049             LSLS     R1,R1,#+1
   \   000000E4   0x6001             STR      R1,[R0, #+0]
    303          
    304             /* Wait the acknowledge */
    305             wait_ack = 0;
   \   000000E6   0x2200             MOVS     R2,#+0
   \   000000E8   0xE000             B.N      ??CAN_Init_17
    306          
    307             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    308             {
    309               wait_ack++;
   \                     ??CAN_Init_18: (+1)
   \   000000EA   0x1C52             ADDS     R2,R2,#+1
    310             }
   \                     ??CAN_Init_17: (+1)
   \   000000EC   0x6841             LDR      R1,[R0, #+4]
   \   000000EE   0x07C9             LSLS     R1,R1,#+31
   \   000000F0   0xD503             BPL.N    ??CAN_Init_19
   \   000000F2   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000F6   0x428A             CMP      R2,R1
   \   000000F8   0xD1F7             BNE.N    ??CAN_Init_18
    311          
    312              /* ...and check acknowledged */
    313              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_19: (+1)
   \   000000FA   0x6840             LDR      R0,[R0, #+4]
   \   000000FC   0x07C0             LSLS     R0,R0,#+31
   \   000000FE   0xD501             BPL.N    ??CAN_Init_20
    314              {
    315                InitStatus = CAN_InitStatus_Failed;
   \   00000100   0x2200             MOVS     R2,#+0
   \   00000102   0xE000             B.N      ??CAN_Init_4
    316              }
    317              else
    318              {
    319                InitStatus = CAN_InitStatus_Success ;
   \                     ??CAN_Init_20: (+1)
   \   00000104   0x2201             MOVS     R2,#+1
    320              }
    321            }
    322          
    323            /* At this step, return the status of initialization */
    324            return InitStatus;
   \                     ??CAN_Init_4: (+1)
   \   00000106   0x0010             MOVS     R0,R2
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0x4770             BX       LR               ;; return
    325          }
    326          
    327          /**
    328            * @brief  Configures the CAN reception filter according to the specified
    329            *         parameters in the CAN_FilterInitStruct.
    330            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    331            *         contains the configuration information.
    332            * @retval None
    333            */

   \                                 In section .text, align 2, keep-with-next
    334          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    335          {
   \                     CAN_FilterInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    336            uint32_t filter_number_bit_pos = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    337            /* Check the parameters */
    338            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    339            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    340            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    341            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    342            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    343          
    344            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x7A82             LDRB     R2,[R0, #+10]
   \   00000008   0x4091             LSLS     R1,R1,R2
    345          
    346            /* Initialisation mode for the filter */
    347            CAN1->FMR |= FMR_FINIT;
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable6_1  ;; 0x40006600
   \   00000018   0x601A             STR      R2,[R3, #+0]
    348          
    349            /* Filter Deactivation */
    350            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable6_2  ;; 0x4000661c
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0x438A             BICS     R2,R2,R1
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable6_2  ;; 0x4000661c
   \   00000026   0x601A             STR      R2,[R3, #+0]
    351          
    352            /* Filter Scale */
    353            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   00000028   0x7B02             LDRB     R2,[R0, #+12]
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD119             BNE.N    ??CAN_FilterInit_0
    354            {
    355              /* 16-bit scale for the filter */
    356              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable6_3  ;; 0x4000660c
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x438A             BICS     R2,R2,R1
   \   00000036   0x.... 0x....      LDR.W    R3,??DataTable6_3  ;; 0x4000660c
   \   0000003A   0x601A             STR      R2,[R3, #+0]
    357          
    358              /* First 16-bit identifier and First 16-bit mask */
    359              /* Or First 16-bit identifier and Second 16-bit identifier */
    360              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    361                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    362                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   0000003C   0x88C2             LDRH     R2,[R0, #+6]
   \   0000003E   0x8843             LDRH     R3,[R0, #+2]
   \   00000040   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable6_4  ;; 0x40006640
   \   00000048   0x7A84             LDRB     R4,[R0, #+10]
   \   0000004A   0xF843 0x2034      STR      R2,[R3, R4, LSL #+3]
    363          
    364              /* Second 16-bit identifier and Second 16-bit mask */
    365              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    366              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    367                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    368                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable6_4  ;; 0x40006640
   \   00000052   0x7A83             LDRB     R3,[R0, #+10]
   \   00000054   0xEB02 0x02C3      ADD      R2,R2,R3, LSL #+3
   \   00000058   0x8883             LDRH     R3,[R0, #+4]
   \   0000005A   0x8804             LDRH     R4,[R0, #+0]
   \   0000005C   0xEA54 0x4303      ORRS     R3,R4,R3, LSL #+16
   \   00000060   0x6053             STR      R3,[R2, #+4]
    369            }
    370          
    371            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0: (+1)
   \   00000062   0x7B02             LDRB     R2,[R0, #+12]
   \   00000064   0x2A01             CMP      R2,#+1
   \   00000066   0xD119             BNE.N    ??CAN_FilterInit_1
    372            {
    373              /* 32-bit scale for the filter */
    374              CAN1->FS1R |= filter_number_bit_pos;
   \   00000068   0x.... 0x....      LDR.W    R2,??DataTable6_3  ;; 0x4000660c
   \   0000006C   0x6812             LDR      R2,[R2, #+0]
   \   0000006E   0x430A             ORRS     R2,R1,R2
   \   00000070   0x.... 0x....      LDR.W    R3,??DataTable6_3  ;; 0x4000660c
   \   00000074   0x601A             STR      R2,[R3, #+0]
    375              /* 32-bit identifier or First 32-bit identifier */
    376              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    377                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    378                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000076   0x8802             LDRH     R2,[R0, #+0]
   \   00000078   0x8843             LDRH     R3,[R0, #+2]
   \   0000007A   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000007E   0x.... 0x....      LDR.W    R3,??DataTable6_4  ;; 0x40006640
   \   00000082   0x7A84             LDRB     R4,[R0, #+10]
   \   00000084   0xF843 0x2034      STR      R2,[R3, R4, LSL #+3]
    379              /* 32-bit mask or Second 32-bit identifier */
    380              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    381                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    382                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable6_4  ;; 0x40006640
   \   0000008C   0x7A83             LDRB     R3,[R0, #+10]
   \   0000008E   0xEB02 0x02C3      ADD      R2,R2,R3, LSL #+3
   \   00000092   0x8883             LDRH     R3,[R0, #+4]
   \   00000094   0x88C4             LDRH     R4,[R0, #+6]
   \   00000096   0xEA54 0x4303      ORRS     R3,R4,R3, LSL #+16
   \   0000009A   0x6053             STR      R3,[R2, #+4]
    383            }
    384          
    385            /* Filter Mode */
    386            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1: (+1)
   \   0000009C   0x7AC2             LDRB     R2,[R0, #+11]
   \   0000009E   0x2A00             CMP      R2,#+0
   \   000000A0   0xD107             BNE.N    ??CAN_FilterInit_2
    387            {
    388              /*Id/Mask mode for the filter*/
    389              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable6_5  ;; 0x40006604
   \   000000A6   0x6812             LDR      R2,[R2, #+0]
   \   000000A8   0x438A             BICS     R2,R2,R1
   \   000000AA   0x.... 0x....      LDR.W    R3,??DataTable6_5  ;; 0x40006604
   \   000000AE   0x601A             STR      R2,[R3, #+0]
   \   000000B0   0xE006             B.N      ??CAN_FilterInit_3
    390            }
    391            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    392            {
    393              /*Identifier list mode for the filter*/
    394              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_2: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable6_5  ;; 0x40006604
   \   000000B6   0x6812             LDR      R2,[R2, #+0]
   \   000000B8   0x430A             ORRS     R2,R1,R2
   \   000000BA   0x.... 0x....      LDR.W    R3,??DataTable6_5  ;; 0x40006604
   \   000000BE   0x601A             STR      R2,[R3, #+0]
    395            }
    396          
    397            /* Filter FIFO assignment */
    398            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
   \                     ??CAN_FilterInit_3: (+1)
   \   000000C0   0x8902             LDRH     R2,[R0, #+8]
   \   000000C2   0x2A00             CMP      R2,#+0
   \   000000C4   0xD106             BNE.N    ??CAN_FilterInit_4
    399            {
    400              /* FIFO 0 assignation for the filter */
    401              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000C6   0x.... 0x....      LDR.W    R2,??DataTable6_6  ;; 0x40006614
   \   000000CA   0x6812             LDR      R2,[R2, #+0]
   \   000000CC   0x438A             BICS     R2,R2,R1
   \   000000CE   0x.... 0x....      LDR.W    R3,??DataTable6_6  ;; 0x40006614
   \   000000D2   0x601A             STR      R2,[R3, #+0]
    402            }
    403          
    404            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
   \                     ??CAN_FilterInit_4: (+1)
   \   000000D4   0x8902             LDRH     R2,[R0, #+8]
   \   000000D6   0x2A01             CMP      R2,#+1
   \   000000D8   0xD106             BNE.N    ??CAN_FilterInit_5
    405            {
    406              /* FIFO 1 assignation for the filter */
    407              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
   \   000000DA   0x.... 0x....      LDR.W    R2,??DataTable6_6  ;; 0x40006614
   \   000000DE   0x6812             LDR      R2,[R2, #+0]
   \   000000E0   0x430A             ORRS     R2,R1,R2
   \   000000E2   0x.... 0x....      LDR.W    R3,??DataTable6_6  ;; 0x40006614
   \   000000E6   0x601A             STR      R2,[R3, #+0]
    408            }
    409            
    410            /* Filter activation */
    411            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5: (+1)
   \   000000E8   0x7B40             LDRB     R0,[R0, #+13]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xD106             BNE.N    ??CAN_FilterInit_6
    412            {
    413              CAN1->FA1R |= filter_number_bit_pos;
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x4000661c
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x4308             ORRS     R0,R1,R0
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable6_2  ;; 0x4000661c
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    414            }
    415          
    416            /* Leave the initialisation mode for the filter */
    417            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0x40006600
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x0840             LSRS     R0,R0,#+1
   \   00000104   0x0040             LSLS     R0,R0,#+1
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   0000010A   0x6008             STR      R0,[R1, #+0]
    418          }
   \   0000010C   0xBC10             POP      {R4}
   \   0000010E   0x4770             BX       LR               ;; return
    419          
    420          /**
    421            * @brief  Fills each CAN_InitStruct member with its default value.
    422            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    423            * @retval None
    424            */

   \                                 In section .text, align 2, keep-with-next
    425          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    426          {
    427            /* Reset CAN init structure parameters values */
    428            
    429            /* Initialize the time triggered communication mode */
    430            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7181             STRB     R1,[R0, #+6]
    431            
    432            /* Initialize the automatic bus-off management */
    433            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    434            
    435            /* Initialize the automatic wake-up mode */
    436            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7201             STRB     R1,[R0, #+8]
    437            
    438            /* Initialize the no automatic retransmission */
    439            CAN_InitStruct->CAN_NART = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7241             STRB     R1,[R0, #+9]
    440            
    441            /* Initialize the receive FIFO locked mode */
    442            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7281             STRB     R1,[R0, #+10]
    443            
    444            /* Initialize the transmit FIFO priority */
    445            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x72C1             STRB     R1,[R0, #+11]
    446            
    447            /* Initialize the CAN_Mode member */
    448            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7081             STRB     R1,[R0, #+2]
    449            
    450            /* Initialize the CAN_SJW member */
    451            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x70C1             STRB     R1,[R0, #+3]
    452            
    453            /* Initialize the CAN_BS1 member */
    454            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x7101             STRB     R1,[R0, #+4]
    455            
    456            /* Initialize the CAN_BS2 member */
    457            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x7141             STRB     R1,[R0, #+5]
    458            
    459            /* Initialize the CAN_Prescaler member */
    460            CAN_InitStruct->CAN_Prescaler = 1;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x8001             STRH     R1,[R0, #+0]
    461          }
   \   0000002C   0x4770             BX       LR               ;; return
    462          
    463          /**
    464            * @brief  Select the start bank filter for slave CAN.
    465            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    472            
    473            /* Enter Initialisation mode for the filter */
    474            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    475            
    476            /* Select the start slave bank */
    477            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable6_7  ;; 0xffffc0f1
   \   0000001A   0x4011             ANDS     R1,R2,R1
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   00000020   0x6011             STR      R1,[R2, #+0]
    478            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000032   0x6008             STR      R0,[R1, #+0]
    479            
    480            /* Leave Initialisation mode for the filter */
    481            CAN1->FMR &= ~FMR_FINIT;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0x40006600
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0840             LSRS     R0,R0,#+1
   \   0000003C   0x0040             LSLS     R0,R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000042   0x6008             STR      R0,[R1, #+0]
    482          }
   \   00000044   0x4770             BX       LR               ;; return
    483          
    484          /**
    485            * @brief  Enables or disables the DBG Freeze for CAN.
    486            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    487            * @param  NewState: new state of the CAN peripheral. 
    488            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    489            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    490            *          or DISABLE (CAN is working during debug).
    491            * @retval None
    492            */

   \                                 In section .text, align 2, keep-with-next
    493          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    494          {
    495            /* Check the parameters */
    496            assert_param(IS_CAN_ALL_PERIPH(CANx));
    497            assert_param(IS_FUNCTIONAL_STATE(NewState));
    498            
    499            if (NewState != DISABLE)
   \                     CAN_DBGFreeze: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??CAN_DBGFreeze_0
    500            {
    501              /* Enable Debug Freeze  */
    502              CANx->MCR |= MCR_DBF;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0xE003             B.N      ??CAN_DBGFreeze_1
    503            }
    504            else
    505            {
    506              /* Disable Debug Freeze */
    507              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0: (+1)
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   00000016   0x6001             STR      R1,[R0, #+0]
    508            }
    509          }
   \                     ??CAN_DBGFreeze_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    510          
    511          
    512          /**
    513            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    514            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    515            *         sent over the CAN bus.  
    516            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    517            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    518            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    519            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    520            *         in data byte 7. 
    521            * @retval None
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    524          {
    525            /* Check the parameters */
    526            assert_param(IS_CAN_ALL_PERIPH(CANx));
    527            assert_param(IS_FUNCTIONAL_STATE(NewState));
    528            if (NewState != DISABLE)
   \                     CAN_TTComModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD016             BEQ.N    ??CAN_TTComModeCmd_0
    529            {
    530              /* Enable the TTCM mode */
    531              CANx->MCR |= CAN_MCR_TTCM;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    532          
    533              /* Set TGT bits */
    534              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
   \   0000000E   0xF8D0 0x1184      LDR      R1,[R0, #+388]
   \   00000012   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   00000016   0xF8C0 0x1184      STR      R1,[R0, #+388]
    535              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
   \   0000001A   0xF8D0 0x1194      LDR      R1,[R0, #+404]
   \   0000001E   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   00000022   0xF8C0 0x1194      STR      R1,[R0, #+404]
    536              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
   \   00000026   0xF8D0 0x11A4      LDR      R1,[R0, #+420]
   \   0000002A   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   0000002E   0xF8C0 0x11A4      STR      R1,[R0, #+420]
   \   00000032   0xE015             B.N      ??CAN_TTComModeCmd_1
    537            }
    538            else
    539            {
    540              /* Disable the TTCM mode */
    541              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
   \                     ??CAN_TTComModeCmd_0: (+1)
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xF031 0x0180      BICS     R1,R1,#0x80
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    542          
    543              /* Reset TGT bits */
    544              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
   \   0000003C   0xF8D0 0x1184      LDR      R1,[R0, #+388]
   \   00000040   0xF431 0x7180      BICS     R1,R1,#0x100
   \   00000044   0xF8C0 0x1184      STR      R1,[R0, #+388]
    545              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
   \   00000048   0xF8D0 0x1194      LDR      R1,[R0, #+404]
   \   0000004C   0xF431 0x7180      BICS     R1,R1,#0x100
   \   00000050   0xF8C0 0x1194      STR      R1,[R0, #+404]
    546              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
   \   00000054   0xF8D0 0x11A4      LDR      R1,[R0, #+420]
   \   00000058   0xF431 0x7180      BICS     R1,R1,#0x100
   \   0000005C   0xF8C0 0x11A4      STR      R1,[R0, #+420]
    547            }
    548          }
   \                     ??CAN_TTComModeCmd_1: (+1)
   \   00000060   0x4770             BX       LR               ;; return
    549          /**
    550            * @}
    551            */
    552          
    553          
    554          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    555           *  @brief    CAN Frames Transmission functions 
    556           *
    557          @verbatim    
    558           ===============================================================================
    559                          ##### CAN Frames Transmission functions #####
    560           ===============================================================================  
    561              [..] This section provides functions allowing to 
    562                (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
    563                (+) Check the transmission status of a CAN Frame
    564                (+) Cancel a transmit request
    565             
    566          @endverbatim
    567            * @{
    568            */
    569          
    570          /**
    571            * @brief  Initiates and transmits a CAN frame message.
    572            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    573            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    574            * @retval The number of the mailbox that is used for transmission or
    575            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    578          {
   \                     CAN_Transmit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    579            uint8_t transmit_mailbox = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    580            /* Check the parameters */
    581            assert_param(IS_CAN_ALL_PERIPH(CANx));
    582            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    583            assert_param(IS_CAN_RTR(TxMessage->RTR));
    584            assert_param(IS_CAN_DLC(TxMessage->DLC));
    585          
    586            /* Select one empty transmit mailbox */
    587            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \   00000004   0x6882             LDR      R2,[R0, #+8]
   \   00000006   0x0152             LSLS     R2,R2,#+5
   \   00000008   0xD501             BPL.N    ??CAN_Transmit_0
    588            {
    589              transmit_mailbox = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xE00A             B.N      ??CAN_Transmit_1
    590            }
    591            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_0: (+1)
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0x0112             LSLS     R2,R2,#+4
   \   00000012   0xD501             BPL.N    ??CAN_Transmit_2
    592            {
    593              transmit_mailbox = 1;
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0xE005             B.N      ??CAN_Transmit_1
    594            }
    595            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_2: (+1)
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0x00D2             LSLS     R2,R2,#+3
   \   0000001C   0xD501             BPL.N    ??CAN_Transmit_3
    596            {
    597              transmit_mailbox = 2;
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0xE000             B.N      ??CAN_Transmit_1
    598            }
    599            else
    600            {
    601              transmit_mailbox = CAN_TxStatus_NoMailBox;
   \                     ??CAN_Transmit_3: (+1)
   \   00000022   0x2204             MOVS     R2,#+4
    602            }
    603          
    604            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
   \                     ??CAN_Transmit_1: (+1)
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2A04             CMP      R2,#+4
   \   00000028   0xD075             BEQ.N    ??CAN_Transmit_4
    605            {
    606              /* Set up the Id */
    607              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x0113             LSLS     R3,R2,#+4
   \   0000002E   0x4403             ADD      R3,R0,R3
   \   00000030   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000034   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x0114             LSLS     R4,R2,#+4
   \   0000003C   0x4404             ADD      R4,R0,R4
   \   0000003E   0xF8C4 0x3180      STR      R3,[R4, #+384]
    608              if (TxMessage->IDE == CAN_Id_Standard)
   \   00000042   0x7A0B             LDRB     R3,[R1, #+8]
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xD10F             BNE.N    ??CAN_Transmit_5
    609              {
    610                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    611                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    612                                                            TxMessage->RTR);
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x0113             LSLS     R3,R2,#+4
   \   0000004C   0x4403             ADD      R3,R0,R3
   \   0000004E   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000052   0x680C             LDR      R4,[R1, #+0]
   \   00000054   0x7A4D             LDRB     R5,[R1, #+9]
   \   00000056   0xEA55 0x5444      ORRS     R4,R5,R4, LSL #+21
   \   0000005A   0x4323             ORRS     R3,R4,R3
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0x0114             LSLS     R4,R2,#+4
   \   00000060   0x4404             ADD      R4,R0,R4
   \   00000062   0xF8C4 0x3180      STR      R3,[R4, #+384]
   \   00000066   0xE010             B.N      ??CAN_Transmit_6
    613              }
    614              else
    615              {
    616                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    617                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    618                                                            TxMessage->IDE | \
    619                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_5: (+1)
   \   00000068   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   0x0113             LSLS     R3,R2,#+4
   \   0000006C   0x4403             ADD      R3,R0,R3
   \   0000006E   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000072   0x684C             LDR      R4,[R1, #+4]
   \   00000074   0x7A0D             LDRB     R5,[R1, #+8]
   \   00000076   0xEA55 0x04C4      ORRS     R4,R5,R4, LSL #+3
   \   0000007A   0x7A4D             LDRB     R5,[R1, #+9]
   \   0000007C   0x432C             ORRS     R4,R5,R4
   \   0000007E   0x4323             ORRS     R3,R4,R3
   \   00000080   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   0x0114             LSLS     R4,R2,#+4
   \   00000084   0x4404             ADD      R4,R0,R4
   \   00000086   0xF8C4 0x3180      STR      R3,[R4, #+384]
    620              }
    621              
    622              /* Set up the DLC */
    623              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_6: (+1)
   \   0000008A   0x7A8B             LDRB     R3,[R1, #+10]
   \   0000008C   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   00000090   0x728B             STRB     R3,[R1, #+10]
    624              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \   00000092   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000094   0x0113             LSLS     R3,R2,#+4
   \   00000096   0x4403             ADD      R3,R0,R3
   \   00000098   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   0000009C   0x091B             LSRS     R3,R3,#+4
   \   0000009E   0x011B             LSLS     R3,R3,#+4
   \   000000A0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A2   0x0114             LSLS     R4,R2,#+4
   \   000000A4   0x4404             ADD      R4,R0,R4
   \   000000A6   0xF8C4 0x3184      STR      R3,[R4, #+388]
    625              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \   000000AA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AC   0x0113             LSLS     R3,R2,#+4
   \   000000AE   0x4403             ADD      R3,R0,R3
   \   000000B0   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   000000B4   0x7A8C             LDRB     R4,[R1, #+10]
   \   000000B6   0x4323             ORRS     R3,R4,R3
   \   000000B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BA   0x0114             LSLS     R4,R2,#+4
   \   000000BC   0x4404             ADD      R4,R0,R4
   \   000000BE   0xF8C4 0x3184      STR      R3,[R4, #+388]
    626          
    627              /* Set up the data field */
    628              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    629                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    630                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    631                                                       ((uint32_t)TxMessage->Data[0]));
   \   000000C2   0x7B8B             LDRB     R3,[R1, #+14]
   \   000000C4   0x7B4C             LDRB     R4,[R1, #+13]
   \   000000C6   0x0424             LSLS     R4,R4,#+16
   \   000000C8   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000CC   0x7B0C             LDRB     R4,[R1, #+12]
   \   000000CE   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000D2   0x7ACC             LDRB     R4,[R1, #+11]
   \   000000D4   0x4323             ORRS     R3,R4,R3
   \   000000D6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D8   0x0114             LSLS     R4,R2,#+4
   \   000000DA   0x4404             ADD      R4,R0,R4
   \   000000DC   0xF8C4 0x3188      STR      R3,[R4, #+392]
    632              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    633                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    634                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    635                                                       ((uint32_t)TxMessage->Data[4]));
   \   000000E0   0x7C8B             LDRB     R3,[R1, #+18]
   \   000000E2   0x7C4C             LDRB     R4,[R1, #+17]
   \   000000E4   0x0424             LSLS     R4,R4,#+16
   \   000000E6   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000EA   0x7C0C             LDRB     R4,[R1, #+16]
   \   000000EC   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000F0   0x7BC9             LDRB     R1,[R1, #+15]
   \   000000F2   0x4319             ORRS     R1,R1,R3
   \   000000F4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F6   0x0113             LSLS     R3,R2,#+4
   \   000000F8   0x4403             ADD      R3,R0,R3
   \   000000FA   0xF8C3 0x118C      STR      R1,[R3, #+396]
    636              /* Request transmission */
    637              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \   000000FE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000100   0x0111             LSLS     R1,R2,#+4
   \   00000102   0x4401             ADD      R1,R0,R1
   \   00000104   0xF8D1 0x1180      LDR      R1,[R1, #+384]
   \   00000108   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000010C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000010E   0x0113             LSLS     R3,R2,#+4
   \   00000110   0x4418             ADD      R0,R0,R3
   \   00000112   0xF8C0 0x1180      STR      R1,[R0, #+384]
    638            }
    639            return transmit_mailbox;
   \                     ??CAN_Transmit_4: (+1)
   \   00000116   0x0010             MOVS     R0,R2
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0xBC30             POP      {R4,R5}
   \   0000011C   0x4770             BX       LR               ;; return
    640          }
    641          
    642          /**
    643            * @brief  Checks the transmission status of a CAN Frame.
    644            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    645            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    646            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    647            *         CAN_TxStatus_Failed in an other case.
    648            */

   \                                 In section .text, align 2, keep-with-next
    649          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    650          {
    651            uint32_t state = 0;
   \                     CAN_TransmitStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    652          
    653            /* Check the parameters */
    654            assert_param(IS_CAN_ALL_PERIPH(CANx));
    655            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    656           
    657            switch (TransmitMailbox)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD003             BEQ.N    ??CAN_TransmitStatus_0
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD00D             BEQ.N    ??CAN_TransmitStatus_1
   \   0000000C   0xD306             BCC.N    ??CAN_TransmitStatus_2
   \   0000000E   0xE011             B.N      ??CAN_TransmitStatus_3
    658            {
    659              case (CAN_TXMAILBOX_0): 
    660                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
   \                     ??CAN_TransmitStatus_0: (+1)
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x4000003
   \   00000016   0xEA11 0x0200      ANDS     R2,R1,R0
    661                break;
   \   0000001A   0xE00C             B.N      ??CAN_TransmitStatus_4
    662              case (CAN_TXMAILBOX_1): 
    663                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
   \                     ??CAN_TransmitStatus_2: (+1)
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable6_9  ;; 0x8000300
   \   00000022   0xEA11 0x0200      ANDS     R2,R1,R0
    664                break;
   \   00000026   0xE006             B.N      ??CAN_TransmitStatus_4
    665              case (CAN_TXMAILBOX_2): 
    666                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
   \                     ??CAN_TransmitStatus_1: (+1)
   \   00000028   0x6880             LDR      R0,[R0, #+8]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable6_10  ;; 0x10030000
   \   0000002E   0xEA11 0x0200      ANDS     R2,R1,R0
    667                break;
   \   00000032   0xE000             B.N      ??CAN_TransmitStatus_4
    668              default:
    669                state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_3: (+1)
   \   00000034   0x2200             MOVS     R2,#+0
    670                break;
    671            }
    672            switch (state)
   \                     ??CAN_TransmitStatus_4: (+1)
   \   00000036   0x2A00             CMP      R2,#+0
   \   00000038   0xD016             BEQ.N    ??CAN_TransmitStatus_5
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable6_11  ;; 0x4000001
   \   0000003E   0x1A12             SUBS     R2,R2,R0
   \   00000040   0xD014             BEQ.N    ??CAN_TransmitStatus_6
   \   00000042   0x1E92             SUBS     R2,R2,#+2
   \   00000044   0xD018             BEQ.N    ??CAN_TransmitStatus_7
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable6_12  ;; 0x40000fd
   \   0000004A   0x1A12             SUBS     R2,R2,R0
   \   0000004C   0xD010             BEQ.N    ??CAN_TransmitStatus_8
   \   0000004E   0xF44F 0x7000      MOV      R0,#+512
   \   00000052   0x1A12             SUBS     R2,R2,R0
   \   00000054   0xD012             BEQ.N    ??CAN_TransmitStatus_9
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable6_13  ;; 0x800fd00
   \   0000005A   0x1A12             SUBS     R2,R2,R0
   \   0000005C   0xD00A             BEQ.N    ??CAN_TransmitStatus_10
   \   0000005E   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000062   0x1A12             SUBS     R2,R2,R0
   \   00000064   0xD00C             BEQ.N    ??CAN_TransmitStatus_11
   \   00000066   0xE00D             B.N      ??CAN_TransmitStatus_12
    673            {
    674                /* transmit pending  */
    675              case (0x0): state = CAN_TxStatus_Pending;
   \                     ??CAN_TransmitStatus_5: (+1)
   \   00000068   0x2202             MOVS     R2,#+2
    676                break;
   \   0000006A   0xE00C             B.N      ??CAN_TransmitStatus_13
    677                /* transmit failed  */
    678               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_6: (+1)
   \   0000006C   0x2200             MOVS     R2,#+0
    679                break;
   \   0000006E   0xE00A             B.N      ??CAN_TransmitStatus_13
    680               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_8: (+1)
   \   00000070   0x2200             MOVS     R2,#+0
    681                break;
   \   00000072   0xE008             B.N      ??CAN_TransmitStatus_13
    682               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_10: (+1)
   \   00000074   0x2200             MOVS     R2,#+0
    683                break;
   \   00000076   0xE006             B.N      ??CAN_TransmitStatus_13
    684                /* transmit succeeded  */
    685              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_7: (+1)
   \   00000078   0x2201             MOVS     R2,#+1
    686                break;
   \   0000007A   0xE004             B.N      ??CAN_TransmitStatus_13
    687              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_9: (+1)
   \   0000007C   0x2201             MOVS     R2,#+1
    688                break;
   \   0000007E   0xE002             B.N      ??CAN_TransmitStatus_13
    689              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_11: (+1)
   \   00000080   0x2201             MOVS     R2,#+1
    690                break;
   \   00000082   0xE000             B.N      ??CAN_TransmitStatus_13
    691              default: state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_12: (+1)
   \   00000084   0x2200             MOVS     R2,#+0
    692                break;
    693            }
    694            return (uint8_t) state;
   \                     ??CAN_TransmitStatus_13: (+1)
   \   00000086   0x0010             MOVS     R0,R2
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x4770             BX       LR               ;; return
    695          }
    696          
    697          /**
    698            * @brief  Cancels a transmit request.
    699            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    700            * @param  Mailbox: Mailbox number.
    701            * @retval None
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_CAN_ALL_PERIPH(CANx));
    707            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    708            /* abort transmission */
    709            switch (Mailbox)
   \                     CAN_CancelTransmit: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_CancelTransmit_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00B             BEQ.N    ??CAN_CancelTransmit_1
   \   0000000A   0xD305             BCC.N    ??CAN_CancelTransmit_2
   \   0000000C   0xE00E             B.N      ??CAN_CancelTransmit_3
    710            {
    711              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0: (+1)
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000014   0x6081             STR      R1,[R0, #+8]
    712                break;
   \   00000016   0xE009             B.N      ??CAN_CancelTransmit_4
    713              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2: (+1)
   \   00000018   0x6881             LDR      R1,[R0, #+8]
   \   0000001A   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   0000001E   0x6081             STR      R1,[R0, #+8]
    714                break;
   \   00000020   0xE004             B.N      ??CAN_CancelTransmit_4
    715              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1: (+1)
   \   00000022   0x6881             LDR      R1,[R0, #+8]
   \   00000024   0xF451 0x0100      ORRS     R1,R1,#0x800000
   \   00000028   0x6081             STR      R1,[R0, #+8]
    716                break;
   \   0000002A   0xE7FF             B.N      ??CAN_CancelTransmit_4
    717              default:
    718                break;
    719            }
    720          }
   \                     ??CAN_CancelTransmit_3: (+1)
   \                     ??CAN_CancelTransmit_4: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    721          /**
    722            * @}
    723            */
    724          
    725          
    726          /** @defgroup CAN_Group3 CAN Frames Reception functions
    727           *  @brief    CAN Frames Reception functions 
    728           *
    729          @verbatim    
    730           ===============================================================================
    731                          ##### CAN Frames Reception functions #####
    732           ===============================================================================  
    733              [..] This section provides functions allowing to 
    734                (+) Receive a correct CAN frame
    735                (+) Release a specified receive FIFO (2 FIFOs are available)
    736                (+) Return the number of the pending received CAN frames
    737             
    738          @endverbatim
    739            * @{
    740            */
    741          
    742          /**
    743            * @brief  Receives a correct CAN frame.
    744            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    745            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    746            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    747            *         CAN DLC, CAN data and FMI number.
    748            * @retval None
    749            */

   \                                 In section .text, align 2, keep-with-next
    750          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    751          {
    752            /* Check the parameters */
    753            assert_param(IS_CAN_ALL_PERIPH(CANx));
    754            assert_param(IS_CAN_FIFO(FIFONumber));
    755            /* Get the Id */
    756            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     CAN_Receive: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x010B             LSLS     R3,R1,#+4
   \   00000004   0x4403             ADD      R3,R0,R3
   \   00000006   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   0000000A   0xF013 0x0304      ANDS     R3,R3,#0x4
   \   0000000E   0x7213             STRB     R3,[R2, #+8]
    757            if (RxMessage->IDE == CAN_Id_Standard)
   \   00000010   0x7A13             LDRB     R3,[R2, #+8]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD107             BNE.N    ??CAN_Receive_0
    758            {
    759              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x010B             LSLS     R3,R1,#+4
   \   0000001A   0x4403             ADD      R3,R0,R3
   \   0000001C   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000020   0x0D5B             LSRS     R3,R3,#+21
   \   00000022   0x6013             STR      R3,[R2, #+0]
   \   00000024   0xE006             B.N      ??CAN_Receive_1
    760            }
    761            else
    762            {
    763              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0: (+1)
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x010B             LSLS     R3,R1,#+4
   \   0000002A   0x4403             ADD      R3,R0,R3
   \   0000002C   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000030   0x08DB             LSRS     R3,R3,#+3
   \   00000032   0x6053             STR      R3,[R2, #+4]
    764            }
    765            
    766            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x010B             LSLS     R3,R1,#+4
   \   00000038   0x4403             ADD      R3,R0,R3
   \   0000003A   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   0000003E   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000042   0x7253             STRB     R3,[R2, #+9]
    767            /* Get the DLC */
    768            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x010B             LSLS     R3,R1,#+4
   \   00000048   0x4403             ADD      R3,R0,R3
   \   0000004A   0xF8D3 0x31B4      LDR      R3,[R3, #+436]
   \   0000004E   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   00000052   0x7293             STRB     R3,[R2, #+10]
    769            /* Get the FMI */
    770            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0x010B             LSLS     R3,R1,#+4
   \   00000058   0x4403             ADD      R3,R0,R3
   \   0000005A   0xF8D3 0x31B4      LDR      R3,[R3, #+436]
   \   0000005E   0x0A1B             LSRS     R3,R3,#+8
   \   00000060   0x74D3             STRB     R3,[R2, #+19]
    771            /* Get the data field */
    772            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x010B             LSLS     R3,R1,#+4
   \   00000066   0x4403             ADD      R3,R0,R3
   \   00000068   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   0000006C   0x72D3             STRB     R3,[R2, #+11]
    773            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x010B             LSLS     R3,R1,#+4
   \   00000072   0x4403             ADD      R3,R0,R3
   \   00000074   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000078   0x0A1B             LSRS     R3,R3,#+8
   \   0000007A   0x7313             STRB     R3,[R2, #+12]
    774            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0x010B             LSLS     R3,R1,#+4
   \   00000080   0x4403             ADD      R3,R0,R3
   \   00000082   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000086   0x0C1B             LSRS     R3,R3,#+16
   \   00000088   0x7353             STRB     R3,[R2, #+13]
    775            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x010B             LSLS     R3,R1,#+4
   \   0000008E   0x4403             ADD      R3,R0,R3
   \   00000090   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000094   0x0E1B             LSRS     R3,R3,#+24
   \   00000096   0x7393             STRB     R3,[R2, #+14]
    776            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0x010B             LSLS     R3,R1,#+4
   \   0000009C   0x4403             ADD      R3,R0,R3
   \   0000009E   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000A2   0x73D3             STRB     R3,[R2, #+15]
    777            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0x010B             LSLS     R3,R1,#+4
   \   000000A8   0x4403             ADD      R3,R0,R3
   \   000000AA   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000AE   0x0A1B             LSRS     R3,R3,#+8
   \   000000B0   0x7413             STRB     R3,[R2, #+16]
    778            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   000000B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B4   0x010B             LSLS     R3,R1,#+4
   \   000000B6   0x4403             ADD      R3,R0,R3
   \   000000B8   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000BC   0x0C1B             LSRS     R3,R3,#+16
   \   000000BE   0x7453             STRB     R3,[R2, #+17]
    779            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   000000C0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C2   0x010B             LSLS     R3,R1,#+4
   \   000000C4   0x4403             ADD      R3,R0,R3
   \   000000C6   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000CA   0x0E1B             LSRS     R3,R3,#+24
   \   000000CC   0x7493             STRB     R3,[R2, #+18]
    780            /* Release the FIFO */
    781            /* Release FIFO0 */
    782            if (FIFONumber == CAN_FIFO0)
   \   000000CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D0   0x2900             CMP      R1,#+0
   \   000000D2   0xD104             BNE.N    ??CAN_Receive_2
    783            {
    784              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   000000D4   0x68C1             LDR      R1,[R0, #+12]
   \   000000D6   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   000000DA   0x60C1             STR      R1,[R0, #+12]
   \   000000DC   0xE003             B.N      ??CAN_Receive_3
    785            }
    786            /* Release FIFO1 */
    787            else /* FIFONumber == CAN_FIFO1 */
    788            {
    789              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_2: (+1)
   \   000000DE   0x6901             LDR      R1,[R0, #+16]
   \   000000E0   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   000000E4   0x6101             STR      R1,[R0, #+16]
    790            }
    791          }
   \                     ??CAN_Receive_3: (+1)
   \   000000E6   0x4770             BX       LR               ;; return
    792          
    793          /**
    794            * @brief  Releases the specified receive FIFO.
    795            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    796            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    797            * @retval None
    798            */

   \                                 In section .text, align 2, keep-with-next
    799          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    800          {
    801            /* Check the parameters */
    802            assert_param(IS_CAN_ALL_PERIPH(CANx));
    803            assert_param(IS_CAN_FIFO(FIFONumber));
    804            /* Release FIFO0 */
    805            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD104             BNE.N    ??CAN_FIFORelease_0
    806            {
    807              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0xE003             B.N      ??CAN_FIFORelease_1
    808            }
    809            /* Release FIFO1 */
    810            else /* FIFONumber == CAN_FIFO1 */
    811            {
    812              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0: (+1)
   \   00000010   0x6901             LDR      R1,[R0, #+16]
   \   00000012   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000016   0x6101             STR      R1,[R0, #+16]
    813            }
    814          }
   \                     ??CAN_FIFORelease_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    815          
    816          /**
    817            * @brief  Returns the number of pending received messages.
    818            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    819            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    820            * @retval NbMessage : which is the number of pending message.
    821            */

   \                                 In section .text, align 2, keep-with-next
    822          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    823          {
    824            uint8_t message_pending=0;
   \                     CAN_MessagePending: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    825            /* Check the parameters */
    826            assert_param(IS_CAN_ALL_PERIPH(CANx));
    827            assert_param(IS_CAN_FIFO(FIFONumber));
    828            if (FIFONumber == CAN_FIFO0)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD103             BNE.N    ??CAN_MessagePending_0
    829            {
    830              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0xF010 0x0203      ANDS     R2,R0,#0x3
   \   0000000E   0xE007             B.N      ??CAN_MessagePending_1
    831            }
    832            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD103             BNE.N    ??CAN_MessagePending_2
    833            {
    834              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0xF010 0x0203      ANDS     R2,R0,#0x3
   \   0000001C   0xE000             B.N      ??CAN_MessagePending_1
    835            }
    836            else
    837            {
    838              message_pending = 0;
   \                     ??CAN_MessagePending_2: (+1)
   \   0000001E   0x2200             MOVS     R2,#+0
    839            }
    840            return message_pending;
   \                     ??CAN_MessagePending_1: (+1)
   \   00000020   0x0010             MOVS     R0,R2
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x4770             BX       LR               ;; return
    841          }
    842          /**
    843            * @}
    844            */
    845          
    846          
    847          /** @defgroup CAN_Group4 CAN Operation modes functions
    848           *  @brief    CAN Operation modes functions 
    849           *
    850          @verbatim    
    851           ===============================================================================
    852                              ##### CAN Operation modes functions #####
    853           ===============================================================================  
    854              [..] This section provides functions allowing to select the CAN Operation modes
    855                (+) sleep mode
    856                (+) normal mode 
    857                (+) initialization mode
    858             
    859          @endverbatim
    860            * @{
    861            */
    862            
    863            
    864          /**
    865            * @brief  Selects the CAN Operation mode.
    866            * @param  CAN_OperatingMode: CAN Operating Mode.
    867            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    868            * @retval status of the requested mode which can be 
    869            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    870            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    871            */

   \                                 In section .text, align 2, keep-with-next
    872          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    873          {
   \                     CAN_OperatingModeRequest: (+1)
   \   00000000   0x000A             MOVS     R2,R1
    874            uint8_t status = CAN_ModeStatus_Failed;
   \   00000002   0x2100             MOVS     R1,#+0
    875            
    876            /* Timeout for INAK or also for SLAK bits*/
    877            uint32_t timeout = INAK_TIMEOUT; 
   \   00000004   0xF64F 0x71FF      MOVW     R1,#+65535
    878          
    879            /* Check the parameters */
    880            assert_param(IS_CAN_ALL_PERIPH(CANx));
    881            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    882          
    883            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD117             BNE.N    ??CAN_OperatingModeRequest_0
    884            {
    885              /* Request initialisation */
    886              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0xF032 0x0202      BICS     R2,R2,#0x2
   \   00000014   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE000             B.N      ??CAN_OperatingModeRequest_1
    887          
    888              /* Wait the acknowledge */
    889              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    890              {
    891                timeout--;
   \                     ??CAN_OperatingModeRequest_2: (+1)
   \   0000001C   0x1E49             SUBS     R1,R1,#+1
    892              }
   \                     ??CAN_OperatingModeRequest_1: (+1)
   \   0000001E   0x6842             LDR      R2,[R0, #+4]
   \   00000020   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000024   0x2A01             CMP      R2,#+1
   \   00000026   0xD001             BEQ.N    ??CAN_OperatingModeRequest_3
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD1F7             BNE.N    ??CAN_OperatingModeRequest_2
    893              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
   \                     ??CAN_OperatingModeRequest_3: (+1)
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD001             BEQ.N    ??CAN_OperatingModeRequest_4
    894              {
    895                status = CAN_ModeStatus_Failed;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xE034             B.N      ??CAN_OperatingModeRequest_5
    896              }
    897              else
    898              {
    899                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_4: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xE032             B.N      ??CAN_OperatingModeRequest_5
    900              }
    901            }
    902            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
   \                     ??CAN_OperatingModeRequest_0: (+1)
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x2A01             CMP      R2,#+1
   \   00000042   0xD113             BNE.N    ??CAN_OperatingModeRequest_6
    903            {
    904              /* Request leave initialisation and sleep mode  and enter Normal mode */
    905              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
   \   00000044   0x6802             LDR      R2,[R0, #+0]
   \   00000046   0x0892             LSRS     R2,R2,#+2
   \   00000048   0x0092             LSLS     R2,R2,#+2
   \   0000004A   0x6002             STR      R2,[R0, #+0]
   \   0000004C   0xE000             B.N      ??CAN_OperatingModeRequest_7
    906          
    907              /* Wait the acknowledge */
    908              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    909              {
    910                timeout--;
   \                     ??CAN_OperatingModeRequest_8: (+1)
   \   0000004E   0x1E49             SUBS     R1,R1,#+1
    911              }
   \                     ??CAN_OperatingModeRequest_7: (+1)
   \   00000050   0x6842             LDR      R2,[R0, #+4]
   \   00000052   0xF012 0x0F03      TST      R2,#0x3
   \   00000056   0xD001             BEQ.N    ??CAN_OperatingModeRequest_9
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD1F8             BNE.N    ??CAN_OperatingModeRequest_8
    912              if ((CANx->MSR & CAN_MODE_MASK) != 0)
   \                     ??CAN_OperatingModeRequest_9: (+1)
   \   0000005C   0x6840             LDR      R0,[R0, #+4]
   \   0000005E   0xF010 0x0F03      TST      R0,#0x3
   \   00000062   0xD001             BEQ.N    ??CAN_OperatingModeRequest_10
    913              {
    914                status = CAN_ModeStatus_Failed;
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xE01D             B.N      ??CAN_OperatingModeRequest_5
    915              }
    916              else
    917              {
    918                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_10: (+1)
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xE01B             B.N      ??CAN_OperatingModeRequest_5
    919              }
    920            }
    921            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
   \                     ??CAN_OperatingModeRequest_6: (+1)
   \   0000006C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   0x2A02             CMP      R2,#+2
   \   00000070   0xD117             BNE.N    ??CAN_OperatingModeRequest_11
    922            {
    923              /* Request Sleep mode */
    924              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000072   0x6802             LDR      R2,[R0, #+0]
   \   00000074   0x0852             LSRS     R2,R2,#+1
   \   00000076   0x0052             LSLS     R2,R2,#+1
   \   00000078   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000007C   0x6002             STR      R2,[R0, #+0]
   \   0000007E   0xE000             B.N      ??CAN_OperatingModeRequest_12
    925          
    926              /* Wait the acknowledge */
    927              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    928              {
    929                timeout--;
   \                     ??CAN_OperatingModeRequest_13: (+1)
   \   00000080   0x1E49             SUBS     R1,R1,#+1
    930              }
   \                     ??CAN_OperatingModeRequest_12: (+1)
   \   00000082   0x6842             LDR      R2,[R0, #+4]
   \   00000084   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000088   0x2A02             CMP      R2,#+2
   \   0000008A   0xD001             BEQ.N    ??CAN_OperatingModeRequest_14
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD1F7             BNE.N    ??CAN_OperatingModeRequest_13
    931              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
   \                     ??CAN_OperatingModeRequest_14: (+1)
   \   00000090   0x6840             LDR      R0,[R0, #+4]
   \   00000092   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000096   0x2802             CMP      R0,#+2
   \   00000098   0xD001             BEQ.N    ??CAN_OperatingModeRequest_15
    932              {
    933                status = CAN_ModeStatus_Failed;
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0xE002             B.N      ??CAN_OperatingModeRequest_5
    934              }
    935              else
    936              {
    937                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_15: (+1)
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0xE000             B.N      ??CAN_OperatingModeRequest_5
    938              }
    939            }
    940            else
    941            {
    942              status = CAN_ModeStatus_Failed;
   \                     ??CAN_OperatingModeRequest_11: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
    943            }
    944          
    945            return  (uint8_t) status;
   \                     ??CAN_OperatingModeRequest_5: (+1)
   \   000000A4   0x0008             MOVS     R0,R1
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x4770             BX       LR               ;; return
    946          }
    947          
    948          /**
    949            * @brief  Enters the Sleep (low power) mode.
    950            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    951            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    952            */

   \                                 In section .text, align 2, keep-with-next
    953          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    954          {
    955            uint8_t sleepstatus = CAN_Sleep_Failed;
   \                     CAN_Sleep: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    956            
    957            /* Check the parameters */
    958            assert_param(IS_CAN_ALL_PERIPH(CANx));
    959              
    960            /* Request Sleep mode */
    961             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    962             
    963            /* Sleep mode status */
    964            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD100             BNE.N    ??CAN_Sleep_0
    965            {
    966              /* Sleep mode not entered */
    967              sleepstatus =  CAN_Sleep_Ok;
   \   00000018   0x2101             MOVS     R1,#+1
    968            }
    969            /* return sleep mode status */
    970             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_0: (+1)
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x4770             BX       LR               ;; return
    971          }
    972          
    973          /**
    974            * @brief  Wakes up the CAN peripheral from sleep mode .
    975            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    976            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    977            */

   \                                 In section .text, align 2, keep-with-next
    978          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    979          {
    980            uint32_t wait_slak = SLAK_TIMEOUT;
   \                     CAN_WakeUp: (+1)
   \   00000000   0xF64F 0x72FF      MOVW     R2,#+65535
    981            uint8_t wakeupstatus = CAN_WakeUp_Failed;
   \   00000004   0x2100             MOVS     R1,#+0
    982            
    983            /* Check the parameters */
    984            assert_param(IS_CAN_ALL_PERIPH(CANx));
    985              
    986            /* Wake up request */
    987            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0xF033 0x0302      BICS     R3,R3,#0x2
   \   0000000C   0x6003             STR      R3,[R0, #+0]
   \   0000000E   0xE000             B.N      ??CAN_WakeUp_0
    988              
    989            /* Sleep mode status */
    990            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    991            {
    992             wait_slak--;
   \                     ??CAN_WakeUp_1: (+1)
   \   00000010   0x1E52             SUBS     R2,R2,#+1
    993            }
   \                     ??CAN_WakeUp_0: (+1)
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x079B             LSLS     R3,R3,#+30
   \   00000016   0xD501             BPL.N    ??CAN_WakeUp_2
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD1F9             BNE.N    ??CAN_WakeUp_1
    994            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2: (+1)
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x0780             LSLS     R0,R0,#+30
   \   00000020   0xD400             BMI.N    ??CAN_WakeUp_3
    995            {
    996             /* wake up done : Sleep mode exited */
    997              wakeupstatus = CAN_WakeUp_Ok;
   \   00000022   0x2101             MOVS     R1,#+1
    998            }
    999            /* return wakeup status */
   1000            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_3: (+1)
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x4770             BX       LR               ;; return
   1001          }
   1002          /**
   1003            * @}
   1004            */
   1005          
   1006          
   1007          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1008           *  @brief    CAN Bus Error management functions 
   1009           *
   1010          @verbatim    
   1011           ===============================================================================
   1012                          ##### CAN Bus Error management functions #####
   1013           ===============================================================================  
   1014              [..] This section provides functions allowing to 
   1015                (+) Return the CANx's last error code (LEC)
   1016                (+) Return the CANx Receive Error Counter (REC)
   1017                (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1018             
   1019                -@- If TEC is greater than 255, The CAN is in bus-off state.
   1020                -@- if REC or TEC are greater than 96, an Error warning flag occurs.
   1021                -@- if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1022                                  
   1023          @endverbatim
   1024            * @{
   1025            */
   1026            
   1027          /**
   1028            * @brief  Returns the CANx's last error code (LEC).
   1029            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1030            * @retval Error code: 
   1031            *          - CAN_ERRORCODE_NoErr: No Error  
   1032            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1033            *          - CAN_ERRORCODE_FormErr: Form Error
   1034            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1035            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1036            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1037            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1038            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1039            */

   \                                 In section .text, align 2, keep-with-next
   1040          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1041          {
   1042            uint8_t errorcode=0;
   \                     CAN_GetLastErrorCode: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1043            
   1044            /* Check the parameters */
   1045            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1046            
   1047            /* Get the error code*/
   1048            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0xF010 0x0170      ANDS     R1,R0,#0x70
   1049            
   1050            /* Return the error code*/
   1051            return errorcode;
   \   00000008   0x0008             MOVS     R0,R1
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x4770             BX       LR               ;; return
   1052          }
   1053          
   1054          /**
   1055            * @brief  Returns the CANx Receive Error Counter (REC).
   1056            * @note   In case of an error during reception, this counter is incremented 
   1057            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1058            *         standard. After every successful reception, the counter is 
   1059            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1060            *         When the counter value exceeds 127, the CAN controller enters the 
   1061            *         error passive state.  
   1062            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1063            * @retval CAN Receive Error Counter. 
   1064            */

   \                                 In section .text, align 2, keep-with-next
   1065          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1066          {
   1067            uint8_t counter=0;
   \                     CAN_GetReceiveErrorCounter: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1068            
   1069            /* Check the parameters */
   1070            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1071            
   1072            /* Get the Receive Error Counter*/
   1073            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x0E01             LSRS     R1,R0,#+24
   1074            
   1075            /* Return the Receive Error Counter*/
   1076            return counter;
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x4770             BX       LR               ;; return
   1077          }
   1078          
   1079          
   1080          /**
   1081            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1082            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1083            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1084            */

   \                                 In section .text, align 2, keep-with-next
   1085          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1086          {
   1087            uint8_t counter=0;
   \                     CAN_GetLSBTransmitErrorCounter: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1088            
   1089            /* Check the parameters */
   1090            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1091            
   1092            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1093            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x0C01             LSRS     R1,R0,#+16
   1094            
   1095            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1096            return counter;
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x4770             BX       LR               ;; return
   1097          }
   1098          /**
   1099            * @}
   1100            */
   1101          
   1102          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1103           *  @brief   Interrupts and flags management functions
   1104           *
   1105          @verbatim   
   1106           ===============================================================================
   1107                        ##### Interrupts and flags management functions #####
   1108           ===============================================================================  
   1109          
   1110               [..] This section provides functions allowing to configure the CAN Interrupts 
   1111                    and to get the status and clear flags and Interrupts pending bits.
   1112            
   1113                    The CAN provides 14 Interrupts sources and 15 Flags:
   1114          
   1115             
   1116            *** Flags ***
   1117            =============
   1118              [..] The 15 flags can be divided on 4 groups: 
   1119          
   1120                (+) Transmit Flags
   1121                  (++) CAN_FLAG_RQCP0, 
   1122                  (++) CAN_FLAG_RQCP1, 
   1123                  (++) CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1124                                         Set when when the last request (transmit or abort)
   1125                                         has been performed. 
   1126          
   1127                (+) Receive Flags
   1128          
   1129          
   1130                  (++) CAN_FLAG_FMP0,
   1131                  (++) CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1132                                         set to signal that messages are pending in the receive 
   1133                                         FIFO.
   1134                                         These Flags are cleared only by hardware. 
   1135          
   1136                  (++) CAN_FLAG_FF0,
   1137                  (++) CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1138                                         set when three messages are stored in the selected 
   1139                                         FIFO.                        
   1140          
   1141                  (++) CAN_FLAG_FOV0              
   1142                  (++) CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1143                                         set when a new message has been received and passed 
   1144                                         the filter while the FIFO was full.         
   1145          
   1146                (+) Operating Mode Flags
   1147          
   1148                  (++) CAN_FLAG_WKU    : Wake up Flag
   1149                                         set to signal that a SOF bit has been detected while 
   1150                                         the CAN hardware was in Sleep mode. 
   1151                  
   1152                  (++) CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1153                                         Set to signal that the CAN has entered Sleep Mode. 
   1154              
   1155                (+) Error Flags
   1156          
   1157                  (++) CAN_FLAG_EWG    : Error Warning Flag
   1158                                         Set when the warning limit has been reached (Receive 
   1159                                         Error Counter or Transmit Error Counter greater than 96). 
   1160                                         This Flag is cleared only by hardware.
   1161                                      
   1162                  (++) CAN_FLAG_EPV    : Error Passive Flag
   1163                                         Set when the Error Passive limit has been reached 
   1164                                         (Receive Error Counter or Transmit Error Counter 
   1165                                         greater than 127).
   1166                                         This Flag is cleared only by hardware.
   1167                                       
   1168                  (++) CAN_FLAG_BOF    : Bus-Off Flag
   1169                                         set when CAN enters the bus-off state. The bus-off 
   1170                                         state is entered on TEC overflow, greater than 255.
   1171                                         This Flag is cleared only by hardware.
   1172                                             
   1173                  (++) CAN_FLAG_LEC    : Last error code Flag
   1174                                         set If a message has been transferred (reception or
   1175                                         transmission) with error, and the error code is hold.              
   1176                                     
   1177            *** Interrupts ***
   1178            ==================
   1179              [..] The 14 interrupts can be divided on 4 groups: 
   1180            
   1181                (+) Transmit interrupt
   1182            
   1183                  (++) CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1184                                       if enabled, this interrupt source is pending when 
   1185                                       no transmit request are pending for Tx mailboxes.      
   1186          
   1187                (+) Receive Interrupts
   1188                   
   1189                  (++) CAN_IT_FMP0,
   1190                  (++) CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1191                                         if enabled, these interrupt sources are pending 
   1192                                         when messages are pending in the receive FIFO.
   1193                                         The corresponding interrupt pending bits are cleared 
   1194                                         only by hardware.
   1195                          
   1196                  (++) CAN_IT_FF0,              
   1197                  (++) CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1198                                         if enabled, these interrupt sources are pending 
   1199                                         when three messages are stored in the selected FIFO.
   1200                  
   1201                  (++) CAN_IT_FOV0,        
   1202                  (++) CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1203                                         if enabled, these interrupt sources are pending 
   1204                                         when a new message has been received and passed 
   1205                                         the filter while the FIFO was full.
   1206          
   1207                (+) Operating Mode Interrupts
   1208                   
   1209                  (++) CAN_IT_WKU     :  Wake-up Interrupt
   1210                                         if enabled, this interrupt source is pending when 
   1211                                         a SOF bit has been detected while the CAN hardware 
   1212                                         was in Sleep mode.
   1213                                            
   1214                  (++) CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1215                                         if enabled, this interrupt source is pending when 
   1216                                         the CAN has entered Sleep Mode.       
   1217          
   1218                (+) Error Interrupts 
   1219                  
   1220                  (++) CAN_IT_EWG     :  Error warning Interrupt 
   1221                                         if enabled, this interrupt source is pending when
   1222                                         the warning limit has been reached (Receive Error 
   1223                                         Counter or Transmit Error Counter=96). 
   1224                                         
   1225                  (++) CAN_IT_EPV     :  Error passive Interrupt        
   1226                                         if enabled, this interrupt source is pending when
   1227                                         the Error Passive limit has been reached (Receive 
   1228                                         Error Counter or Transmit Error Counter>127).
   1229                                    
   1230                  (++) CAN_IT_BOF     :  Bus-off Interrupt
   1231                                         if enabled, this interrupt source is pending when
   1232                                         CAN enters the bus-off state. The bus-off state is 
   1233                                         entered on TEC overflow, greater than 255.
   1234                                         This Flag is cleared only by hardware.
   1235                                            
   1236                  (++) CAN_IT_LEC     :  Last error code Interrupt        
   1237                                         if enabled, this interrupt source is pending  when
   1238                                         a message has been transferred (reception or
   1239                                         transmission) with error, and the error code is hold.
   1240                                    
   1241                  (++) CAN_IT_ERR     :  Error Interrupt
   1242                                         if enabled, this interrupt source is pending when 
   1243                                         an error condition is pending.      
   1244                                
   1245              [..] Managing the CAN controller events :
   1246           
   1247                   The user should identify which mode will be used in his application to 
   1248                   manage the CAN controller events: Polling mode or Interrupt mode.
   1249            
   1250                (#) In the Polling Mode it is advised to use the following functions:
   1251                  (++) CAN_GetFlagStatus() : to check if flags events occur. 
   1252                  (++) CAN_ClearFlag()     : to clear the flags events.
   1253            
   1254          
   1255            
   1256                (#) In the Interrupt Mode it is advised to use the following functions:
   1257                  (++) CAN_ITConfig()       : to enable or disable the interrupt source.
   1258                  (++) CAN_GetITStatus()    : to check if Interrupt occurs.
   1259                  (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1260                      (corresponding Flag).
   1261                  -@@-  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1262                       pending bits since there are cleared only by hardware. 
   1263            
   1264          @endverbatim
   1265            * @{
   1266            */ 
   1267          /**
   1268            * @brief  Enables or disables the specified CANx interrupts.
   1269            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1270            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1271            *          This parameter can be: 
   1272            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1273            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1274            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1275            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1276            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1277            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1278            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1279            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1280            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1281            *            @arg CAN_IT_EWG: Error warning Interrupt
   1282            *            @arg CAN_IT_EPV: Error passive Interrupt
   1283            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1284            *            @arg CAN_IT_LEC: Last error code Interrupt
   1285            *            @arg CAN_IT_ERR: Error Interrupt
   1286            * @param  NewState: new state of the CAN interrupts.
   1287            *          This parameter can be: ENABLE or DISABLE.
   1288            * @retval None
   1289            */

   \                                 In section .text, align 2, keep-with-next
   1290          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1291          {
   1292            /* Check the parameters */
   1293            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1294            assert_param(IS_CAN_IT(CAN_IT));
   1295            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1296          
   1297            if (NewState != DISABLE)
   \                     CAN_ITConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_ITConfig_0
   1298            {
   1299              /* Enable the selected CANx interrupt */
   1300              CANx->IER |= CAN_IT;
   \   00000006   0x6942             LDR      R2,[R0, #+20]
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6141             STR      R1,[R0, #+20]
   \   0000000C   0xE003             B.N      ??CAN_ITConfig_1
   1301            }
   1302            else
   1303            {
   1304              /* Disable the selected CANx interrupt */
   1305              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0: (+1)
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   \   00000010   0xEA32 0x0101      BICS     R1,R2,R1
   \   00000014   0x6141             STR      R1,[R0, #+20]
   1306            }
   1307          }
   \                     ??CAN_ITConfig_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
   1308          /**
   1309            * @brief  Checks whether the specified CAN flag is set or not.
   1310            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1311            * @param  CAN_FLAG: specifies the flag to check.
   1312            *          This parameter can be one of the following values:
   1313            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1314            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1315            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1316            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1317            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1318            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1319            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1320            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1321            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1322            *            @arg CAN_FLAG_WKU: Wake up Flag
   1323            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1324            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1325            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1326            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1327            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1328            * @retval The new state of CAN_FLAG (SET or RESET).
   1329            */

   \                                 In section .text, align 2, keep-with-next
   1330          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1331          {
   1332            FlagStatus bitstatus = RESET;
   \                     CAN_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1333            
   1334            /* Check the parameters */
   1335            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1336            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1337            
   1338          
   1339            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \   00000002   0xF411 0x0F70      TST      R1,#0xF00000
   \   00000006   0xD007             BEQ.N    ??CAN_GetFlagStatus_0
   1340            { 
   1341              /* Check the status of the specified CAN flag */
   1342              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000008   0x6980             LDR      R0,[R0, #+24]
   \   0000000A   0x4008             ANDS     R0,R1,R0
   \   0000000C   0x0300             LSLS     R0,R0,#+12
   \   0000000E   0xD001             BEQ.N    ??CAN_GetFlagStatus_1
   1343              { 
   1344                /* CAN_FLAG is set */
   1345                bitstatus = SET;
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0xE026             B.N      ??CAN_GetFlagStatus_2
   1346              }
   1347              else
   1348              { 
   1349                /* CAN_FLAG is reset */
   1350                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_1: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xE024             B.N      ??CAN_GetFlagStatus_2
   1351              }
   1352            }
   1353            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_0: (+1)
   \   00000018   0x01CA             LSLS     R2,R1,#+7
   \   0000001A   0xD507             BPL.N    ??CAN_GetFlagStatus_3
   1354            { 
   1355              /* Check the status of the specified CAN flag */
   1356              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x4008             ANDS     R0,R1,R0
   \   00000020   0x0300             LSLS     R0,R0,#+12
   \   00000022   0xD001             BEQ.N    ??CAN_GetFlagStatus_4
   1357              { 
   1358                /* CAN_FLAG is set */
   1359                bitstatus = SET;
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xE01C             B.N      ??CAN_GetFlagStatus_2
   1360              }
   1361              else
   1362              { 
   1363                /* CAN_FLAG is reset */
   1364                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_4: (+1)
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xE01A             B.N      ??CAN_GetFlagStatus_2
   1365              }
   1366            }
   1367            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_3: (+1)
   \   0000002C   0x010A             LSLS     R2,R1,#+4
   \   0000002E   0xD507             BPL.N    ??CAN_GetFlagStatus_5
   1368            { 
   1369              /* Check the status of the specified CAN flag */
   1370              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0x4008             ANDS     R0,R1,R0
   \   00000034   0x0300             LSLS     R0,R0,#+12
   \   00000036   0xD001             BEQ.N    ??CAN_GetFlagStatus_6
   1371              { 
   1372                /* CAN_FLAG is set */
   1373                bitstatus = SET;
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xE012             B.N      ??CAN_GetFlagStatus_2
   1374              }
   1375              else
   1376              { 
   1377                /* CAN_FLAG is reset */
   1378                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_6: (+1)
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xE010             B.N      ??CAN_GetFlagStatus_2
   1379              }
   1380            }
   1381            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_5: (+1)
   \   00000040   0x018A             LSLS     R2,R1,#+6
   \   00000042   0xD507             BPL.N    ??CAN_GetFlagStatus_7
   1382            { 
   1383              /* Check the status of the specified CAN flag */
   1384              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0x4008             ANDS     R0,R1,R0
   \   00000048   0x0300             LSLS     R0,R0,#+12
   \   0000004A   0xD001             BEQ.N    ??CAN_GetFlagStatus_8
   1385              { 
   1386                /* CAN_FLAG is set */
   1387                bitstatus = SET;
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0xE008             B.N      ??CAN_GetFlagStatus_2
   1388              }
   1389              else
   1390              { 
   1391                /* CAN_FLAG is reset */
   1392                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_8: (+1)
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0xE006             B.N      ??CAN_GetFlagStatus_2
   1393              }
   1394            }
   1395            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1396            { 
   1397              /* Check the status of the specified CAN flag */
   1398              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_7: (+1)
   \   00000054   0x6900             LDR      R0,[R0, #+16]
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x0300             LSLS     R0,R0,#+12
   \   0000005A   0xD001             BEQ.N    ??CAN_GetFlagStatus_9
   1399              { 
   1400                /* CAN_FLAG is set */
   1401                bitstatus = SET;
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0xE000             B.N      ??CAN_GetFlagStatus_2
   1402              }
   1403              else
   1404              { 
   1405                /* CAN_FLAG is reset */
   1406                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_9: (+1)
   \   00000060   0x2200             MOVS     R2,#+0
   1407              }
   1408            }
   1409            /* Return the CAN_FLAG status */
   1410            return  bitstatus;
   \                     ??CAN_GetFlagStatus_2: (+1)
   \   00000062   0x0010             MOVS     R0,R2
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x4770             BX       LR               ;; return
   1411          }
   1412          
   1413          /**
   1414            * @brief  Clears the CAN's pending flags.
   1415            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1416            * @param  CAN_FLAG: specifies the flag to clear.
   1417            *          This parameter can be one of the following values:
   1418            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1419            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1420            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1421            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1422            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1423            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1424            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1425            *            @arg CAN_FLAG_WKU: Wake up Flag
   1426            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1427            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1428            * @retval None
   1429            */

   \                                 In section .text, align 2, keep-with-next
   1430          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1431          {
   1432            uint32_t flagtmp=0;
   \                     CAN_ClearFlag: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1433            /* Check the parameters */
   1434            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1435            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1436            
   1437            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \   00000002   0x....             LDR.N    R2,??DataTable6_14  ;; 0x30f00070
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0xD102             BNE.N    ??CAN_ClearFlag_0
   1438            {
   1439              /* Clear the selected CAN flags */
   1440              CANx->ESR = (uint32_t)RESET;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6181             STR      R1,[R0, #+24]
   \   0000000C   0xE00E             B.N      ??CAN_ClearFlag_1
   1441            }
   1442            else /* MSR or TSR or RF0R or RF1R */
   1443            {
   1444              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_0: (+1)
   \   0000000E   0x030A             LSLS     R2,R1,#+12       ;; ZeroExtS R2,R1,#+12,#+12
   \   00000010   0x0B12             LSRS     R2,R2,#+12
   1445          
   1446              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \   00000012   0x018B             LSLS     R3,R1,#+6
   \   00000014   0xD501             BPL.N    ??CAN_ClearFlag_2
   1447              {
   1448                /* Receive Flags */
   1449                CANx->RF0R = (uint32_t)(flagtmp);
   \   00000016   0x60C2             STR      R2,[R0, #+12]
   \   00000018   0xE008             B.N      ??CAN_ClearFlag_1
   1450              }
   1451              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_2: (+1)
   \   0000001A   0x014B             LSLS     R3,R1,#+5
   \   0000001C   0xD501             BPL.N    ??CAN_ClearFlag_3
   1452              {
   1453                /* Receive Flags */
   1454                CANx->RF1R = (uint32_t)(flagtmp);
   \   0000001E   0x6102             STR      R2,[R0, #+16]
   \   00000020   0xE004             B.N      ??CAN_ClearFlag_1
   1455              }
   1456              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_3: (+1)
   \   00000022   0x0109             LSLS     R1,R1,#+4
   \   00000024   0xD501             BPL.N    ??CAN_ClearFlag_4
   1457              {
   1458                /* Transmit Flags */
   1459                CANx->TSR = (uint32_t)(flagtmp);
   \   00000026   0x6082             STR      R2,[R0, #+8]
   \   00000028   0xE000             B.N      ??CAN_ClearFlag_1
   1460              }
   1461              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1462              {
   1463                /* Operating mode Flags */
   1464                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_4: (+1)
   \   0000002A   0x6042             STR      R2,[R0, #+4]
   1465              }
   1466            }
   1467          }
   \                     ??CAN_ClearFlag_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   1468          
   1469          /**
   1470            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1471            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1472            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1473            *          This parameter can be one of the following values:
   1474            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1475            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1476            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1477            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1478            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1479            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1480            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1481            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1482            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1483            *            @arg CAN_IT_EWG: Error warning Interrupt
   1484            *            @arg CAN_IT_EPV: Error passive Interrupt
   1485            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1486            *            @arg CAN_IT_LEC: Last error code Interrupt
   1487            *            @arg CAN_IT_ERR: Error Interrupt
   1488            * @retval The current state of CAN_IT (SET or RESET).
   1489            */

   \                                 In section .text, align 2, keep-with-next
   1490          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1491          {
   \                     CAN_GetITStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1492            ITStatus itstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
   1493            /* Check the parameters */
   1494            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1495            assert_param(IS_CAN_IT(CAN_IT));
   1496            
   1497            /* check the interrupt enable bit */
   1498           if((CANx->IER & CAN_IT) != RESET)
   \   00000004   0x6942             LDR      R2,[R0, #+20]
   \   00000006   0x420A             TST      R2,R1
   \   00000008   0xD079             BEQ.N    ??CAN_GetITStatus_0
   1499           {
   1500             /* in case the Interrupt is enabled, .... */
   1501              switch (CAN_IT)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD021             BEQ.N    ??CAN_GetITStatus_1
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD025             BEQ.N    ??CAN_GetITStatus_2
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD029             BEQ.N    ??CAN_GetITStatus_3
   \   00000016   0x2908             CMP      R1,#+8
   \   00000018   0xD02D             BEQ.N    ??CAN_GetITStatus_4
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xD031             BEQ.N    ??CAN_GetITStatus_5
   \   0000001E   0x2920             CMP      R1,#+32
   \   00000020   0xD035             BEQ.N    ??CAN_GetITStatus_6
   \   00000022   0x2940             CMP      R1,#+64
   \   00000024   0xD039             BEQ.N    ??CAN_GetITStatus_7
   \   00000026   0xF5B1 0x7F80      CMP      R1,#+256
   \   0000002A   0xD048             BEQ.N    ??CAN_GetITStatus_8
   \   0000002C   0xF5B1 0x7F00      CMP      R1,#+512
   \   00000030   0xD04B             BEQ.N    ??CAN_GetITStatus_9
   \   00000032   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000036   0xD04E             BEQ.N    ??CAN_GetITStatus_10
   \   00000038   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000003C   0xD051             BEQ.N    ??CAN_GetITStatus_11
   \   0000003E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000042   0xD054             BEQ.N    ??CAN_GetITStatus_12
   \   00000044   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000048   0xD02D             BEQ.N    ??CAN_GetITStatus_13
   \   0000004A   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000004E   0xD030             BEQ.N    ??CAN_GetITStatus_14
   \   00000050   0xE053             B.N      ??CAN_GetITStatus_15
   1502              {
   1503                case CAN_IT_TME:
   1504                  /* Check CAN_TSR_RQCPx bits */
   1505                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_1: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable6_15  ;; 0x10101
   \   00000054   0x6880             LDR      R0,[R0, #+8]
   \   00000056   0x.... 0x....      BL       CheckITStatus
   \   0000005A   0x0002             MOVS     R2,R0
   1506                  break;
   \   0000005C   0xE050             B.N      ??CAN_GetITStatus_16
   1507                case CAN_IT_FMP0:
   1508                  /* Check CAN_RF0R_FMP0 bit */
   1509                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_2: (+1)
   \   0000005E   0x2103             MOVS     R1,#+3
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0x.... 0x....      BL       CheckITStatus
   \   00000066   0x0002             MOVS     R2,R0
   1510                  break;
   \   00000068   0xE04A             B.N      ??CAN_GetITStatus_16
   1511                case CAN_IT_FF0:
   1512                  /* Check CAN_RF0R_FULL0 bit */
   1513                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_3: (+1)
   \   0000006A   0x2108             MOVS     R1,#+8
   \   0000006C   0x68C0             LDR      R0,[R0, #+12]
   \   0000006E   0x.... 0x....      BL       CheckITStatus
   \   00000072   0x0002             MOVS     R2,R0
   1514                  break;
   \   00000074   0xE044             B.N      ??CAN_GetITStatus_16
   1515                case CAN_IT_FOV0:
   1516                  /* Check CAN_RF0R_FOVR0 bit */
   1517                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_4: (+1)
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0x.... 0x....      BL       CheckITStatus
   \   0000007E   0x0002             MOVS     R2,R0
   1518                  break;
   \   00000080   0xE03E             B.N      ??CAN_GetITStatus_16
   1519                case CAN_IT_FMP1:
   1520                  /* Check CAN_RF1R_FMP1 bit */
   1521                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_5: (+1)
   \   00000082   0x2103             MOVS     R1,#+3
   \   00000084   0x6900             LDR      R0,[R0, #+16]
   \   00000086   0x.... 0x....      BL       CheckITStatus
   \   0000008A   0x0002             MOVS     R2,R0
   1522                  break;
   \   0000008C   0xE038             B.N      ??CAN_GetITStatus_16
   1523                case CAN_IT_FF1:
   1524                  /* Check CAN_RF1R_FULL1 bit */
   1525                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_6: (+1)
   \   0000008E   0x2108             MOVS     R1,#+8
   \   00000090   0x6900             LDR      R0,[R0, #+16]
   \   00000092   0x.... 0x....      BL       CheckITStatus
   \   00000096   0x0002             MOVS     R2,R0
   1526                  break;
   \   00000098   0xE032             B.N      ??CAN_GetITStatus_16
   1527                case CAN_IT_FOV1:
   1528                  /* Check CAN_RF1R_FOVR1 bit */
   1529                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_7: (+1)
   \   0000009A   0x2110             MOVS     R1,#+16
   \   0000009C   0x6900             LDR      R0,[R0, #+16]
   \   0000009E   0x.... 0x....      BL       CheckITStatus
   \   000000A2   0x0002             MOVS     R2,R0
   1530                  break;
   \   000000A4   0xE02C             B.N      ??CAN_GetITStatus_16
   1531                case CAN_IT_WKU:
   1532                  /* Check CAN_MSR_WKUI bit */
   1533                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_13: (+1)
   \   000000A6   0x2108             MOVS     R1,#+8
   \   000000A8   0x6840             LDR      R0,[R0, #+4]
   \   000000AA   0x.... 0x....      BL       CheckITStatus
   \   000000AE   0x0002             MOVS     R2,R0
   1534                  break;
   \   000000B0   0xE026             B.N      ??CAN_GetITStatus_16
   1535                case CAN_IT_SLK:
   1536                  /* Check CAN_MSR_SLAKI bit */
   1537                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_14: (+1)
   \   000000B2   0x2110             MOVS     R1,#+16
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0x.... 0x....      BL       CheckITStatus
   \   000000BA   0x0002             MOVS     R2,R0
   1538                  break;
   \   000000BC   0xE020             B.N      ??CAN_GetITStatus_16
   1539                case CAN_IT_EWG:
   1540                  /* Check CAN_ESR_EWGF bit */
   1541                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_8: (+1)
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x6980             LDR      R0,[R0, #+24]
   \   000000C2   0x.... 0x....      BL       CheckITStatus
   \   000000C6   0x0002             MOVS     R2,R0
   1542                  break;
   \   000000C8   0xE01A             B.N      ??CAN_GetITStatus_16
   1543                case CAN_IT_EPV:
   1544                  /* Check CAN_ESR_EPVF bit */
   1545                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_9: (+1)
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0x6980             LDR      R0,[R0, #+24]
   \   000000CE   0x.... 0x....      BL       CheckITStatus
   \   000000D2   0x0002             MOVS     R2,R0
   1546                  break;
   \   000000D4   0xE014             B.N      ??CAN_GetITStatus_16
   1547                case CAN_IT_BOF:
   1548                  /* Check CAN_ESR_BOFF bit */
   1549                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_10: (+1)
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x6980             LDR      R0,[R0, #+24]
   \   000000DA   0x.... 0x....      BL       CheckITStatus
   \   000000DE   0x0002             MOVS     R2,R0
   1550                  break;
   \   000000E0   0xE00E             B.N      ??CAN_GetITStatus_16
   1551                case CAN_IT_LEC:
   1552                  /* Check CAN_ESR_LEC bit */
   1553                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_11: (+1)
   \   000000E2   0x2170             MOVS     R1,#+112
   \   000000E4   0x6980             LDR      R0,[R0, #+24]
   \   000000E6   0x.... 0x....      BL       CheckITStatus
   \   000000EA   0x0002             MOVS     R2,R0
   1554                  break;
   \   000000EC   0xE008             B.N      ??CAN_GetITStatus_16
   1555                case CAN_IT_ERR:
   1556                  /* Check CAN_MSR_ERRI bit */ 
   1557                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \                     ??CAN_GetITStatus_12: (+1)
   \   000000EE   0x2104             MOVS     R1,#+4
   \   000000F0   0x6840             LDR      R0,[R0, #+4]
   \   000000F2   0x.... 0x....      BL       CheckITStatus
   \   000000F6   0x0002             MOVS     R2,R0
   1558                  break;
   \   000000F8   0xE002             B.N      ??CAN_GetITStatus_16
   1559                default:
   1560                  /* in case of error, return RESET */
   1561                  itstatus = RESET;
   \                     ??CAN_GetITStatus_15: (+1)
   \   000000FA   0x2200             MOVS     R2,#+0
   1562                  break;
   \   000000FC   0xE000             B.N      ??CAN_GetITStatus_16
   1563              }
   1564            }
   1565            else
   1566            {
   1567             /* in case the Interrupt is not enabled, return RESET */
   1568              itstatus  = RESET;
   \                     ??CAN_GetITStatus_0: (+1)
   \   000000FE   0x2200             MOVS     R2,#+0
   1569            }
   1570            
   1571            /* Return the CAN_IT status */
   1572            return  itstatus;
   \                     ??CAN_GetITStatus_16: (+1)
   \   00000100   0x0010             MOVS     R0,R2
   \   00000102   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000104   0xBD02             POP      {R1,PC}          ;; return
   1573          }
   1574          
   1575          /**
   1576            * @brief  Clears the CANx's interrupt pending bits.
   1577            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1578            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1579            *          This parameter can be one of the following values:
   1580            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1581            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1582            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1583            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1584            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1585            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1586            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1587            *            @arg CAN_IT_EWG: Error warning Interrupt
   1588            *            @arg CAN_IT_EPV: Error passive Interrupt
   1589            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1590            *            @arg CAN_IT_LEC: Last error code Interrupt
   1591            *            @arg CAN_IT_ERR: Error Interrupt 
   1592            * @retval None
   1593            */

   \                                 In section .text, align 2, keep-with-next
   1594          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1595          {
   1596            /* Check the parameters */
   1597            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1598            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1599          
   1600            switch (CAN_IT)
   \                     CAN_ClearITPendingBit: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD01D             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000008   0x2908             CMP      R1,#+8
   \   0000000A   0xD01F             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000C   0x2920             CMP      R1,#+32
   \   0000000E   0xD020             BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000010   0x2940             CMP      R1,#+64
   \   00000012   0xD021             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000014   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000018   0xD027             BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001A   0xF5B1 0x7F00      CMP      R1,#+512
   \   0000001E   0xD027             BEQ.N    ??CAN_ClearITPendingBit_6
   \   00000020   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000024   0xD027             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000026   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000002A   0xD027             BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000002C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000030   0xD029             BEQ.N    ??CAN_ClearITPendingBit_9
   \   00000032   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000036   0xD012             BEQ.N    ??CAN_ClearITPendingBit_10
   \   00000038   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000003C   0xD012             BEQ.N    ??CAN_ClearITPendingBit_11
   \   0000003E   0xE027             B.N      ??CAN_ClearITPendingBit_12
   1601            {
   1602              case CAN_IT_TME:
   1603                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1604                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \   00000040   0x....             LDR.N    R1,??DataTable6_15  ;; 0x10101
   \   00000042   0x6081             STR      R1,[R0, #+8]
   1605                break;
   \   00000044   0xE024             B.N      ??CAN_ClearITPendingBit_13
   1606              case CAN_IT_FF0:
   1607                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1608                CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \   00000046   0x2108             MOVS     R1,#+8
   \   00000048   0x60C1             STR      R1,[R0, #+12]
   1609                break;
   \   0000004A   0xE021             B.N      ??CAN_ClearITPendingBit_13
   1610              case CAN_IT_FOV0:
   1611                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1612                CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0x60C1             STR      R1,[R0, #+12]
   1613                break;
   \   00000050   0xE01E             B.N      ??CAN_ClearITPendingBit_13
   1614              case CAN_IT_FF1:
   1615                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1616                CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \   00000052   0x2108             MOVS     R1,#+8
   \   00000054   0x6101             STR      R1,[R0, #+16]
   1617                break;
   \   00000056   0xE01B             B.N      ??CAN_ClearITPendingBit_13
   1618              case CAN_IT_FOV1:
   1619                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1620                CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x6101             STR      R1,[R0, #+16]
   1621                break;
   \   0000005C   0xE018             B.N      ??CAN_ClearITPendingBit_13
   1622              case CAN_IT_WKU:
   1623                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1624                CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_10: (+1)
   \   0000005E   0x2108             MOVS     R1,#+8
   \   00000060   0x6041             STR      R1,[R0, #+4]
   1625                break;
   \   00000062   0xE015             B.N      ??CAN_ClearITPendingBit_13
   1626              case CAN_IT_SLK:
   1627                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1628                CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_11: (+1)
   \   00000064   0x2110             MOVS     R1,#+16
   \   00000066   0x6041             STR      R1,[R0, #+4]
   1629                break;
   \   00000068   0xE012             B.N      ??CAN_ClearITPendingBit_13
   1630              case CAN_IT_EWG:
   1631                /* Clear CAN_MSR_ERRI (rc_w1) */
   1632                CANx->MSR = CAN_MSR_ERRI;
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \   0000006A   0x2104             MOVS     R1,#+4
   \   0000006C   0x6041             STR      R1,[R0, #+4]
   1633                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1634                break;
   \   0000006E   0xE00F             B.N      ??CAN_ClearITPendingBit_13
   1635              case CAN_IT_EPV:
   1636                /* Clear CAN_MSR_ERRI (rc_w1) */
   1637                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \   00000070   0x2104             MOVS     R1,#+4
   \   00000072   0x6041             STR      R1,[R0, #+4]
   1638                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1639                break;
   \   00000074   0xE00C             B.N      ??CAN_ClearITPendingBit_13
   1640              case CAN_IT_BOF:
   1641                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1642                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \   00000076   0x2104             MOVS     R1,#+4
   \   00000078   0x6041             STR      R1,[R0, #+4]
   1643                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1644                 break;
   \   0000007A   0xE009             B.N      ??CAN_ClearITPendingBit_13
   1645              case CAN_IT_LEC:
   1646                /*  Clear LEC bits */
   1647                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x6181             STR      R1,[R0, #+24]
   1648                /* Clear CAN_MSR_ERRI (rc_w1) */
   1649                CANx->MSR = CAN_MSR_ERRI; 
   \   00000080   0x2104             MOVS     R1,#+4
   \   00000082   0x6041             STR      R1,[R0, #+4]
   1650                break;
   \   00000084   0xE004             B.N      ??CAN_ClearITPendingBit_13
   1651              case CAN_IT_ERR:
   1652                /*Clear LEC bits */
   1653                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_9: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6181             STR      R1,[R0, #+24]
   1654                /* Clear CAN_MSR_ERRI (rc_w1) */
   1655                CANx->MSR = CAN_MSR_ERRI; 
   \   0000008A   0x2104             MOVS     R1,#+4
   \   0000008C   0x6041             STR      R1,[R0, #+4]
   1656                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1657                 break;
   \   0000008E   0xE7FF             B.N      ??CAN_ClearITPendingBit_13
   1658              default:
   1659                 break;
   1660             }
   1661          }
   \                     ??CAN_ClearITPendingBit_12: (+1)
   \                     ??CAN_ClearITPendingBit_13: (+1)
   \   00000090   0x4770             BX       LR               ;; return
   1662           /**
   1663            * @}
   1664            */
   1665          
   1666          /**
   1667            * @brief  Checks whether the CAN interrupt has occurred or not.
   1668            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1669            * @param  It_Bit: specifies the interrupt source bit to check.
   1670            * @retval The new state of the CAN Interrupt (SET or RESET).
   1671            */

   \                                 In section .text, align 2, keep-with-next
   1672          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1673          {
   1674            ITStatus pendingbitstatus = RESET;
   \                     CheckITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1675            
   1676            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??CheckITStatus_0
   1677            {
   1678              /* CAN_IT is set */
   1679              pendingbitstatus = SET;
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xE000             B.N      ??CheckITStatus_1
   1680            }
   1681            else
   1682            {
   1683              /* CAN_IT is reset */
   1684              pendingbitstatus = RESET;
   \                     ??CheckITStatus_0: (+1)
   \   0000000A   0x2200             MOVS     R2,#+0
   1685            }
   1686            return pendingbitstatus;
   \                     ??CheckITStatus_1: (+1)
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
   1687          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x4000661C         DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x4000660C         DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40006604         DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40006614         DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x04000003         DC32     0x4000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x08000300         DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x10030000         DC32     0x10030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x04000001         DC32     0x4000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x040000FD         DC32     0x40000fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x0800FD00         DC32     0x800fd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x30F00070         DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x00010101         DC32     0x10101
   1688          
   1689          /**
   1690            * @}
   1691            */
   1692          
   1693          /**
   1694            * @}
   1695            */
   1696          
   1697          /**
   1698            * @}
   1699            */
   1700          
   1701          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
       4   CAN_FilterInit
       0   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       0   CAN_Init
       0   CAN_MessagePending
       0   CAN_OperatingModeRequest
       0   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
       8   CAN_Transmit
       0   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      46  CAN_CancelTransmit
      46  CAN_ClearFlag
     146  CAN_ClearITPendingBit
      26  CAN_DBGFreeze
      54  CAN_DeInit
      26  CAN_FIFORelease
     272  CAN_FilterInit
     104  CAN_GetFlagStatus
     262  CAN_GetITStatus
      12  CAN_GetLSBTransmitErrorCounter
      14  CAN_GetLastErrorCode
      12  CAN_GetReceiveErrorCounter
      24  CAN_ITConfig
     268  CAN_Init
      38  CAN_MessagePending
     170  CAN_OperatingModeRequest
     232  CAN_Receive
      70  CAN_SlaveStartBank
      32  CAN_Sleep
      46  CAN_StructInit
      98  CAN_TTComModeCmd
     286  CAN_Transmit
     140  CAN_TransmitStatus
      42  CAN_WakeUp
      18  CheckITStatus

 
 2 548 bytes in section .text
 
 2 548 bytes of CODE memory

Errors: none
Warnings: none
