###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       20/Feb/2017  16:08:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#    Command line =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\STM324xG_EVAL\List
#        -o
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\..\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\STM324xG_EVAL\List\stm32f4xx_adc.lst
#    Object file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab5\EWARM\STM324xG_EVAL\Obj\stm32f4xx_adc.o
#
###############################################################################

C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           + Initialization and Configuration (in addition to ADC multi mode 
     10            *             selection)
     11            *           + Analog Watchdog configuration
     12            *           + Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
     13            *             management 
     14            *           + Regular Channels Configuration
     15            *           + Regular Channels DMA Configuration
     16            *           + Injected channels Configuration
     17            *           + Interrupts and flags management
     18            *         
     19            @verbatim
     20           ===============================================================================
     21                               ##### How to use this driver #####
     22           ===============================================================================
     23              [..]
     24              (#) Enable the ADC interface clock using 
     25                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
     26                 
     27              (#) ADC pins configuration
     28                   (++) Enable the clock for the ADC GPIOs using the following function:
     29                       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30                   (++) Configure these ADC pins in analog mode using GPIO_Init();  
     31            
     32               (#) Configure the ADC Prescaler, conversion resolution and data 
     33                   alignment using the ADC_Init() function.
     34               (#) Activate the ADC peripheral using ADC_Cmd() function.
     35            
     36               *** Regular channels group configuration ***
     37               ============================================
     38               [..]    
     39                 (+) To configure the ADC regular channels group features, use 
     40                     ADC_Init() and ADC_RegularChannelConfig() functions.
     41                 (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     42                     function.
     43                 (+) To configurate and activate the Discontinuous mode, use the 
     44                     ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     45                 (+) To read the ADC converted values, use the ADC_GetConversionValue()
     46                     function.
     47            
     48               *** Multi mode ADCs Regular channels configuration ***
     49               ======================================================
     50               [..]
     51                 (+) Refer to "Regular channels group configuration" description to
     52                     configure the ADC1, ADC2 and ADC3 regular channels.        
     53                 (+) Select the Multi mode ADC regular channels features (dual or 
     54                     triple mode) using ADC_CommonInit() function and configure 
     55                     the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
     56                     functions.        
     57                 (+) Read the ADCs converted values using the 
     58                     ADC_GetMultiModeConversionValue() function.
     59            
     60               *** DMA for Regular channels group features configuration ***
     61               ============================================================= 
     62               [..]
     63                 (+) To enable the DMA mode for regular channels group, use the 
     64                     ADC_DMACmd() function.
     65                 (+) To enable the generation of DMA requests continuously at the end
     66                     of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     67                     function.
     68            
     69               *** Injected channels group configuration ***
     70               =============================================    
     71               [..]
     72                 (+) To configure the ADC Injected channels group features, use 
     73                     ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     74                     functions.
     75                 (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     76                     function.
     77                 (+) To activate the Injected Discontinuous mode, use the 
     78                     ADC_InjectedDiscModeCmd() function.  
     79                 (+) To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     80                     function.        
     81                 (+) To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     82                     function.
     83            
     84              @endverbatim
     85            ******************************************************************************
     86            * @attention
     87            *
     88            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     89            *
     90            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     91            * You may not use this file except in compliance with the License.
     92            * You may obtain a copy of the License at:
     93            *
     94            *        http://www.st.com/software_license_agreement_liberty_v2
     95            *
     96            * Unless required by applicable law or agreed to in writing, software 
     97            * distributed under the License is distributed on an "AS IS" BASIS, 
     98            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     99            * See the License for the specific language governing permissions and
    100            * limitations under the License.
    101            *
    102            ******************************************************************************  
    103            */ 
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32f4xx_adc.h"
    107          #include "stm32f4xx_rcc.h"
    108          
    109          /** @addtogroup STM32F4xx_StdPeriph_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup ADC 
    114            * @brief ADC driver modules
    115            * @{
    116            */ 
    117          
    118          /* Private typedef -----------------------------------------------------------*/
    119          /* Private define ------------------------------------------------------------*/ 
    120          
    121          /* ADC DISCNUM mask */
    122          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    123          
    124          /* ADC AWDCH mask */
    125          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
    126          
    127          /* ADC Analog watchdog enable mode mask */
    128          #define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
    129          
    130          /* CR1 register Mask */
    131          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
    132          
    133          /* ADC EXTEN mask */
    134          #define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
    135          
    136          /* ADC JEXTEN mask */
    137          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
    138          
    139          /* ADC JEXTSEL mask */
    140          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
    141          
    142          /* CR2 register Mask */
    143          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    144          
    145          /* ADC SQx mask */
    146          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    147          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    148          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
    149          
    150          /* ADC L Mask */
    151          #define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
    152          
    153          /* ADC JSQx mask */
    154          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    155          
    156          /* ADC JL mask */
    157          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    158          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    159          
    160          /* ADC SMPx mask */
    161          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    162          #define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
    163          
    164          /* ADC JDRx registers offset */
    165          #define JDR_OFFSET                ((uint8_t)0x28) 
    166          
    167          /* ADC CDR register base address */
    168          #define CDR_ADDRESS               ((uint32_t)0x40012308)   
    169          
    170          /* ADC CCR register Mask */
    171          #define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
    172          
    173          /* Private macro -------------------------------------------------------------*/
    174          /* Private variables ---------------------------------------------------------*/
    175          /* Private function prototypes -----------------------------------------------*/
    176          /* Private functions ---------------------------------------------------------*/
    177          
    178          /** @defgroup ADC_Private_Functions
    179            * @{
    180            */ 
    181          
    182          /** @defgroup ADC_Group1 Initialization and Configuration functions
    183           *  @brief    Initialization and Configuration functions 
    184           *
    185          @verbatim    
    186           ===============================================================================
    187                        ##### Initialization and Configuration functions #####
    188           ===============================================================================
    189              [..]  This section provides functions allowing to:
    190                (+) Initialize and configure the ADC Prescaler
    191                (+) ADC Conversion Resolution (12bit..6bit)
    192                (+) Scan Conversion Mode (multichannel or one channel) for regular group
    193                (+) ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    194                    regular group
    195                (+) External trigger Edge and source of regular group, 
    196                (+) Converted data alignment (left or right)
    197                (+) The number of ADC conversions that will be done using the sequencer for 
    198                    regular channel group
    199                (+) Multi ADC mode selection
    200                (+) Direct memory access mode selection for multi ADC mode  
    201                (+) Delay between 2 sampling phases (used in dual or triple interleaved modes)
    202                (+) Enable or disable the ADC peripheral   
    203          @endverbatim
    204            * @{
    205            */
    206          
    207          /**
    208            * @brief  Deinitializes all ADCs peripherals registers to their default reset 
    209            *         values.
    210            * @param  None
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void ADC_DeInit(void)
    214          {
   \                     ADC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    215            /* Enable all ADCs reset state */
    216            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x7080      MOV      R0,#+256
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    217            
    218            /* Release all ADCs from reset state */
    219            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF44F 0x7080      MOV      R0,#+256
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    220          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    221          
    222          /**
    223            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    224            *         in the ADC_InitStruct.
    225            * @note   This function is used to configure the global features of the ADC ( 
    226            *         Resolution and Data Alignment), however, the rest of the configuration
    227            *         parameters are specific to the regular channels group (scan mode 
    228            *         activation, continuous mode activation, External trigger source and 
    229            *         edge, number of conversion in the regular channels group sequencer).  
    230            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    231            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    232            *         the configuration information for the specified ADC peripheral.
    233            * @retval None
    234            */

   \                                 In section .text, align 2, keep-with-next
    235          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    236          {
   \                     ADC_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    237            uint32_t tmpreg1 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    238            uint8_t tmpreg2 = 0;
   \   00000004   0x2200             MOVS     R2,#+0
    239            /* Check the parameters */
    240            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    241            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
    242            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    243            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
    244            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
    245            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
    246            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    247            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
    248            
    249            /*---------------------------- ADCx CR1 Configuration -----------------*/
    250            /* Get the ADCx CR1 value */
    251            tmpreg1 = ADCx->CR1;
   \   00000006   0x6843             LDR      R3,[R0, #+4]
    252            
    253            /* Clear RES and SCAN bits */
    254            tmpreg1 &= CR1_CLEAR_MASK;
   \   00000008   0x....             LDR.N    R4,??DataTable6  ;; 0xfcfffeff
   \   0000000A   0x4023             ANDS     R3,R4,R3
    255            
    256            /* Configure ADCx: scan conversion mode and resolution */
    257            /* Set SCAN bit according to ADC_ScanConvMode value */
    258            /* Set RES bit according to ADC_Resolution value */ 
    259            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
    260                                             ADC_InitStruct->ADC_Resolution);
   \   0000000C   0x790C             LDRB     R4,[R1, #+4]
   \   0000000E   0x680D             LDR      R5,[R1, #+0]
   \   00000010   0xEA55 0x2404      ORRS     R4,R5,R4, LSL #+8
   \   00000014   0x4323             ORRS     R3,R4,R3
    261            /* Write to ADCx CR1 */
    262            ADCx->CR1 = tmpreg1;
   \   00000016   0x6043             STR      R3,[R0, #+4]
    263            /*---------------------------- ADCx CR2 Configuration -----------------*/
    264            /* Get the ADCx CR2 value */
    265            tmpreg1 = ADCx->CR2;
   \   00000018   0x6883             LDR      R3,[R0, #+8]
    266            
    267            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    268            tmpreg1 &= CR2_CLEAR_MASK;
   \   0000001A   0x....             LDR.N    R4,??DataTable6_1  ;; 0xc0fff7fd
   \   0000001C   0x4023             ANDS     R3,R4,R3
    269            
    270            /* Configure ADCx: external trigger event and edge, data alignment and 
    271               continuous conversion mode */
    272            /* Set ALIGN bit according to ADC_DataAlign value */
    273            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    274            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    275            /* Set CONT bit according to ADC_ContinuousConvMode value */
    276            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
    277                                  ADC_InitStruct->ADC_ExternalTrigConv | 
    278                                  ADC_InitStruct->ADC_ExternalTrigConvEdge | \
    279                                  ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
   \   0000001E   0x690C             LDR      R4,[R1, #+16]
   \   00000020   0x68CD             LDR      R5,[R1, #+12]
   \   00000022   0x432C             ORRS     R4,R5,R4
   \   00000024   0x688D             LDR      R5,[R1, #+8]
   \   00000026   0x432C             ORRS     R4,R5,R4
   \   00000028   0x794D             LDRB     R5,[R1, #+5]
   \   0000002A   0xEA54 0x0445      ORRS     R4,R4,R5, LSL #+1
   \   0000002E   0x4323             ORRS     R3,R4,R3
    280                                  
    281            /* Write to ADCx CR2 */
    282            ADCx->CR2 = tmpreg1;
   \   00000030   0x6083             STR      R3,[R0, #+8]
    283            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    284            /* Get the ADCx SQR1 value */
    285            tmpreg1 = ADCx->SQR1;
   \   00000032   0x6AC3             LDR      R3,[R0, #+44]
    286            
    287            /* Clear L bits */
    288            tmpreg1 &= SQR1_L_RESET;
   \   00000034   0xF433 0x0370      BICS     R3,R3,#0xF00000
    289            
    290            /* Configure ADCx: regular channel sequence length */
    291            /* Set L bits according to ADC_NbrOfConversion value */
    292            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
   \   00000038   0x7D09             LDRB     R1,[R1, #+20]
   \   0000003A   0x1E49             SUBS     R1,R1,#+1
   \   0000003C   0x430A             ORRS     R2,R1,R2
    293            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0xEA53 0x5302      ORRS     R3,R3,R2, LSL #+20
    294            
    295            /* Write to ADCx SQR1 */
    296            ADCx->SQR1 = tmpreg1;
   \   00000044   0x62C3             STR      R3,[R0, #+44]
    297          }
   \   00000046   0xBC30             POP      {R4,R5}
   \   00000048   0x4770             BX       LR               ;; return
    298          
    299          /**
    300            * @brief  Fills each ADC_InitStruct member with its default value.
    301            * @note   This function is used to initialize the global features of the ADC ( 
    302            *         Resolution and Data Alignment), however, the rest of the configuration
    303            *         parameters are specific to the regular channels group (scan mode 
    304            *         activation, continuous mode activation, External trigger source and 
    305            *         edge, number of conversion in the regular channels group sequencer).  
    306            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    307            *         be initialized.
    308            * @retval None
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    311          {
    312            /* Initialize the ADC_Mode member */
    313            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
   \                     ADC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    314          
    315            /* initialize the ADC_ScanConvMode member */
    316            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    317          
    318            /* Initialize the ADC_ContinuousConvMode member */
    319            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    320          
    321            /* Initialize the ADC_ExternalTrigConvEdge member */
    322            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    323          
    324            /* Initialize the ADC_ExternalTrigConv member */
    325            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    326          
    327            /* Initialize the ADC_DataAlign member */
    328            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
    329          
    330            /* Initialize the ADC_NbrOfConversion member */
    331            ADC_InitStruct->ADC_NbrOfConversion = 1;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7501             STRB     R1,[R0, #+20]
    332          }
   \   0000001C   0x4770             BX       LR               ;; return
    333          
    334          /**
    335            * @brief  Initializes the ADCs peripherals according to the specified parameters 
    336            *         in the ADC_CommonInitStruct.
    337            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    338            *         that contains the configuration information for  All ADCs peripherals.
    339            * @retval None
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    342          {
    343            uint32_t tmpreg1 = 0;
   \                     ADC_CommonInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    344            /* Check the parameters */
    345            assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
    346            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
    347            assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
    348            assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
    349            /*---------------------------- ADC CCR Configuration -----------------*/
    350            /* Get the ADC CCR value */
    351            tmpreg1 = ADC->CCR;
   \   00000002   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   00000004   0x6809             LDR      R1,[R1, #+0]
    352            
    353            /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    354            tmpreg1 &= CR_CLEAR_MASK;
   \   00000006   0x....             LDR.N    R2,??DataTable6_3  ;; 0xfffc30e0
   \   00000008   0x4011             ANDS     R1,R2,R1
    355            
    356            /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
    357               and DMA access mode for multimode */
    358            /* Set MULTI bits according to ADC_Mode value */
    359            /* Set ADCPRE bits according to ADC_Prescaler value */
    360            /* Set DMA bits according to ADC_DMAAccessMode value */
    361            /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
    362            tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
    363                                  ADC_CommonInitStruct->ADC_Prescaler | 
    364                                  ADC_CommonInitStruct->ADC_DMAAccessMode | 
    365                                  ADC_CommonInitStruct->ADC_TwoSamplingDelay);
   \   0000000A   0x6802             LDR      R2,[R0, #+0]
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   \   0000000E   0x431A             ORRS     R2,R3,R2
   \   00000010   0x6883             LDR      R3,[R0, #+8]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0x4310             ORRS     R0,R0,R2
   \   00000018   0x4301             ORRS     R1,R0,R1
    366                                  
    367            /* Write to ADC CCR */
    368            ADC->CCR = tmpreg1;
   \   0000001A   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    369          }
   \   0000001E   0x4770             BX       LR               ;; return
    370          
    371          /**
    372            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    373            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    374            *         which will be initialized.
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    378          {
    379            /* Initialize the ADC_Mode member */
    380            ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
   \                     ADC_CommonStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    381          
    382            /* initialize the ADC_Prescaler member */
    383            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    384          
    385            /* Initialize the ADC_DMAAccessMode member */
    386            ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    387          
    388            /* Initialize the ADC_TwoSamplingDelay member */
    389            ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    390          }
   \   00000010   0x4770             BX       LR               ;; return
    391          
    392          /**
    393            * @brief  Enables or disables the specified ADC peripheral.
    394            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    395            * @param  NewState: new state of the ADCx peripheral. 
    396            *          This parameter can be: ENABLE or DISABLE.
    397            * @retval None
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    400          {
    401            /* Check the parameters */
    402            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    403            assert_param(IS_FUNCTIONAL_STATE(NewState));
    404            if (NewState != DISABLE)
   \                     ADC_Cmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_Cmd_0
    405            {
    406              /* Set the ADON bit to wake up the ADC from power down mode */
    407              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_Cmd_1
    408            }
    409            else
    410            {
    411              /* Disable the selected ADC peripheral */
    412              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
   \                     ??ADC_Cmd_0: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0x0849             LSRS     R1,R1,#+1
   \   00000014   0x0049             LSLS     R1,R1,#+1
   \   00000016   0x6081             STR      R1,[R0, #+8]
    413            }
    414          }
   \                     ??ADC_Cmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    415          /**
    416            * @}
    417            */
    418          
    419          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    420           *  @brief    Analog Watchdog configuration functions 
    421           *
    422          @verbatim   
    423           ===============================================================================
    424                       ##### Analog Watchdog configuration functions #####
    425           ===============================================================================  
    426              [..] This section provides functions allowing to configure the Analog Watchdog
    427                   (AWD) feature in the ADC.
    428            
    429              [..] A typical configuration Analog Watchdog is done following these steps :
    430                (#) the ADC guarded channel(s) is (are) selected using the 
    431                    ADC_AnalogWatchdogSingleChannelConfig() function.
    432                (#) The Analog watchdog lower and higher threshold are configured using the  
    433                    ADC_AnalogWatchdogThresholdsConfig() function.
    434                (#) The Analog watchdog is enabled and configured to enable the check, on one
    435                    or more channels, using the  ADC_AnalogWatchdogCmd() function.
    436          @endverbatim
    437            * @{
    438            */
    439            
    440          /**
    441            * @brief  Enables or disables the analog watchdog on single/all regular or 
    442            *         injected channels
    443            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    444            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    445            *         This parameter can be one of the following values:
    446            *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
    447            *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
    448            *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
    449            *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
    450            *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
    451            *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
    452            *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    453            * @retval None	  
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    456          {
    457            uint32_t tmpreg = 0;
   \                     ADC_AnalogWatchdogCmd: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    458            /* Check the parameters */
    459            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    460            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
    461            
    462            /* Get the old register value */
    463            tmpreg = ADCx->CR1;
   \   00000002   0x6842             LDR      R2,[R0, #+4]
    464            
    465            /* Clear AWDEN, JAWDEN and AWDSGL bits */
    466            tmpreg &= CR1_AWDMode_RESET;
   \   00000004   0x....             LDR.N    R3,??DataTable6_4  ;; 0xff3ffdff
   \   00000006   0x401A             ANDS     R2,R3,R2
    467            
    468            /* Set the analog watchdog enable mode */
    469            tmpreg |= ADC_AnalogWatchdog;
   \   00000008   0x430A             ORRS     R2,R1,R2
    470            
    471            /* Store the new register value */
    472            ADCx->CR1 = tmpreg;
   \   0000000A   0x6042             STR      R2,[R0, #+4]
    473          }
   \   0000000C   0x4770             BX       LR               ;; return
    474          
    475          /**
    476            * @brief  Configures the high and low thresholds of the analog watchdog.
    477            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    478            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    479            *          This parameter must be a 12-bit value.
    480            * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
    481            *          This parameter must be a 12-bit value.
    482            * @retval None
    483            */

   \                                 In section .text, align 2, keep-with-next
    484          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    485                                                  uint16_t LowThreshold)
    486          {
    487            /* Check the parameters */
    488            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    489            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    490            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    491            
    492            /* Set the ADCx high threshold */
    493            ADCx->HTR = HighThreshold;
   \                     ADC_AnalogWatchdogThresholdsConfig: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6241             STR      R1,[R0, #+36]
    494            
    495            /* Set the ADCx low threshold */
    496            ADCx->LTR = LowThreshold;
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x6282             STR      R2,[R0, #+40]
    497          }
   \   00000008   0x4770             BX       LR               ;; return
    498          
    499          /**
    500            * @brief  Configures the analog watchdog guarded single channel
    501            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    502            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    503            *          This parameter can be one of the following values:
    504            *            @arg ADC_Channel_0: ADC Channel0 selected
    505            *            @arg ADC_Channel_1: ADC Channel1 selected
    506            *            @arg ADC_Channel_2: ADC Channel2 selected
    507            *            @arg ADC_Channel_3: ADC Channel3 selected
    508            *            @arg ADC_Channel_4: ADC Channel4 selected
    509            *            @arg ADC_Channel_5: ADC Channel5 selected
    510            *            @arg ADC_Channel_6: ADC Channel6 selected
    511            *            @arg ADC_Channel_7: ADC Channel7 selected
    512            *            @arg ADC_Channel_8: ADC Channel8 selected
    513            *            @arg ADC_Channel_9: ADC Channel9 selected
    514            *            @arg ADC_Channel_10: ADC Channel10 selected
    515            *            @arg ADC_Channel_11: ADC Channel11 selected
    516            *            @arg ADC_Channel_12: ADC Channel12 selected
    517            *            @arg ADC_Channel_13: ADC Channel13 selected
    518            *            @arg ADC_Channel_14: ADC Channel14 selected
    519            *            @arg ADC_Channel_15: ADC Channel15 selected
    520            *            @arg ADC_Channel_16: ADC Channel16 selected
    521            *            @arg ADC_Channel_17: ADC Channel17 selected
    522            *            @arg ADC_Channel_18: ADC Channel18 selected
    523            * @retval None
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    526          {
    527            uint32_t tmpreg = 0;
   \                     ADC_AnalogWatchdogSingleChannelConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    528            /* Check the parameters */
    529            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    530            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    531            
    532            /* Get the old register value */
    533            tmpreg = ADCx->CR1;
   \   00000002   0x6842             LDR      R2,[R0, #+4]
    534            
    535            /* Clear the Analog watchdog channel select bits */
    536            tmpreg &= CR1_AWDCH_RESET;
   \   00000004   0x0952             LSRS     R2,R2,#+5
   \   00000006   0x0152             LSLS     R2,R2,#+5
    537            
    538            /* Set the Analog watchdog channel */
    539            tmpreg |= ADC_Channel;
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x430A             ORRS     R2,R1,R2
    540            
    541            /* Store the new register value */
    542            ADCx->CR1 = tmpreg;
   \   0000000C   0x6042             STR      R2,[R0, #+4]
    543          }
   \   0000000E   0x4770             BX       LR               ;; return
    544          /**
    545            * @}
    546            */
    547          
    548          /** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
    549           *            and VBAT (Voltage BATtery) management functions
    550           *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
    551           *
    552          @verbatim   
    553           ===============================================================================
    554                ##### Temperature Sensor, Vrefint and VBAT management functions #####
    555           ===============================================================================  
    556              [..] This section provides functions allowing to enable/ disable the internal 
    557                   connections between the ADC and the Temperature Sensor, the Vrefint and 
    558                   the Vbat sources.
    559               
    560              [..] A typical configuration to get the Temperature sensor and Vrefint channels 
    561                   voltages is done following these steps :
    562                (#) Enable the internal connection of Temperature sensor and Vrefint sources 
    563                    with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    564                (#) Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    565                    ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    566                (#) Get the voltage values, using ADC_GetConversionValue() or  
    567                    ADC_GetInjectedConversionValue().
    568          
    569              [..] A typical configuration to get the VBAT channel voltage is done following 
    570                   these steps :
    571                (#) Enable the internal connection of VBAT source with the ADC channel using 
    572                    ADC_VBATCmd() function. 
    573                (#) Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
    574                    ADC_InjectedChannelConfig() functions 
    575                (#) Get the voltage value, using ADC_GetConversionValue() or  
    576                    ADC_GetInjectedConversionValue().
    577           
    578          @endverbatim
    579            * @{
    580            */
    581            
    582            
    583          /**
    584            * @brief  Enables or disables the temperature sensor and Vrefint channels.
    585            * @param  NewState: new state of the temperature sensor and Vrefint channels.
    586            *          This parameter can be: ENABLE or DISABLE.
    587            * @retval None
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    590          {
    591            /* Check the parameters */
    592            assert_param(IS_FUNCTIONAL_STATE(NewState));
    593            if (NewState != DISABLE)
   \                     ADC_TempSensorVrefintCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??ADC_TempSensorVrefintCmd_0
    594            {
    595              /* Enable the temperature sensor and Vrefint channel*/
    596              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
   \   00000006   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   0000000E   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0xE005             B.N      ??ADC_TempSensorVrefintCmd_1
    597            }
    598            else
    599            {
    600              /* Disable the temperature sensor and Vrefint channel*/
    601              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
   \                     ??ADC_TempSensorVrefintCmd_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   0000001C   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    602            }
    603          }
   \                     ??ADC_TempSensorVrefintCmd_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    604          
    605          /**
    606            * @brief  Enables or disables the VBAT (Voltage Battery) channel.
    607            * @param  NewState: new state of the VBAT channel.
    608            *          This parameter can be: ENABLE or DISABLE.
    609            * @retval None
    610            */

   \                                 In section .text, align 2, keep-with-next
    611          void ADC_VBATCmd(FunctionalState NewState)                             
    612          {
    613            /* Check the parameters */
    614            assert_param(IS_FUNCTIONAL_STATE(NewState));
    615            if (NewState != DISABLE)
   \                     ADC_VBATCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??ADC_VBATCmd_0
    616            {
    617              /* Enable the VBAT channel*/
    618              ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
   \   00000006   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   0000000E   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0xE005             B.N      ??ADC_VBATCmd_1
    619            }
    620            else
    621            {
    622              /* Disable the VBAT channel*/
    623              ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
   \                     ??ADC_VBATCmd_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   0000001C   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    624            }
    625          }
   \                     ??ADC_VBATCmd_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    626          
    627          /**
    628            * @}
    629            */
    630          
    631          /** @defgroup ADC_Group4 Regular Channels Configuration functions
    632           *  @brief   Regular Channels Configuration functions 
    633           *
    634          @verbatim   
    635           ===============================================================================
    636                       ##### Regular Channels Configuration functions #####
    637           ===============================================================================  
    638          
    639              [..] This section provides functions allowing to manage the ADC's regular channels,
    640                   it is composed of 2 sub sections : 
    641            
    642                (#) Configuration and management functions for regular channels: This subsection 
    643                    provides functions allowing to configure the ADC regular channels :    
    644                   (++) Configure the rank in the regular group sequencer for each channel
    645                   (++) Configure the sampling time for each channel
    646                   (++) select the conversion Trigger for regular channels
    647                   (++) select the desired EOC event behavior configuration
    648                   (++) Activate the continuous Mode  (*)
    649                   (++) Activate the Discontinuous Mode 
    650                   -@@- Please Note that the following features for regular channels 
    651                       are configurated using the ADC_Init() function : 
    652                     (+@@) scan mode activation 
    653                     (+@@) continuous mode activation (**) 
    654                     (+@@) External trigger source  
    655                     (+@@) External trigger edge 
    656                     (+@@) number of conversion in the regular channels group sequencer.
    657               
    658                   -@@- (*) and (**) are performing the same configuration
    659               
    660                (#) Get the conversion data: This subsection provides an important function in 
    661                    the ADC peripheral since it returns the converted data of the current 
    662                    regular channel. When the Conversion value is read, the EOC Flag is 
    663                    automatically cleared.
    664               
    665                    -@- For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
    666                        results data (in the selected multi mode) can be returned in the same 
    667                        time using ADC_GetMultiModeConversionValue() function. 
    668                   
    669          @endverbatim
    670            * @{
    671            */
    672          /**
    673            * @brief  Configures for the selected ADC regular channel its corresponding
    674            *         rank in the sequencer and its sample time.
    675            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    676            * @param  ADC_Channel: the ADC channel to configure. 
    677            *          This parameter can be one of the following values:
    678            *            @arg ADC_Channel_0: ADC Channel0 selected
    679            *            @arg ADC_Channel_1: ADC Channel1 selected
    680            *            @arg ADC_Channel_2: ADC Channel2 selected
    681            *            @arg ADC_Channel_3: ADC Channel3 selected
    682            *            @arg ADC_Channel_4: ADC Channel4 selected
    683            *            @arg ADC_Channel_5: ADC Channel5 selected
    684            *            @arg ADC_Channel_6: ADC Channel6 selected
    685            *            @arg ADC_Channel_7: ADC Channel7 selected
    686            *            @arg ADC_Channel_8: ADC Channel8 selected
    687            *            @arg ADC_Channel_9: ADC Channel9 selected
    688            *            @arg ADC_Channel_10: ADC Channel10 selected
    689            *            @arg ADC_Channel_11: ADC Channel11 selected
    690            *            @arg ADC_Channel_12: ADC Channel12 selected
    691            *            @arg ADC_Channel_13: ADC Channel13 selected
    692            *            @arg ADC_Channel_14: ADC Channel14 selected
    693            *            @arg ADC_Channel_15: ADC Channel15 selected
    694            *            @arg ADC_Channel_16: ADC Channel16 selected
    695            *            @arg ADC_Channel_17: ADC Channel17 selected
    696            *            @arg ADC_Channel_18: ADC Channel18 selected                       
    697            * @param  Rank: The rank in the regular group sequencer.
    698            *          This parameter must be between 1 to 16.
    699            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    700            *          This parameter can be one of the following values:
    701            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
    702            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
    703            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
    704            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
    705            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
    706            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
    707            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
    708            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
    709            * @retval None
    710            */

   \                                 In section .text, align 2, keep-with-next
    711          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    712          {
   \                     ADC_RegularChannelConfig: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    713            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
    714            /* Check the parameters */
    715            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    716            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    717            assert_param(IS_ADC_REGULAR_RANK(Rank));
    718            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    719            
    720            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    721            if (ADC_Channel > ADC_Channel_9)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x290A             CMP      R1,#+10
   \   0000000A   0xDB13             BLT.N    ??ADC_RegularChannelConfig_0
    722            {
    723              /* Get the old register value */
    724              tmpreg1 = ADCx->SMPR1;
   \   0000000C   0x68C4             LDR      R4,[R0, #+12]
    725              
    726              /* Calculate the mask to clear */
    727              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
   \   0000000E   0x2507             MOVS     R5,#+7
   \   00000010   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \   00000014   0x2703             MOVS     R7,#+3
   \   00000016   0xFB16 0xF607      SMULBB   R6,R6,R7
   \   0000001A   0x40B5             LSLS     R5,R5,R6
    728              
    729              /* Clear the old sample time */
    730              tmpreg1 &= ~tmpreg2;
   \   0000001C   0x43AC             BICS     R4,R4,R5
    731              
    732              /* Calculate the mask to set */
    733              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
   \   0000001E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000020   0xF1B1 0x050A      SUBS     R5,R1,#+10
   \   00000024   0x2603             MOVS     R6,#+3
   \   00000026   0xFB15 0xF506      SMULBB   R5,R5,R6
   \   0000002A   0xFA13 0xF505      LSLS     R5,R3,R5
    734              
    735              /* Set the new sample time */
    736              tmpreg1 |= tmpreg2;
   \   0000002E   0x432C             ORRS     R4,R5,R4
    737              
    738              /* Store the new register value */
    739              ADCx->SMPR1 = tmpreg1;
   \   00000030   0x60C4             STR      R4,[R0, #+12]
   \   00000032   0xE00E             B.N      ??ADC_RegularChannelConfig_1
    740            }
    741            else /* ADC_Channel include in ADC_Channel_[0..9] */
    742            {
    743              /* Get the old register value */
    744              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_RegularChannelConfig_0: (+1)
   \   00000034   0x6904             LDR      R4,[R0, #+16]
    745              
    746              /* Calculate the mask to clear */
    747              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   \   00000036   0x2507             MOVS     R5,#+7
   \   00000038   0x2603             MOVS     R6,#+3
   \   0000003A   0xFB11 0xF606      SMULBB   R6,R1,R6
   \   0000003E   0x40B5             LSLS     R5,R5,R6
    748              
    749              /* Clear the old sample time */
    750              tmpreg1 &= ~tmpreg2;
   \   00000040   0x43AC             BICS     R4,R4,R5
    751              
    752              /* Calculate the mask to set */
    753              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \   00000042   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000044   0x2503             MOVS     R5,#+3
   \   00000046   0xFB11 0xF505      SMULBB   R5,R1,R5
   \   0000004A   0xFA13 0xF505      LSLS     R5,R3,R5
    754              
    755              /* Set the new sample time */
    756              tmpreg1 |= tmpreg2;
   \   0000004E   0x432C             ORRS     R4,R5,R4
    757              
    758              /* Store the new register value */
    759              ADCx->SMPR2 = tmpreg1;
   \   00000050   0x6104             STR      R4,[R0, #+16]
    760            }
    761            /* For Rank 1 to 6 */
    762            if (Rank < 7)
   \                     ??ADC_RegularChannelConfig_1: (+1)
   \   00000052   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000054   0x2A07             CMP      R2,#+7
   \   00000056   0xDA12             BGE.N    ??ADC_RegularChannelConfig_2
    763            {
    764              /* Get the old register value */
    765              tmpreg1 = ADCx->SQR3;
   \   00000058   0x6B44             LDR      R4,[R0, #+52]
    766              
    767              /* Calculate the mask to clear */
    768              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
   \   0000005A   0x231F             MOVS     R3,#+31
   \   0000005C   0x1E55             SUBS     R5,R2,#+1
   \   0000005E   0x2605             MOVS     R6,#+5
   \   00000060   0xFB15 0xF506      SMULBB   R5,R5,R6
   \   00000064   0xFA13 0xF505      LSLS     R5,R3,R5
    769              
    770              /* Clear the old SQx bits for the selected rank */
    771              tmpreg1 &= ~tmpreg2;
   \   00000068   0x43AC             BICS     R4,R4,R5
    772              
    773              /* Calculate the mask to set */
    774              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
   \   0000006A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006C   0x1E52             SUBS     R2,R2,#+1
   \   0000006E   0x2305             MOVS     R3,#+5
   \   00000070   0xFB12 0xF203      SMULBB   R2,R2,R3
   \   00000074   0xFA11 0xF502      LSLS     R5,R1,R2
    775              
    776              /* Set the SQx bits for the selected rank */
    777              tmpreg1 |= tmpreg2;
   \   00000078   0x432C             ORRS     R4,R5,R4
    778              
    779              /* Store the new register value */
    780              ADCx->SQR3 = tmpreg1;
   \   0000007A   0x6344             STR      R4,[R0, #+52]
   \   0000007C   0xE028             B.N      ??ADC_RegularChannelConfig_3
    781            }
    782            /* For Rank 7 to 12 */
    783            else if (Rank < 13)
   \                     ??ADC_RegularChannelConfig_2: (+1)
   \   0000007E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000080   0x2A0D             CMP      R2,#+13
   \   00000082   0xDA12             BGE.N    ??ADC_RegularChannelConfig_4
    784            {
    785              /* Get the old register value */
    786              tmpreg1 = ADCx->SQR2;
   \   00000084   0x6B04             LDR      R4,[R0, #+48]
    787              
    788              /* Calculate the mask to clear */
    789              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
   \   00000086   0x231F             MOVS     R3,#+31
   \   00000088   0x1FD5             SUBS     R5,R2,#+7
   \   0000008A   0x2605             MOVS     R6,#+5
   \   0000008C   0xFB15 0xF506      SMULBB   R5,R5,R6
   \   00000090   0xFA13 0xF505      LSLS     R5,R3,R5
    790              
    791              /* Clear the old SQx bits for the selected rank */
    792              tmpreg1 &= ~tmpreg2;
   \   00000094   0x43AC             BICS     R4,R4,R5
    793              
    794              /* Calculate the mask to set */
    795              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0x1FD2             SUBS     R2,R2,#+7
   \   0000009A   0x2305             MOVS     R3,#+5
   \   0000009C   0xFB12 0xF203      SMULBB   R2,R2,R3
   \   000000A0   0xFA11 0xF502      LSLS     R5,R1,R2
    796              
    797              /* Set the SQx bits for the selected rank */
    798              tmpreg1 |= tmpreg2;
   \   000000A4   0x432C             ORRS     R4,R5,R4
    799              
    800              /* Store the new register value */
    801              ADCx->SQR2 = tmpreg1;
   \   000000A6   0x6304             STR      R4,[R0, #+48]
   \   000000A8   0xE012             B.N      ??ADC_RegularChannelConfig_3
    802            }
    803            /* For Rank 13 to 16 */
    804            else
    805            {
    806              /* Get the old register value */
    807              tmpreg1 = ADCx->SQR1;
   \                     ??ADC_RegularChannelConfig_4: (+1)
   \   000000AA   0x6AC4             LDR      R4,[R0, #+44]
    808              
    809              /* Calculate the mask to clear */
    810              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
   \   000000AC   0x231F             MOVS     R3,#+31
   \   000000AE   0xF1B2 0x050D      SUBS     R5,R2,#+13
   \   000000B2   0x2605             MOVS     R6,#+5
   \   000000B4   0xFB15 0xF506      SMULBB   R5,R5,R6
   \   000000B8   0xFA13 0xF505      LSLS     R5,R3,R5
    811              
    812              /* Clear the old SQx bits for the selected rank */
    813              tmpreg1 &= ~tmpreg2;
   \   000000BC   0x43AC             BICS     R4,R4,R5
    814              
    815              /* Calculate the mask to set */
    816              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
   \   000000BE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C0   0x3A0D             SUBS     R2,R2,#+13
   \   000000C2   0x2305             MOVS     R3,#+5
   \   000000C4   0xFB12 0xF203      SMULBB   R2,R2,R3
   \   000000C8   0xFA11 0xF502      LSLS     R5,R1,R2
    817              
    818              /* Set the SQx bits for the selected rank */
    819              tmpreg1 |= tmpreg2;
   \   000000CC   0x432C             ORRS     R4,R5,R4
    820              
    821              /* Store the new register value */
    822              ADCx->SQR1 = tmpreg1;
   \   000000CE   0x62C4             STR      R4,[R0, #+44]
    823            }
    824          }
   \                     ??ADC_RegularChannelConfig_3: (+1)
   \   000000D0   0xBCF0             POP      {R4-R7}
   \   000000D2   0x4770             BX       LR               ;; return
    825          
    826          /**
    827            * @brief  Enables the selected ADC software start conversion of the regular channels.
    828            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    829            * @retval None
    830            */

   \                                 In section .text, align 2, keep-with-next
    831          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    832          {
    833            /* Check the parameters */
    834            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    835            
    836            /* Enable the selected ADC conversion for regular group */
    837            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \                     ADC_SoftwareStartConv: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0xF051 0x4180      ORRS     R1,R1,#0x40000000
   \   00000006   0x6081             STR      R1,[R0, #+8]
    838          }
   \   00000008   0x4770             BX       LR               ;; return
    839          
    840          /**
    841            * @brief  Gets the selected ADC Software start regular conversion Status.
    842            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    843            * @retval The new state of ADC software start conversion (SET or RESET).
    844            */

   \                                 In section .text, align 2, keep-with-next
    845          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    846          {
    847            FlagStatus bitstatus = RESET;
   \                     ADC_GetSoftwareStartConvStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    848            /* Check the parameters */
    849            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    850            
    851            /* Check the status of SWSTART bit */
    852            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x0240             LSLS     R0,R0,#+9
   \   00000006   0xD501             BPL.N    ??ADC_GetSoftwareStartConvStatus_0
    853            {
    854              /* SWSTART bit is set */
    855              bitstatus = SET;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xE000             B.N      ??ADC_GetSoftwareStartConvStatus_1
    856            }
    857            else
    858            {
    859              /* SWSTART bit is reset */
    860              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartConvStatus_0: (+1)
   \   0000000C   0x2100             MOVS     R1,#+0
    861            }
    862            
    863            /* Return the SWSTART bit status */
    864            return  bitstatus;
   \                     ??ADC_GetSoftwareStartConvStatus_1: (+1)
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
    865          }
    866          
    867          
    868          /**
    869            * @brief  Enables or disables the EOC on each regular channel conversion
    870            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    871            * @param  NewState: new state of the selected ADC EOC flag rising
    872            *          This parameter can be: ENABLE or DISABLE.
    873            * @retval None
    874            */

   \                                 In section .text, align 2, keep-with-next
    875          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    876          {
    877            /* Check the parameters */
    878            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    879            assert_param(IS_FUNCTIONAL_STATE(NewState));
    880            
    881            if (NewState != DISABLE)
   \                     ADC_EOCOnEachRegularChannelCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
    882            {
    883              /* Enable the selected ADC EOC rising on each regular channel conversion */
    884              ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF451 0x6180      ORRS     R1,R1,#0x400
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_EOCOnEachRegularChannelCmd_1
    885            }
    886            else
    887            {
    888              /* Disable the selected ADC EOC rising on each regular channel conversion */
    889              ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
   \                     ??ADC_EOCOnEachRegularChannelCmd_0: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF431 0x6180      BICS     R1,R1,#0x400
   \   00000016   0x6081             STR      R1,[R0, #+8]
    890            }
    891          }
   \                     ??ADC_EOCOnEachRegularChannelCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    892          
    893          /**
    894            * @brief  Enables or disables the ADC continuous conversion mode 
    895            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    896            * @param  NewState: new state of the selected ADC continuous conversion mode
    897            *          This parameter can be: ENABLE or DISABLE.
    898            * @retval None
    899            */

   \                                 In section .text, align 2, keep-with-next
    900          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    901          {
    902            /* Check the parameters */
    903            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    904            assert_param(IS_FUNCTIONAL_STATE(NewState));
    905            
    906            if (NewState != DISABLE)
   \                     ADC_ContinuousModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_ContinuousModeCmd_0
    907            {
    908              /* Enable the selected ADC continuous conversion mode */
    909              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_ContinuousModeCmd_1
    910            }
    911            else
    912            {
    913              /* Disable the selected ADC continuous conversion mode */
    914              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
   \                     ??ADC_ContinuousModeCmd_0: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF031 0x0102      BICS     R1,R1,#0x2
   \   00000016   0x6081             STR      R1,[R0, #+8]
    915            }
    916          }
   \                     ??ADC_ContinuousModeCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    917          
    918          /**
    919            * @brief  Configures the discontinuous mode for the selected ADC regular group 
    920            *         channel.
    921            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    922            * @param  Number: specifies the discontinuous mode regular channel count value.
    923            *          This number must be between 1 and 8.
    924            * @retval None
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    927          {
    928            uint32_t tmpreg1 = 0;
   \                     ADC_DiscModeChannelCountConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    929            uint32_t tmpreg2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    930            
    931            /* Check the parameters */
    932            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    933            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    934            
    935            /* Get the old register value */
    936            tmpreg1 = ADCx->CR1;
   \   00000004   0x6842             LDR      R2,[R0, #+4]
    937            
    938            /* Clear the old discontinuous mode channel count */
    939            tmpreg1 &= CR1_DISCNUM_RESET;
   \   00000006   0xF432 0x4260      BICS     R2,R2,#0xE000
    940            
    941            /* Set the discontinuous mode channel count */
    942            tmpreg2 = Number - 1;
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x1E4B             SUBS     R3,R1,#+1
    943            tmpreg1 |= tmpreg2 << 13;
   \   0000000E   0xEA52 0x3243      ORRS     R2,R2,R3, LSL #+13
    944            
    945            /* Store the new register value */
    946            ADCx->CR1 = tmpreg1;
   \   00000012   0x6042             STR      R2,[R0, #+4]
    947          }
   \   00000014   0x4770             BX       LR               ;; return
    948          
    949          /**
    950            * @brief  Enables or disables the discontinuous mode on regular group channel 
    951            *         for the specified ADC
    952            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    953            * @param  NewState: new state of the selected ADC discontinuous mode on 
    954            *         regular group channel.
    955            *          This parameter can be: ENABLE or DISABLE.
    956            * @retval None
    957            */

   \                                 In section .text, align 2, keep-with-next
    958          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    959          {
    960            /* Check the parameters */
    961            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    962            assert_param(IS_FUNCTIONAL_STATE(NewState));
    963            
    964            if (NewState != DISABLE)
   \                     ADC_DiscModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_DiscModeCmd_0
    965            {
    966              /* Enable the selected ADC regular discontinuous mode */
    967              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF451 0x6100      ORRS     R1,R1,#0x800
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   \   0000000E   0xE003             B.N      ??ADC_DiscModeCmd_1
    968            }
    969            else
    970            {
    971              /* Disable the selected ADC regular discontinuous mode */
    972              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
   \                     ??ADC_DiscModeCmd_0: (+1)
   \   00000010   0x6841             LDR      R1,[R0, #+4]
   \   00000012   0xF431 0x6100      BICS     R1,R1,#0x800
   \   00000016   0x6041             STR      R1,[R0, #+4]
    973            }
    974          }
   \                     ??ADC_DiscModeCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    975          
    976          /**
    977            * @brief  Returns the last ADCx conversion result data for regular channel.
    978            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    979            * @retval The Data conversion value.
    980            */

   \                                 In section .text, align 2, keep-with-next
    981          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    982          {
    983            /* Check the parameters */
    984            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    985            
    986            /* Return the selected ADC conversion value */
    987            return (uint16_t) ADCx->DR;
   \                     ADC_GetConversionValue: (+1)
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    988          }
    989          
    990          /**
    991            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    992            *         data in the selected multi mode.
    993            * @param  None  
    994            * @retval The Data conversion value.
    995            * @note   In dual mode, the value returned by this function is as following
    996            *           Data[15:0] : these bits contain the regular data of ADC1.
    997            *           Data[31:16]: these bits contain the regular data of ADC2.
    998            * @note   In triple mode, the value returned by this function is as following
    999            *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
   1000            *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
   1001            */

   \                                 In section .text, align 2, keep-with-next
   1002          uint32_t ADC_GetMultiModeConversionValue(void)
   1003          {
   1004            /* Return the multi mode conversion value */
   1005            return (*(__IO uint32_t *) CDR_ADDRESS);
   \                     ADC_GetMultiModeConversionValue: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40012308
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1006          }
   1007          /**
   1008            * @}
   1009            */
   1010          
   1011          /** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
   1012           *  @brief   Regular Channels DMA Configuration functions 
   1013           *
   1014          @verbatim   
   1015           ===============================================================================
   1016                      ##### Regular Channels DMA Configuration functions #####
   1017           ===============================================================================  
   1018              [..] This section provides functions allowing to configure the DMA for ADC 
   1019                   regular channels.
   1020                   Since converted regular channel values are stored into a unique data 
   1021                   register, it is useful to use DMA for conversion of more than one regular 
   1022                   channel. This avoids the loss of the data already stored in the ADC 
   1023                   Data register.   
   1024                   When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1025                   conversion of a regular channel, a DMA request is generated.
   1026              [..] Depending on the "DMA disable selection for Independent ADC mode" 
   1027                   configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
   1028                   at the end of the last DMA transfer, two possibilities are allowed:
   1029                (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
   1030                (+) Requests can continue to be generated (feature ENABLED).  
   1031              [..] Depending on the "DMA disable selection for multi ADC mode" configuration 
   1032                   (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
   1033                   at the end of the last DMA transfer, two possibilities are allowed:
   1034                  (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
   1035                  (+) Requests can continue to be generated (feature ENABLED).
   1036          
   1037          @endverbatim
   1038            * @{
   1039            */
   1040            
   1041           /**
   1042            * @brief  Enables or disables the specified ADC DMA request.
   1043            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1044            * @param  NewState: new state of the selected ADC DMA transfer.
   1045            *          This parameter can be: ENABLE or DISABLE.
   1046            * @retval None
   1047            */

   \                                 In section .text, align 2, keep-with-next
   1048          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1052            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1053            if (NewState != DISABLE)
   \                     ADC_DMACmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_DMACmd_0
   1054            {
   1055              /* Enable the selected ADC DMA request */
   1056              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_DMACmd_1
   1057            }
   1058            else
   1059            {
   1060              /* Disable the selected ADC DMA request */
   1061              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   \                     ??ADC_DMACmd_0: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF431 0x7180      BICS     R1,R1,#0x100
   \   00000016   0x6081             STR      R1,[R0, #+8]
   1062            }
   1063          }
   \                     ??ADC_DMACmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1064          
   1065          /**
   1066            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1067            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1068            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1069            *          This parameter can be: ENABLE or DISABLE.
   1070            * @retval None
   1071            */

   \                                 In section .text, align 2, keep-with-next
   1072          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1073          {
   1074            /* Check the parameters */
   1075            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1076            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1077            if (NewState != DISABLE)
   \                     ADC_DMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   1078            {
   1079              /* Enable the selected ADC DMA request after last transfer */
   1080              ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF451 0x7100      ORRS     R1,R1,#0x200
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_DMARequestAfterLastTransferCmd_1
   1081            }
   1082            else
   1083            {
   1084              /* Disable the selected ADC DMA request after last transfer */
   1085              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
   \                     ??ADC_DMARequestAfterLastTransferCmd_0: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF431 0x7100      BICS     R1,R1,#0x200
   \   00000016   0x6081             STR      R1,[R0, #+8]
   1086            }
   1087          }
   \                     ??ADC_DMARequestAfterLastTransferCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1088          
   1089          /**
   1090            * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
   1091            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1092            *          This parameter can be: ENABLE or DISABLE.
   1093            * @note   if Enabled, DMA requests are issued as long as data are converted and 
   1094            *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
   1095            *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
   1096            *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
   1097            * @retval None
   1098            */

   \                                 In section .text, align 2, keep-with-next
   1099          void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
   1100          {
   1101            /* Check the parameters */
   1102            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1103            if (NewState != DISABLE)
   \                     ADC_MultiModeDMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_0
   1104            {
   1105              /* Enable the selected ADC DMA request after last transfer */
   1106              ADC->CCR |= (uint32_t)ADC_CCR_DDS;
   \   00000006   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000000E   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0xE005             B.N      ??ADC_MultiModeDMARequestAfterLastTransferCmd_1
   1107            }
   1108            else
   1109            {
   1110              /* Disable the selected ADC DMA request after last transfer */
   1111              ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40012304
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000001C   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40012304
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1112            }
   1113          }
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1114          /**
   1115            * @}
   1116            */
   1117          
   1118          /** @defgroup ADC_Group6 Injected channels Configuration functions
   1119           *  @brief   Injected channels Configuration functions 
   1120           *
   1121          @verbatim   
   1122           ===============================================================================
   1123                        ##### Injected channels Configuration functions #####
   1124           ===============================================================================  
   1125          
   1126              [..] This section provide functions allowing to configure the ADC Injected channels,
   1127                   it is composed of 2 sub sections : 
   1128              
   1129                (#) Configuration functions for Injected channels: This subsection provides 
   1130                    functions allowing to configure the ADC injected channels :    
   1131                  (++) Configure the rank in the injected group sequencer for each channel
   1132                  (++) Configure the sampling time for each channel    
   1133                  (++) Activate the Auto injected Mode  
   1134                  (++) Activate the Discontinuous Mode 
   1135                  (++) scan mode activation  
   1136                  (++) External/software trigger source   
   1137                  (++) External trigger edge 
   1138                  (++) injected channels sequencer.
   1139              
   1140                (#) Get the Specified Injected channel conversion data: This subsection 
   1141                    provides an important function in the ADC peripheral since it returns the 
   1142                    converted data of the specific injected channel.
   1143          
   1144          @endverbatim
   1145            * @{
   1146            */ 
   1147          /**
   1148            * @brief  Configures for the selected ADC injected channel its corresponding
   1149            *         rank in the sequencer and its sample time.
   1150            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1151            * @param  ADC_Channel: the ADC channel to configure. 
   1152            *          This parameter can be one of the following values:
   1153            *            @arg ADC_Channel_0: ADC Channel0 selected
   1154            *            @arg ADC_Channel_1: ADC Channel1 selected
   1155            *            @arg ADC_Channel_2: ADC Channel2 selected
   1156            *            @arg ADC_Channel_3: ADC Channel3 selected
   1157            *            @arg ADC_Channel_4: ADC Channel4 selected
   1158            *            @arg ADC_Channel_5: ADC Channel5 selected
   1159            *            @arg ADC_Channel_6: ADC Channel6 selected
   1160            *            @arg ADC_Channel_7: ADC Channel7 selected
   1161            *            @arg ADC_Channel_8: ADC Channel8 selected
   1162            *            @arg ADC_Channel_9: ADC Channel9 selected
   1163            *            @arg ADC_Channel_10: ADC Channel10 selected
   1164            *            @arg ADC_Channel_11: ADC Channel11 selected
   1165            *            @arg ADC_Channel_12: ADC Channel12 selected
   1166            *            @arg ADC_Channel_13: ADC Channel13 selected
   1167            *            @arg ADC_Channel_14: ADC Channel14 selected
   1168            *            @arg ADC_Channel_15: ADC Channel15 selected
   1169            *            @arg ADC_Channel_16: ADC Channel16 selected
   1170            *            @arg ADC_Channel_17: ADC Channel17 selected
   1171            *            @arg ADC_Channel_18: ADC Channel18 selected                       
   1172            * @param  Rank: The rank in the injected group sequencer. 
   1173            *          This parameter must be between 1 to 4.
   1174            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1175            *          This parameter can be one of the following values:
   1176            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
   1177            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
   1178            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
   1179            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
   1180            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
   1181            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
   1182            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
   1183            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
   1184            * @retval None
   1185            */

   \                                 In section .text, align 2, keep-with-next
   1186          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1187          {
   \                     ADC_InjectedChannelConfig: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1188            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2600             MOVS     R6,#+0
   1189            /* Check the parameters */
   1190            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1191            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1192            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1193            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1194            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1195            if (ADC_Channel > ADC_Channel_9)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x290A             CMP      R1,#+10
   \   0000000C   0xDB13             BLT.N    ??ADC_InjectedChannelConfig_0
   1196            {
   1197              /* Get the old register value */
   1198              tmpreg1 = ADCx->SMPR1;
   \   0000000E   0x68C4             LDR      R4,[R0, #+12]
   1199              /* Calculate the mask to clear */
   1200              tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
   \   00000010   0x2507             MOVS     R5,#+7
   \   00000012   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \   00000016   0x2703             MOVS     R7,#+3
   \   00000018   0xFB16 0xF607      SMULBB   R6,R6,R7
   \   0000001C   0x40B5             LSLS     R5,R5,R6
   1201              /* Clear the old sample time */
   1202              tmpreg1 &= ~tmpreg2;
   \   0000001E   0x43AC             BICS     R4,R4,R5
   1203              /* Calculate the mask to set */
   1204              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   \   00000020   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000022   0xF1B1 0x050A      SUBS     R5,R1,#+10
   \   00000026   0x2603             MOVS     R6,#+3
   \   00000028   0xFB15 0xF506      SMULBB   R5,R5,R6
   \   0000002C   0xFA13 0xF505      LSLS     R5,R3,R5
   1205              /* Set the new sample time */
   1206              tmpreg1 |= tmpreg2;
   \   00000030   0x432C             ORRS     R4,R5,R4
   1207              /* Store the new register value */
   1208              ADCx->SMPR1 = tmpreg1;
   \   00000032   0x60C4             STR      R4,[R0, #+12]
   \   00000034   0xE00E             B.N      ??ADC_InjectedChannelConfig_1
   1209            }
   1210            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1211            {
   1212              /* Get the old register value */
   1213              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_InjectedChannelConfig_0: (+1)
   \   00000036   0x6904             LDR      R4,[R0, #+16]
   1214              /* Calculate the mask to clear */
   1215              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   \   00000038   0x2507             MOVS     R5,#+7
   \   0000003A   0x2603             MOVS     R6,#+3
   \   0000003C   0xFB11 0xF606      SMULBB   R6,R1,R6
   \   00000040   0x40B5             LSLS     R5,R5,R6
   1216              /* Clear the old sample time */
   1217              tmpreg1 &= ~tmpreg2;
   \   00000042   0x43AC             BICS     R4,R4,R5
   1218              /* Calculate the mask to set */
   1219              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \   00000044   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000046   0x2503             MOVS     R5,#+3
   \   00000048   0xFB11 0xF505      SMULBB   R5,R1,R5
   \   0000004C   0xFA13 0xF505      LSLS     R5,R3,R5
   1220              /* Set the new sample time */
   1221              tmpreg1 |= tmpreg2;
   \   00000050   0x432C             ORRS     R4,R5,R4
   1222              /* Store the new register value */
   1223              ADCx->SMPR2 = tmpreg1;
   \   00000052   0x6104             STR      R4,[R0, #+16]
   1224            }
   1225            /* Rank configuration */
   1226            /* Get the old register value */
   1227            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedChannelConfig_1: (+1)
   \   00000054   0x6B84             LDR      R4,[R0, #+56]
   1228            /* Get JL value: Number = JL+1 */
   1229            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   \   00000056   0xF3C4 0x5601      UBFX     R6,R4,#+20,#+2
   1230            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1231            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \   0000005A   0x231F             MOVS     R3,#+31
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0x1CD5             ADDS     R5,R2,#+3
   \   00000060   0x1BAD             SUBS     R5,R5,R6
   \   00000062   0x1E6D             SUBS     R5,R5,#+1
   \   00000064   0x2705             MOVS     R7,#+5
   \   00000066   0xFB15 0xF507      SMULBB   R5,R5,R7
   \   0000006A   0xFA13 0xF505      LSLS     R5,R3,R5
   1232            /* Clear the old JSQx bits for the selected rank */
   1233            tmpreg1 &= ~tmpreg2;
   \   0000006E   0x43AC             BICS     R4,R4,R5
   1234            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1235            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000074   0x1CD2             ADDS     R2,R2,#+3
   \   00000076   0x1B92             SUBS     R2,R2,R6
   \   00000078   0x1E52             SUBS     R2,R2,#+1
   \   0000007A   0x2305             MOVS     R3,#+5
   \   0000007C   0xFB12 0xF203      SMULBB   R2,R2,R3
   \   00000080   0xFA11 0xF502      LSLS     R5,R1,R2
   1236            /* Set the JSQx bits for the selected rank */
   1237            tmpreg1 |= tmpreg2;
   \   00000084   0x432C             ORRS     R4,R5,R4
   1238            /* Store the new register value */
   1239            ADCx->JSQR = tmpreg1;
   \   00000086   0x6384             STR      R4,[R0, #+56]
   1240          }
   \   00000088   0xBCF0             POP      {R4-R7}
   \   0000008A   0x4770             BX       LR               ;; return
   1241          
   1242          /**
   1243            * @brief  Configures the sequencer length for injected channels
   1244            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1245            * @param  Length: The sequencer length. 
   1246            *          This parameter must be a number between 1 to 4.
   1247            * @retval None
   1248            */

   \                                 In section .text, align 2, keep-with-next
   1249          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1250          {
   1251            uint32_t tmpreg1 = 0;
   \                     ADC_InjectedSequencerLengthConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1252            uint32_t tmpreg2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   1253            /* Check the parameters */
   1254            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1255            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1256            
   1257            /* Get the old register value */
   1258            tmpreg1 = ADCx->JSQR;
   \   00000004   0x6B82             LDR      R2,[R0, #+56]
   1259            
   1260            /* Clear the old injected sequence length JL bits */
   1261            tmpreg1 &= JSQR_JL_RESET;
   \   00000006   0xF432 0x1240      BICS     R2,R2,#0x300000
   1262            
   1263            /* Set the injected sequence length JL bits */
   1264            tmpreg2 = Length - 1; 
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x1E4B             SUBS     R3,R1,#+1
   1265            tmpreg1 |= tmpreg2 << 20;
   \   0000000E   0xEA52 0x5203      ORRS     R2,R2,R3, LSL #+20
   1266            
   1267            /* Store the new register value */
   1268            ADCx->JSQR = tmpreg1;
   \   00000012   0x6382             STR      R2,[R0, #+56]
   1269          }
   \   00000014   0x4770             BX       LR               ;; return
   1270          
   1271          /**
   1272            * @brief  Set the injected channels conversion value offset
   1273            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1274            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1275            *          This parameter can be one of the following values:
   1276            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1277            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1278            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1279            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1280            * @param  Offset: the offset value for the selected ADC injected channel
   1281            *          This parameter must be a 12bit value.
   1282            * @retval None
   1283            */

   \                                 In section .text, align 2, keep-with-next
   1284          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1285          {
   \                     ADC_SetInjectedOffset: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1286              __IO uint32_t tmp = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x9300             STR      R3,[SP, #+0]
   1287            /* Check the parameters */
   1288            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1289            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1290            assert_param(IS_ADC_OFFSET(Offset));
   1291            
   1292            tmp = (uint32_t)ADCx;
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1293            tmp += ADC_InjectedChannel;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   1294            
   1295            /* Set the selected injected channel data offset */
   1296           *(__IO uint32_t *) tmp = (uint32_t)Offset;
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x6002             STR      R2,[R0, #+0]
   1297          }
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
   1298          
   1299           /**
   1300            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1301            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1302            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
   1303            *          This parameter can be one of the following values:                    
   1304            *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
   1305            *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
   1306            *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
   1307            *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1308            *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
   1309            *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1310            *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1311            *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1312            *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1313            *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1314            *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
   1315            *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
   1316            *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
   1317            *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
   1318            *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
   1319            *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1320            * @retval None
   1321            */

   \                                 In section .text, align 2, keep-with-next
   1322          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1323          {
   1324            uint32_t tmpreg = 0;
   \                     ADC_ExternalTrigInjectedConvConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1325            /* Check the parameters */
   1326            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1327            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   1328            
   1329            /* Get the old register value */
   1330            tmpreg = ADCx->CR2;
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   1331            
   1332            /* Clear the old external event selection for injected group */
   1333            tmpreg &= CR2_JEXTSEL_RESET;
   \   00000004   0xF432 0x2270      BICS     R2,R2,#0xF0000
   1334            
   1335            /* Set the external event selection for injected group */
   1336            tmpreg |= ADC_ExternalTrigInjecConv;
   \   00000008   0x430A             ORRS     R2,R1,R2
   1337            
   1338            /* Store the new register value */
   1339            ADCx->CR2 = tmpreg;
   \   0000000A   0x6082             STR      R2,[R0, #+8]
   1340          }
   \   0000000C   0x4770             BX       LR               ;; return
   1341          
   1342          /**
   1343            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1344            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1345            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
   1346            *         to start injected conversion. 
   1347            *          This parameter can be one of the following values:
   1348            *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
   1349            *                                                     injected conversion
   1350            *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
   1351            *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
   1352            *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
   1353            *                                                               and falling edge
   1354            * @retval None
   1355            */

   \                                 In section .text, align 2, keep-with-next
   1356          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1357          {
   1358            uint32_t tmpreg = 0;
   \                     ADC_ExternalTrigInjectedConvEdgeConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1359            /* Check the parameters */
   1360            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1361            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   1362            /* Get the old register value */
   1363            tmpreg = ADCx->CR2;
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   1364            /* Clear the old external trigger edge for injected group */
   1365            tmpreg &= CR2_JEXTEN_RESET;
   \   00000004   0xF432 0x1240      BICS     R2,R2,#0x300000
   1366            /* Set the new external trigger edge for injected group */
   1367            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   \   00000008   0x430A             ORRS     R2,R1,R2
   1368            /* Store the new register value */
   1369            ADCx->CR2 = tmpreg;
   \   0000000A   0x6082             STR      R2,[R0, #+8]
   1370          }
   \   0000000C   0x4770             BX       LR               ;; return
   1371          
   1372          /**
   1373            * @brief  Enables the selected ADC software start conversion of the injected channels.
   1374            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1375            * @retval None
   1376            */

   \                                 In section .text, align 2, keep-with-next
   1377          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1378          {
   1379            /* Check the parameters */
   1380            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1381            /* Enable the selected ADC conversion for injected group */
   1382            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   \                     ADC_SoftwareStartInjectedConv: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0xF451 0x0180      ORRS     R1,R1,#0x400000
   \   00000006   0x6081             STR      R1,[R0, #+8]
   1383          }
   \   00000008   0x4770             BX       LR               ;; return
   1384          
   1385          /**
   1386            * @brief  Gets the selected ADC Software start injected conversion Status.
   1387            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1388            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1389            */

   \                                 In section .text, align 2, keep-with-next
   1390          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1391          {
   1392            FlagStatus bitstatus = RESET;
   \                     ADC_GetSoftwareStartInjectedConvCmdStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1393            /* Check the parameters */
   1394            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1395            
   1396            /* Check the status of JSWSTART bit */
   1397            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x0240             LSLS     R0,R0,#+9
   \   00000006   0xD501             BPL.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   1398            {
   1399              /* JSWSTART bit is set */
   1400              bitstatus = SET;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xE000             B.N      ??ADC_GetSoftwareStartInjectedConvCmdStatus_1
   1401            }
   1402            else
   1403            {
   1404              /* JSWSTART bit is reset */
   1405              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_0: (+1)
   \   0000000C   0x2100             MOVS     R1,#+0
   1406            }
   1407            /* Return the JSWSTART bit status */
   1408            return  bitstatus;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_1: (+1)
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
   1409          }
   1410          
   1411          /**
   1412            * @brief  Enables or disables the selected ADC automatic injected group 
   1413            *         conversion after regular one.
   1414            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1415            * @param  NewState: new state of the selected ADC auto injected conversion
   1416            *          This parameter can be: ENABLE or DISABLE.
   1417            * @retval None
   1418            */

   \                                 In section .text, align 2, keep-with-next
   1419          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1420          {
   1421            /* Check the parameters */
   1422            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1423            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1424            if (NewState != DISABLE)
   \                     ADC_AutoInjectedConvCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   1425            {
   1426              /* Enable the selected ADC automatic injected group conversion */
   1427              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF451 0x6180      ORRS     R1,R1,#0x400
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   \   0000000E   0xE003             B.N      ??ADC_AutoInjectedConvCmd_1
   1428            }
   1429            else
   1430            {
   1431              /* Disable the selected ADC automatic injected group conversion */
   1432              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   \                     ??ADC_AutoInjectedConvCmd_0: (+1)
   \   00000010   0x6841             LDR      R1,[R0, #+4]
   \   00000012   0xF431 0x6180      BICS     R1,R1,#0x400
   \   00000016   0x6041             STR      R1,[R0, #+4]
   1433            }
   1434          }
   \                     ??ADC_AutoInjectedConvCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1435          
   1436          /**
   1437            * @brief  Enables or disables the discontinuous mode for injected group 
   1438            *         channel for the specified ADC
   1439            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1440            * @param  NewState: new state of the selected ADC discontinuous mode on injected
   1441            *         group channel.
   1442            *          This parameter can be: ENABLE or DISABLE.
   1443            * @retval None
   1444            */

   \                                 In section .text, align 2, keep-with-next
   1445          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1446          {
   1447            /* Check the parameters */
   1448            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1449            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1450            if (NewState != DISABLE)
   \                     ADC_InjectedDiscModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   1451            {
   1452              /* Enable the selected ADC injected discontinuous mode */
   1453              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   \   0000000E   0xE003             B.N      ??ADC_InjectedDiscModeCmd_1
   1454            }
   1455            else
   1456            {
   1457              /* Disable the selected ADC injected discontinuous mode */
   1458              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   \                     ??ADC_InjectedDiscModeCmd_0: (+1)
   \   00000010   0x6841             LDR      R1,[R0, #+4]
   \   00000012   0xF431 0x5180      BICS     R1,R1,#0x1000
   \   00000016   0x6041             STR      R1,[R0, #+4]
   1459            }
   1460          }
   \                     ??ADC_InjectedDiscModeCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1461          
   1462          /**
   1463            * @brief  Returns the ADC injected channel conversion result
   1464            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1465            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1466            *          This parameter can be one of the following values:
   1467            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1468            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1469            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1470            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1471            * @retval The Data conversion value.
   1472            */

   \                                 In section .text, align 2, keep-with-next
   1473          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1474          {
   \                     ADC_GetInjectedConversionValue: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1475            __IO uint32_t tmp = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
   1476            
   1477            /* Check the parameters */
   1478            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1479            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1480          
   1481            tmp = (uint32_t)ADCx;
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1482            tmp += ADC_InjectedChannel + JDR_OFFSET;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x3128             ADDS     R1,R1,#+40
   \   0000000E   0x1808             ADDS     R0,R1,R0
   \   00000010   0x9000             STR      R0,[SP, #+0]
   1483            
   1484            /* Returns the selected injected channel conversion data value */
   1485            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0x4770             BX       LR               ;; return
   1486          }
   1487          /**
   1488            * @}
   1489            */
   1490          
   1491          /** @defgroup ADC_Group7 Interrupts and flags management functions
   1492           *  @brief   Interrupts and flags management functions
   1493           *
   1494          @verbatim   
   1495           ===============================================================================
   1496                      ##### Interrupts and flags management functions #####
   1497           ===============================================================================  
   1498          
   1499              [..] This section provides functions allowing to configure the ADC Interrupts 
   1500                   and to get the status and clear flags and Interrupts pending bits.
   1501            
   1502              [..] Each ADC provides 4 Interrupts sources and 6 Flags which can be divided
   1503                  into 3 groups:
   1504            
   1505            *** Flags and Interrupts for ADC regular channels ***
   1506            =====================================================
   1507              [..]
   1508                (+) Flags :
   1509                  (##) ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1510          
   1511                  (##) ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate 
   1512                       (depending on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() )
   1513                       the end of:
   1514                       (+++) a regular CHANNEL conversion 
   1515                       (+++) sequence of regular GROUP conversions .
   1516          
   1517                  (##) ADC_FLAG_STRT: Regular channel start ==> to indicate when regular 
   1518                       CHANNEL conversion starts.
   1519              [..]
   1520                (+) Interrupts :
   1521                  (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
   1522                       event.  
   1523                  (##) ADC_IT_EOC : specifies the interrupt source for Regular channel end
   1524                       of conversion event.
   1525            
   1526            
   1527            *** Flags and Interrupts for ADC Injected channels ***
   1528            ======================================================
   1529              [..]
   1530                (+) Flags :
   1531                  (##) ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate 
   1532                       at the end of injected GROUP conversion  
   1533                        
   1534                  (##) ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
   1535                       injected GROUP conversion starts.
   1536              [..]
   1537                (+) Interrupts :
   1538                  (##) ADC_IT_JEOC : specifies the interrupt source for Injected channel 
   1539                       end of conversion event.     
   1540          
   1541            *** General Flags and Interrupts for the ADC ***
   1542            ================================================ 
   1543              [..]
   1544                (+)Flags :
   1545                  (##) ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
   1546                       crosses the programmed thresholds values.
   1547              [..]          
   1548                (+) Interrupts :
   1549                  (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
   1550          
   1551            
   1552              [..] The user should identify which mode will be used in his application to 
   1553                   manage the ADC controller events: Polling mode or Interrupt mode.
   1554            
   1555              [..] In the Polling Mode it is advised to use the following functions:
   1556                (+) ADC_GetFlagStatus() : to check if flags events occur. 
   1557                (+) ADC_ClearFlag()     : to clear the flags events.
   1558                
   1559              [..] In the Interrupt Mode it is advised to use the following functions:
   1560                (+) ADC_ITConfig()          : to enable or disable the interrupt source.
   1561                (+) ADC_GetITStatus()       : to check if Interrupt occurs.
   1562                (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1563                                             (corresponding Flag). 
   1564          @endverbatim
   1565            * @{
   1566            */ 
   1567          /**
   1568            * @brief  Enables or disables the specified ADC interrupts.
   1569            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1570            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1571            *          This parameter can be one of the following values:
   1572            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1573            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1574            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1575            *            @arg ADC_IT_OVR: Overrun interrupt enable                       
   1576            * @param  NewState: new state of the specified ADC interrupts.
   1577            *          This parameter can be: ENABLE or DISABLE.
   1578            * @retval None
   1579            */

   \                                 In section .text, align 2, keep-with-next
   1580          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1581          {
   1582            uint32_t itmask = 0;
   \                     ADC_ITConfig: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   1583            /* Check the parameters */
   1584            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1585            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1586            assert_param(IS_ADC_IT(ADC_IT)); 
   1587          
   1588            /* Get the ADC IT index */
   1589            itmask = (uint8_t)ADC_IT;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x000B             MOVS     R3,R1
   1590            itmask = (uint32_t)0x01 << itmask;    
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xFA11 0xF303      LSLS     R3,R1,R3
   1591          
   1592            if (NewState != DISABLE)
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD003             BEQ.N    ??ADC_ITConfig_0
   1593            {
   1594              /* Enable the selected ADC interrupts */
   1595              ADCx->CR1 |= itmask;
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x4319             ORRS     R1,R3,R1
   \   00000016   0x6041             STR      R1,[R0, #+4]
   \   00000018   0xE002             B.N      ??ADC_ITConfig_1
   1596            }
   1597            else
   1598            {
   1599              /* Disable the selected ADC interrupts */
   1600              ADCx->CR1 &= (~(uint32_t)itmask);
   \                     ??ADC_ITConfig_0: (+1)
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0x4399             BICS     R1,R1,R3
   \   0000001E   0x6041             STR      R1,[R0, #+4]
   1601            }
   1602          }
   \                     ??ADC_ITConfig_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1603          
   1604          /**
   1605            * @brief  Checks whether the specified ADC flag is set or not.
   1606            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1607            * @param  ADC_FLAG: specifies the flag to check. 
   1608            *          This parameter can be one of the following values:
   1609            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1610            *            @arg ADC_FLAG_EOC: End of conversion flag
   1611            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1612            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1613            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1614            *            @arg ADC_FLAG_OVR: Overrun flag                                                 
   1615            * @retval The new state of ADC_FLAG (SET or RESET).
   1616            */

   \                                 In section .text, align 2, keep-with-next
   1617          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1618          {
   1619            FlagStatus bitstatus = RESET;
   \                     ADC_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1620            /* Check the parameters */
   1621            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1622            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1623          
   1624            /* Check the status of the specified ADC flag */
   1625            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD001             BEQ.N    ??ADC_GetFlagStatus_0
   1626            {
   1627              /* ADC_FLAG is set */
   1628              bitstatus = SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xE000             B.N      ??ADC_GetFlagStatus_1
   1629            }
   1630            else
   1631            {
   1632              /* ADC_FLAG is reset */
   1633              bitstatus = RESET;
   \                     ??ADC_GetFlagStatus_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
   1634            }
   1635            /* Return the ADC_FLAG status */
   1636            return  bitstatus;
   \                     ??ADC_GetFlagStatus_1: (+1)
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1637          }
   1638          
   1639          /**
   1640            * @brief  Clears the ADCx's pending flags.
   1641            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1642            * @param  ADC_FLAG: specifies the flag to clear. 
   1643            *          This parameter can be any combination of the following values:
   1644            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1645            *            @arg ADC_FLAG_EOC: End of conversion flag
   1646            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1647            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1648            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1649            *            @arg ADC_FLAG_OVR: Overrun flag                          
   1650            * @retval None
   1651            */

   \                                 In section .text, align 2, keep-with-next
   1652          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1653          {
   1654            /* Check the parameters */
   1655            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1656            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1657          
   1658            /* Clear the selected ADC flags */
   1659            ADCx->SR = ~(uint32_t)ADC_FLAG;
   \                     ADC_ClearFlag: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x43C9             MVNS     R1,R1
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1660          }
   \   00000006   0x4770             BX       LR               ;; return
   1661          
   1662          /**
   1663            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1664            * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
   1665            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1666            *          This parameter can be one of the following values:
   1667            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1668            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1669            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1670            *            @arg ADC_IT_OVR: Overrun interrupt mask                        
   1671            * @retval The new state of ADC_IT (SET or RESET).
   1672            */

   \                                 In section .text, align 2, keep-with-next
   1673          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1674          {
   \                     ADC_GetITStatus: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1675            ITStatus bitstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
   1676            uint32_t itmask = 0, enablestatus = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   1677          
   1678            /* Check the parameters */
   1679            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1680            assert_param(IS_ADC_IT(ADC_IT));
   1681          
   1682            /* Get the ADC IT index */
   1683            itmask = ADC_IT >> 8;
   \   00000008   0x000A             MOVS     R2,R1
   \   0000000A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   0x0A12             LSRS     R2,R2,#+8
   \   0000000E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   1684          
   1685            /* Get the ADC_IT enable bit status */
   1686            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
   \   00000010   0x6843             LDR      R3,[R0, #+4]
   \   00000012   0x2401             MOVS     R4,#+1
   \   00000014   0xFA14 0xF101      LSLS     R1,R4,R1
   \   00000018   0x400B             ANDS     R3,R1,R3
   1687          
   1688            /* Check the status of the specified ADC interrupt */
   1689            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x4210             TST      R0,R2
   \   0000001E   0xD003             BEQ.N    ??ADC_GetITStatus_0
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ.N    ??ADC_GetITStatus_0
   1690            {
   1691              /* ADC_IT is set */
   1692              bitstatus = SET;
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xE000             B.N      ??ADC_GetITStatus_1
   1693            }
   1694            else
   1695            {
   1696              /* ADC_IT is reset */
   1697              bitstatus = RESET;
   \                     ??ADC_GetITStatus_0: (+1)
   \   00000028   0x2200             MOVS     R2,#+0
   1698            }
   1699            /* Return the ADC_IT status */
   1700            return  bitstatus;
   \                     ??ADC_GetITStatus_1: (+1)
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
   1701          }
   1702          
   1703          /**
   1704            * @brief  Clears the ADCx's interrupt pending bits.
   1705            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1706            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1707            *          This parameter can be one of the following values:
   1708            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1709            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1710            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1711            *            @arg ADC_IT_OVR: Overrun interrupt mask                         
   1712            * @retval None
   1713            */

   \                                 In section .text, align 2, keep-with-next
   1714          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1715          {
   1716            uint8_t itmask = 0;
   \                     ADC_ClearITPendingBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1717            /* Check the parameters */
   1718            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1719            assert_param(IS_ADC_IT(ADC_IT)); 
   1720            /* Get the ADC IT index */
   1721            itmask = (uint8_t)(ADC_IT >> 8);
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x0A0A             LSRS     R2,R1,#+8
   1722            /* Clear the selected ADC interrupt pending bits */
   1723            ADCx->SR = ~(uint32_t)itmask;
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x43D1             MVNS     R1,R2
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   1724          }                    
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xFCFFFEFF         DC32     0xfcfffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xC0FFF7FD         DC32     0xc0fff7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0xFFFC30E0         DC32     0xfffc30e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0xFF3FFDFF         DC32     0xff3ffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40012308         DC32     0x40012308
   1725          /**
   1726            * @}
   1727            */ 
   1728          
   1729          /**
   1730            * @}
   1731            */
   1732          
   1733          /**
   1734            * @}
   1735            */ 
   1736          
   1737          /**
   1738            * @}
   1739            */ 
   1740          
   1741          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_AnalogWatchdogCmd
       0   ADC_AnalogWatchdogSingleChannelConfig
       0   ADC_AnalogWatchdogThresholdsConfig
       0   ADC_AutoInjectedConvCmd
       0   ADC_ClearFlag
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_CommonInit
       0   ADC_CommonStructInit
       0   ADC_ContinuousModeCmd
       0   ADC_DMACmd
       0   ADC_DMARequestAfterLastTransferCmd
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   ADC_DiscModeChannelCountConfig
       0   ADC_DiscModeCmd
       0   ADC_EOCOnEachRegularChannelCmd
       0   ADC_ExternalTrigInjectedConvConfig
       0   ADC_ExternalTrigInjectedConvEdgeConfig
       0   ADC_GetConversionValue
       0   ADC_GetFlagStatus
       4   ADC_GetITStatus
       4   ADC_GetInjectedConversionValue
       0   ADC_GetMultiModeConversionValue
       0   ADC_GetSoftwareStartConvStatus
       0   ADC_GetSoftwareStartInjectedConvCmdStatus
       0   ADC_ITConfig
       8   ADC_Init
      16   ADC_InjectedChannelConfig
       0   ADC_InjectedDiscModeCmd
       0   ADC_InjectedSequencerLengthConfig
       0   ADC_MultiModeDMARequestAfterLastTransferCmd
      16   ADC_RegularChannelConfig
       4   ADC_SetInjectedOffset
       0   ADC_SoftwareStartConv
       0   ADC_SoftwareStartInjectedConv
       0   ADC_StructInit
       0   ADC_TempSensorVrefintCmd
       0   ADC_VBATCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
      14  ADC_AnalogWatchdogCmd
      16  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
       8  ADC_ClearFlag
      14  ADC_ClearITPendingBit
      26  ADC_Cmd
      32  ADC_CommonInit
      18  ADC_CommonStructInit
      26  ADC_ContinuousModeCmd
      26  ADC_DMACmd
      26  ADC_DMARequestAfterLastTransferCmd
      24  ADC_DeInit
      22  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_EOCOnEachRegularChannelCmd
      14  ADC_ExternalTrigInjectedConvConfig
      14  ADC_ExternalTrigInjectedConvEdgeConfig
       6  ADC_GetConversionValue
      22  ADC_GetFlagStatus
      50  ADC_GetITStatus
      28  ADC_GetInjectedConversionValue
       6  ADC_GetMultiModeConversionValue
      20  ADC_GetSoftwareStartConvStatus
      20  ADC_GetSoftwareStartInjectedConvCmdStatus
      34  ADC_ITConfig
      74  ADC_Init
     140  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      22  ADC_InjectedSequencerLengthConfig
      34  ADC_MultiModeDMARequestAfterLastTransferCmd
     212  ADC_RegularChannelConfig
      26  ADC_SetInjectedOffset
      10  ADC_SoftwareStartConv
      10  ADC_SoftwareStartInjectedConv
      30  ADC_StructInit
      34  ADC_TempSensorVrefintCmd
      34  ADC_VBATCmd

 
 1 230 bytes in section .text
 
 1 230 bytes of CODE memory

Errors: none
Warnings: none
