###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       26/Mar/2017  20:09:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
#    Command line =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\List
#        -o
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\List\stm32f4xx_i2c.lst
#    Object file  =  
#        C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\Obj\stm32f4xx_i2c.o
#
###############################################################################

C:\proj\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           + Initialization and Configuration
     10            *           + Data transfers
     11            *           + PEC management
     12            *           + DMA transfers management
     13            *           + Interrupts, events and flags management 
     14            *           
     15              @verbatim    
     16           ===============================================================================
     17                              ##### How to use this driver #####
     18           ===============================================================================
     19              [..]
     20                (#) Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
     21                    function for I2C1, I2C2 or I2C3.
     22            
     23                (#) Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
     24                    RCC_AHBPeriphClockCmd() function. 
     25            
     26                (#) Peripherals alternate function: 
     27                  (++) Connect the pin to the desired peripherals' Alternate 
     28                       Function (AF) using GPIO_PinAFConfig() function
     29                  (++) Configure the desired pin in alternate function by:
     30                       GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31                  (++) Select the type, pull-up/pull-down and output speed via 
     32                       GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33                  (++) Call GPIO_Init() function
     34                       Recommended configuration is Push-Pull, Pull-up, Open-Drain.
     35                       Add an external pull up if necessary (typically 4.7 KOhm).      
     36                    
     37                (#) Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     38                    Address using the I2C_Init() function.
     39            
     40                (#) Optionally you can enable/configure the following parameters without
     41                    re-initialization (i.e there is no need to call again I2C_Init() function):
     42                  (++) Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     43                  (++) Enable the dual addressing mode using I2C_DualAddressCmd() function
     44                  (++) Enable the general call using the I2C_GeneralCallCmd() function
     45                  (++) Enable the clock stretching using I2C_StretchClockCmd() function
     46                  (++) Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     47                       function.
     48                  (++) Configure the NACK position for Master Receiver mode in case of 
     49                       2 bytes reception using the function I2C_NACKPositionConfig().  
     50                  (++) Enable the PEC Calculation using I2C_CalculatePEC() function
     51                  (++) For SMBus Mode: 
     52                    (+++) Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     53                    (+++) Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     54            
     55                (#) Enable the NVIC and the corresponding interrupt using the function 
     56                    I2C_ITConfig() if you need to use interrupt mode. 
     57            
     58                (#) When using the DMA mode 
     59                  (++) Configure the DMA using DMA_Init() function
     60                  (++) Active the needed channel Request using I2C_DMACmd() or
     61                       I2C_DMALastTransferCmd() function.
     62                  -@@- When using DMA mode, I2C interrupts may be used at the same time to
     63                       control the communication flow (Start/Stop/Ack... events and errors).
     64             
     65                (#) Enable the I2C using the I2C_Cmd() function.
     66             
     67                (#) Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
     68                    transfers. 
     69            
     70              @endverbatim  
     71            ******************************************************************************
     72            * @attention
     73            *
     74            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     75            *
     76            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     77            * You may not use this file except in compliance with the License.
     78            * You may obtain a copy of the License at:
     79            *
     80            *        http://www.st.com/software_license_agreement_liberty_v2
     81            *
     82            * Unless required by applicable law or agreed to in writing, software 
     83            * distributed under the License is distributed on an "AS IS" BASIS, 
     84            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     85            * See the License for the specific language governing permissions and
     86            * limitations under the License.
     87            *
     88            ******************************************************************************  
     89            */ 
     90          
     91          /* Includes ------------------------------------------------------------------*/
     92          #include "stm32f4xx_i2c.h"
     93          #include "stm32f4xx_rcc.h"
     94          
     95          /** @addtogroup STM32F4xx_StdPeriph_Driver
     96            * @{
     97            */
     98          
     99          /** @defgroup I2C 
    100            * @brief I2C driver modules
    101            * @{
    102            */ 
    103          
    104          /* Private typedef -----------------------------------------------------------*/
    105          /* Private define ------------------------------------------------------------*/
    106          
    107          #define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
    108          #define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
    109          #define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    110          
    111          /* Private macro -------------------------------------------------------------*/
    112          /* Private variables ---------------------------------------------------------*/
    113          /* Private function prototypes -----------------------------------------------*/
    114          /* Private functions ---------------------------------------------------------*/
    115          
    116          /** @defgroup I2C_Private_Functions
    117            * @{
    118            */
    119          
    120          /** @defgroup I2C_Group1 Initialization and Configuration functions
    121           *  @brief   Initialization and Configuration functions 
    122           *
    123          @verbatim   
    124           ===============================================================================
    125                      ##### Initialization and Configuration functions #####
    126           ===============================================================================  
    127          
    128          @endverbatim
    129            * @{
    130            */
    131          
    132          /**
    133            * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
    134            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    135            * @retval None
    136            */

   \                                 In section .text, align 2, keep-with-next
    137          void I2C_DeInit(I2C_TypeDef* I2Cx)
    138          {
   \                     I2C_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139            /* Check the parameters */
    140            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    141          
    142            if (I2Cx == I2C1)
   \   00000002   0x....             LDR.N    R1,??DataTable1  ;; 0x40005400
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD10A             BNE.N    ??I2C_DeInit_0
    143            {
    144              /* Enable I2C1 reset state */
    145              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000000E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    146              /* Release I2C1 from reset state */
    147              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000018   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000001C   0xE01A             B.N      ??I2C_DeInit_1
    148            }
    149            else if (I2Cx == I2C2)
   \                     ??I2C_DeInit_0: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40005800
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD10A             BNE.N    ??I2C_DeInit_2
    150            {
    151              /* Enable I2C2 reset state */
    152              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000002A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    153              /* Release I2C2 from reset state */
    154              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000034   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000038   0xE00C             B.N      ??I2C_DeInit_1
    155            }
    156            else 
    157            {
    158              if (I2Cx == I2C3)
   \                     ??I2C_DeInit_2: (+1)
   \   0000003A   0x....             LDR.N    R1,??DataTable1_2  ;; 0x40005c00
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD109             BNE.N    ??I2C_DeInit_1
    159              {
    160                /* Enable I2C3 reset state */
    161                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000046   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    162                /* Release I2C3 from reset state */
    163                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000050   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    164              }
    165            }
    166          }
   \                     ??I2C_DeInit_1: (+1)
   \   00000054   0xBD01             POP      {R0,PC}          ;; return
    167          
    168          /**
    169            * @brief  Initializes the I2Cx peripheral according to the specified 
    170            *         parameters in the I2C_InitStruct.
    171            *           
    172            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency 
    173            *         (I2C peripheral input clock) must be a multiple of 10 MHz.  
    174            *           
    175            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    176            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
    177            *         the configuration information for the specified I2C peripheral.
    178            * @retval None
    179            */

   \                                 In section .text, align 2, keep-with-next
    180          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    181          {
   \                     I2C_Init: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    182            uint16_t tmpreg = 0, freqrange = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2000             MOVS     R0,#+0
    183            uint16_t result = 0x04;
   \   0000000A   0x2104             MOVS     R1,#+4
    184            uint32_t pclk1 = 8000000;
   \   0000000C   0x....             LDR.N    R1,??DataTable1_3  ;; 0x7a1200
    185            RCC_ClocksTypeDef  rcc_clocks;
    186            /* Check the parameters */
    187            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    188            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
    189            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
    190            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
    191            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    192            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
    193            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
    194          
    195          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    196            /* Get the I2Cx CR2 value */
    197            tmpreg = I2Cx->CR2;
   \   0000000E   0x88A6             LDRH     R6,[R4, #+4]
    198            /* Clear frequency FREQ[5:0] bits */
    199            tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
   \   00000010   0xF64F 0x70C0      MOVW     R0,#+65472
   \   00000014   0x4006             ANDS     R6,R0,R6
    200            /* Get pclk1 frequency value */
    201            RCC_GetClocksFreq(&rcc_clocks);
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       RCC_GetClocksFreq
    202            pclk1 = rcc_clocks.PCLK1_Frequency;
   \   0000001C   0x9902             LDR      R1,[SP, #+8]
    203            /* Set frequency bits depending on pclk1 value */
    204            freqrange = (uint16_t)(pclk1 / 1000000);
   \   0000001E   0x....             LDR.N    R0,??DataTable1_4  ;; 0xf4240
   \   00000020   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    205            tmpreg |= freqrange;
   \   00000024   0x4306             ORRS     R6,R0,R6
    206            /* Write to I2Cx CR2 */
    207            I2Cx->CR2 = tmpreg;
   \   00000026   0x80A6             STRH     R6,[R4, #+4]
    208          
    209          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    210            /* Disable the selected I2C peripheral to configure TRISE */
    211            I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
   \   00000028   0x8822             LDRH     R2,[R4, #+0]
   \   0000002A   0xF64F 0x73FE      MOVW     R3,#+65534
   \   0000002E   0x401A             ANDS     R2,R3,R2
   \   00000030   0x8022             STRH     R2,[R4, #+0]
    212            /* Reset tmpreg value */
    213            /* Clear F/S, DUTY and CCR[11:0] bits */
    214            tmpreg = 0;
   \   00000032   0x2600             MOVS     R6,#+0
    215          
    216            /* Configure speed in standard mode */
    217            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
   \   00000034   0x682A             LDR      R2,[R5, #+0]
   \   00000036   0x....             LDR.N    R3,??DataTable1_5  ;; 0x186a1
   \   00000038   0x429A             CMP      R2,R3
   \   0000003A   0xD20B             BCS.N    ??I2C_Init_0
    218            {
    219              /* Standard mode speed calculate */
    220              result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
   \   0000003C   0x682A             LDR      R2,[R5, #+0]
   \   0000003E   0x0052             LSLS     R2,R2,#+1
   \   00000040   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    221              /* Test if CCR value is under 0x4*/
    222              if (result < 0x04)
   \   00000044   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000046   0x2904             CMP      R1,#+4
   \   00000048   0xDA00             BGE.N    ??I2C_Init_1
    223              {
    224                /* Set minimum allowed value */
    225                result = 0x04;  
   \   0000004A   0x2104             MOVS     R1,#+4
    226              }
    227              /* Set speed value for standard mode */
    228              tmpreg |= result;	  
   \                     ??I2C_Init_1: (+1)
   \   0000004C   0x430E             ORRS     R6,R1,R6
    229              /* Set Maximum Rise Time for standard mode */
    230              I2Cx->TRISE = freqrange + 1; 
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x8420             STRH     R0,[R4, #+32]
   \   00000052   0xE022             B.N      ??I2C_Init_2
    231            }
    232            /* Configure speed in fast mode */
    233            /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
    234               input clock) must be a multiple of 10 MHz */
    235            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    236            {
    237              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
   \                     ??I2C_Init_0: (+1)
   \   00000054   0x88EA             LDRH     R2,[R5, #+6]
   \   00000056   0xF64B 0x73FF      MOVW     R3,#+49151
   \   0000005A   0x429A             CMP      R2,R3
   \   0000005C   0xD105             BNE.N    ??I2C_Init_3
    238              {
    239                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    240                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
   \   0000005E   0x682A             LDR      R2,[R5, #+0]
   \   00000060   0x2303             MOVS     R3,#+3
   \   00000062   0x435A             MULS     R2,R3,R2
   \   00000064   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000068   0xE006             B.N      ??I2C_Init_4
    241              }
    242              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    243              {
    244                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    245                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
   \                     ??I2C_Init_3: (+1)
   \   0000006A   0x682A             LDR      R2,[R5, #+0]
   \   0000006C   0x2319             MOVS     R3,#+25
   \   0000006E   0x435A             MULS     R2,R3,R2
   \   00000070   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    246                /* Set DUTY bit */
    247                result |= I2C_DutyCycle_16_9;
   \   00000074   0xF451 0x4180      ORRS     R1,R1,#0x4000
    248              }
    249          
    250              /* Test if CCR value is under 0x1*/
    251              if ((result & I2C_CCR_CCR) == 0)
   \                     ??I2C_Init_4: (+1)
   \   00000078   0x050A             LSLS     R2,R1,#+20
   \   0000007A   0xD101             BNE.N    ??I2C_Init_5
    252              {
    253                /* Set minimum allowed value */
    254                result |= (uint16_t)0x0001;  
   \   0000007C   0xF051 0x0101      ORRS     R1,R1,#0x1
    255              }
    256              /* Set speed value and set F/S bit for fast mode */
    257              tmpreg |= (uint16_t)(result | I2C_CCR_FS);
   \                     ??I2C_Init_5: (+1)
   \   00000080   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   00000084   0x430E             ORRS     R6,R1,R6
    258              /* Set Maximum Rise Time for fast mode */
    259              I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0xF44F 0x7196      MOV      R1,#+300
   \   0000008C   0x4348             MULS     R0,R1,R0
   \   0000008E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000092   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0x8420             STRH     R0,[R4, #+32]
    260            }
    261          
    262            /* Write to I2Cx CCR */
    263            I2Cx->CCR = tmpreg;
   \                     ??I2C_Init_2: (+1)
   \   0000009A   0x83A6             STRH     R6,[R4, #+28]
    264            /* Enable the selected I2C peripheral */
    265            I2Cx->CR1 |= I2C_CR1_PE;
   \   0000009C   0x8820             LDRH     R0,[R4, #+0]
   \   0000009E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000A2   0x8020             STRH     R0,[R4, #+0]
    266          
    267          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    268            /* Get the I2Cx CR1 value */
    269            tmpreg = I2Cx->CR1;
   \   000000A4   0x8826             LDRH     R6,[R4, #+0]
    270            /* Clear ACK, SMBTYPE and  SMBUS bits */
    271            tmpreg &= CR1_CLEAR_MASK;
   \   000000A6   0xF64F 0x30F5      MOVW     R0,#+64501
   \   000000AA   0x4006             ANDS     R6,R0,R6
    272            /* Configure I2Cx: mode and acknowledgement */
    273            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    274            /* Set ACK bit according to I2C_Ack value */
    275            tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
   \   000000AC   0x88A8             LDRH     R0,[R5, #+4]
   \   000000AE   0x8969             LDRH     R1,[R5, #+10]
   \   000000B0   0x4308             ORRS     R0,R1,R0
   \   000000B2   0x4306             ORRS     R6,R0,R6
    276            /* Write to I2Cx CR1 */
    277            I2Cx->CR1 = tmpreg;
   \   000000B4   0x8026             STRH     R6,[R4, #+0]
    278          
    279          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    280            /* Set I2Cx Own Address1 and acknowledged address */
    281            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
   \   000000B6   0x89A8             LDRH     R0,[R5, #+12]
   \   000000B8   0x8929             LDRH     R1,[R5, #+8]
   \   000000BA   0x4308             ORRS     R0,R1,R0
   \   000000BC   0x8120             STRH     R0,[R4, #+8]
    282          }
   \   000000BE   0xBD7F             POP      {R0-R6,PC}       ;; return
    283          
    284          /**
    285            * @brief  Fills each I2C_InitStruct member with its default value.
    286            * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
    287            * @retval None
    288            */

   \                                 In section .text, align 2, keep-with-next
    289          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    290          {
    291          /*---------------- Reset I2C init structure parameters values ----------------*/
    292            /* initialize the I2C_ClockSpeed member */
    293            I2C_InitStruct->I2C_ClockSpeed = 5000;
   \                     I2C_StructInit: (+1)
   \   00000000   0xF241 0x3188      MOVW     R1,#+5000
   \   00000004   0x6001             STR      R1,[R0, #+0]
    294            /* Initialize the I2C_Mode member */
    295            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    296            /* Initialize the I2C_DutyCycle member */
    297            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000A   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    298            /* Initialize the I2C_OwnAddress1 member */
    299            I2C_InitStruct->I2C_OwnAddress1 = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    300            /* Initialize the I2C_Ack member */
    301            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    302            /* Initialize the I2C_AcknowledgedAddress member */
    303            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000018   0xF44F 0x4180      MOV      R1,#+16384
   \   0000001C   0x8181             STRH     R1,[R0, #+12]
    304          }
   \   0000001E   0x4770             BX       LR               ;; return
    305          
    306          /**
    307            * @brief  Enables or disables the specified I2C peripheral.
    308            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    309            * @param  NewState: new state of the I2Cx peripheral. 
    310            *          This parameter can be: ENABLE or DISABLE.
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    314          {
    315            /* Check the parameters */
    316            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    317            assert_param(IS_FUNCTIONAL_STATE(NewState));
    318            if (NewState != DISABLE)
   \                     I2C_Cmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_Cmd_0
    319            {
    320              /* Enable the selected I2C peripheral */
    321              I2Cx->CR1 |= I2C_CR1_PE;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_Cmd_1
    322            }
    323            else
    324            {
    325              /* Disable the selected I2C peripheral */
    326              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
   \                     ??I2C_Cmd_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x72FE      MOVW     R2,#+65534
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    327            }
    328          }
   \                     ??I2C_Cmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    329          
    330          /**
    331            * @brief  Enables or disables the Analog filter of I2C peripheral.
    332            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    333            * @param  NewState: new state of the Analog filter. 
    334            *          This parameter can be: ENABLE or DISABLE.
    335            * @note   This function should be called before initializing and enabling
    336                      the I2C Peripheral.
    337            * @retval None
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    340          {
    341            /* Check the parameters */
    342            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    343            assert_param(IS_FUNCTIONAL_STATE(NewState));
    344            if (NewState != DISABLE)
   \                     I2C_AnalogFilterCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??I2C_AnalogFilterCmd_0
    345            {
    346              /* Enable the analog filter */
    347              I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
   \   00000006   0x8C81             LDRH     R1,[R0, #+36]
   \   00000008   0xF64F 0x72EF      MOVW     R2,#+65519
   \   0000000C   0x4011             ANDS     R1,R2,R1
   \   0000000E   0x8481             STRH     R1,[R0, #+36]
   \   00000010   0xE003             B.N      ??I2C_AnalogFilterCmd_1
    348            }
    349            else
    350            {
    351              /* Disable the analog filter */
    352              I2Cx->FLTR |= I2C_FLTR_ANOFF;
   \                     ??I2C_AnalogFilterCmd_0: (+1)
   \   00000012   0x8C81             LDRH     R1,[R0, #+36]
   \   00000014   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000018   0x8481             STRH     R1,[R0, #+36]
    353            }
    354          }
   \                     ??I2C_AnalogFilterCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    355          
    356          /**
    357            * @brief  Configures the Digital noise filter of I2C peripheral.
    358            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    359            * @param  I2C_DigitalFilter: Coefficient of digital noise filter. 
    360            *          This parameter can be a number between 0x00 and 0x0F.
    361            * @note   This function should be called before initializing and enabling
    362                      the I2C Peripheral.
    363            * @retval None
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
    366          {
    367            uint16_t tmpreg = 0;
   \                     I2C_DigitalFilterConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    368            
    369            /* Check the parameters */
    370            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    371            assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
    372            
    373            /* Get the old register value */
    374            tmpreg = I2Cx->FLTR;
   \   00000002   0x8C82             LDRH     R2,[R0, #+36]
    375            
    376            /* Reset I2Cx DNF bit [3:0] */
    377            tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
   \   00000004   0xF64F 0x73F0      MOVW     R3,#+65520
   \   00000008   0x401A             ANDS     R2,R3,R2
    378            
    379            /* Set I2Cx DNF coefficient */
    380            tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
   \   0000000A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000000E   0x430A             ORRS     R2,R1,R2
    381            
    382            /* Store the new register value */
    383            I2Cx->FLTR = tmpreg;
   \   00000010   0x8482             STRH     R2,[R0, #+36]
    384          }
   \   00000012   0x4770             BX       LR               ;; return
    385          
    386          /**
    387            * @brief  Generates I2Cx communication START condition.
    388            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    389            * @param  NewState: new state of the I2C START condition generation.
    390            *          This parameter can be: ENABLE or DISABLE.
    391            * @retval None.
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    394          {
    395            /* Check the parameters */
    396            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    397            assert_param(IS_FUNCTIONAL_STATE(NewState));
    398            if (NewState != DISABLE)
   \                     I2C_GenerateSTART: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_GenerateSTART_0
    399            {
    400              /* Generate a START condition */
    401              I2Cx->CR1 |= I2C_CR1_START;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_GenerateSTART_1
    402            }
    403            else
    404            {
    405              /* Disable the START condition generation */
    406              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
   \                     ??I2C_GenerateSTART_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x62FF      MOVW     R2,#+65279
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    407            }
    408          }
   \                     ??I2C_GenerateSTART_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    409          
    410          /**
    411            * @brief  Generates I2Cx communication STOP condition.
    412            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    413            * @param  NewState: new state of the I2C STOP condition generation.
    414            *          This parameter can be: ENABLE or DISABLE.
    415            * @retval None.
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    421            assert_param(IS_FUNCTIONAL_STATE(NewState));
    422            if (NewState != DISABLE)
   \                     I2C_GenerateSTOP: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_GenerateSTOP_0
    423            {
    424              /* Generate a STOP condition */
    425              I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF451 0x7100      ORRS     R1,R1,#0x200
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_GenerateSTOP_1
    426            }
    427            else
    428            {
    429              /* Disable the STOP condition generation */
    430              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
   \                     ??I2C_GenerateSTOP_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x52FF      MOVW     R2,#+65023
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    431            }
    432          }
   \                     ??I2C_GenerateSTOP_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    433          
    434          /**
    435            * @brief  Transmits the address byte to select the slave device.
    436            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    437            * @param  Address: specifies the slave address which will be transmitted
    438            * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
    439            *         or a Receiver. 
    440            *          This parameter can be one of the following values
    441            *            @arg I2C_Direction_Transmitter: Transmitter mode
    442            *            @arg I2C_Direction_Receiver: Receiver mode
    443            * @retval None.
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
    446          {
    447            /* Check the parameters */
    448            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    449            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    450            /* Test on the direction to set/reset the read/write bit */
    451            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     I2C_Send7bitAddress: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD002             BEQ.N    ??I2C_Send7bitAddress_0
    452            {
    453              /* Set the address bit0 for read */
    454              Address |= I2C_OAR1_ADD0;
   \   00000006   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000A   0xE001             B.N      ??I2C_Send7bitAddress_1
    455            }
    456            else
    457            {
    458              /* Reset the address bit0 for write */
    459              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
   \                     ??I2C_Send7bitAddress_0: (+1)
   \   0000000C   0xF011 0x01FE      ANDS     R1,R1,#0xFE
    460            }
    461            /* Send the address */
    462            I2Cx->DR = Address;
   \                     ??I2C_Send7bitAddress_1: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x8201             STRH     R1,[R0, #+16]
    463          }
   \   00000014   0x4770             BX       LR               ;; return
    464          
    465          /**
    466            * @brief  Enables or disables the specified I2C acknowledge feature.
    467            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    468            * @param  NewState: new state of the I2C Acknowledgement.
    469            *          This parameter can be: ENABLE or DISABLE.
    470            * @retval None.
    471            */

   \                                 In section .text, align 2, keep-with-next
    472          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    473          {
    474            /* Check the parameters */
    475            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    476            assert_param(IS_FUNCTIONAL_STATE(NewState));
    477            if (NewState != DISABLE)
   \                     I2C_AcknowledgeConfig: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_AcknowledgeConfig_0
    478            {
    479              /* Enable the acknowledgement */
    480              I2Cx->CR1 |= I2C_CR1_ACK;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF451 0x6180      ORRS     R1,R1,#0x400
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_AcknowledgeConfig_1
    481            }
    482            else
    483            {
    484              /* Disable the acknowledgement */
    485              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
   \                     ??I2C_AcknowledgeConfig_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x32FF      MOVW     R2,#+64511
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    486            }
    487          }
   \                     ??I2C_AcknowledgeConfig_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    488          
    489          /**
    490            * @brief  Configures the specified I2C own address2.
    491            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    492            * @param  Address: specifies the 7bit I2C own address2.
    493            * @retval None.
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    496          {
    497            uint16_t tmpreg = 0;
   \                     I2C_OwnAddress2Config: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    498          
    499            /* Check the parameters */
    500            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    501          
    502            /* Get the old register value */
    503            tmpreg = I2Cx->OAR2;
   \   00000002   0x8982             LDRH     R2,[R0, #+12]
    504          
    505            /* Reset I2Cx Own address2 bit [7:1] */
    506            tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
   \   00000004   0xF64F 0x7301      MOVW     R3,#+65281
   \   00000008   0x401A             ANDS     R2,R3,R2
    507          
    508            /* Set I2Cx Own address2 */
    509            tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \   00000010   0x430A             ORRS     R2,R1,R2
    510          
    511            /* Store the new register value */
    512            I2Cx->OAR2 = tmpreg;
   \   00000012   0x8182             STRH     R2,[R0, #+12]
    513          }
   \   00000014   0x4770             BX       LR               ;; return
    514          
    515          /**
    516            * @brief  Enables or disables the specified I2C dual addressing mode.
    517            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    518            * @param  NewState: new state of the I2C dual addressing mode.
    519            *          This parameter can be: ENABLE or DISABLE.
    520            * @retval None
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    526            assert_param(IS_FUNCTIONAL_STATE(NewState));
    527            if (NewState != DISABLE)
   \                     I2C_DualAddressCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_DualAddressCmd_0
    528            {
    529              /* Enable dual addressing mode */
    530              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
   \   00000006   0x8981             LDRH     R1,[R0, #+12]
   \   00000008   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000C   0x8181             STRH     R1,[R0, #+12]
   \   0000000E   0xE004             B.N      ??I2C_DualAddressCmd_1
    531            }
    532            else
    533            {
    534              /* Disable dual addressing mode */
    535              I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
   \                     ??I2C_DualAddressCmd_0: (+1)
   \   00000010   0x8981             LDRH     R1,[R0, #+12]
   \   00000012   0xF64F 0x72FE      MOVW     R2,#+65534
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8181             STRH     R1,[R0, #+12]
    536            }
    537          }
   \                     ??I2C_DualAddressCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    538          
    539          /**
    540            * @brief  Enables or disables the specified I2C general call feature.
    541            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    542            * @param  NewState: new state of the I2C General call.
    543            *          This parameter can be: ENABLE or DISABLE.
    544            * @retval None
    545            */

   \                                 In section .text, align 2, keep-with-next
    546          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    547          {
    548            /* Check the parameters */
    549            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    550            assert_param(IS_FUNCTIONAL_STATE(NewState));
    551            if (NewState != DISABLE)
   \                     I2C_GeneralCallCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_GeneralCallCmd_0
    552            {
    553              /* Enable generall call */
    554              I2Cx->CR1 |= I2C_CR1_ENGC;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_GeneralCallCmd_1
    555            }
    556            else
    557            {
    558              /* Disable generall call */
    559              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
   \                     ??I2C_GeneralCallCmd_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x72BF      MOVW     R2,#+65471
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    560            }
    561          }
   \                     ??I2C_GeneralCallCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    562          
    563          /**
    564            * @brief  Enables or disables the specified I2C software reset.
    565            * @note   When software reset is enabled, the I2C IOs are released (this can
    566            *         be useful to recover from bus errors).  
    567            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    568            * @param  NewState: new state of the I2C software reset.
    569            *          This parameter can be: ENABLE or DISABLE.
    570            * @retval None
    571            */

   \                                 In section .text, align 2, keep-with-next
    572          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    573          {
    574            /* Check the parameters */
    575            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    576            assert_param(IS_FUNCTIONAL_STATE(NewState));
    577            if (NewState != DISABLE)
   \                     I2C_SoftwareResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_SoftwareResetCmd_0
    578            {
    579              /* Peripheral under reset */
    580              I2Cx->CR1 |= I2C_CR1_SWRST;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE003             B.N      ??I2C_SoftwareResetCmd_1
    581            }
    582            else
    583            {
    584              /* Peripheral not under reset */
    585              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
   \                     ??I2C_SoftwareResetCmd_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0x0449             LSLS     R1,R1,#+17       ;; ZeroExtS R1,R1,#+17,#+17
   \   00000014   0x0C49             LSRS     R1,R1,#+17
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    586            }
    587          }
   \                     ??I2C_SoftwareResetCmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    588          
    589          /**
    590            * @brief  Enables or disables the specified I2C Clock stretching.
    591            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    592            * @param  NewState: new state of the I2Cx Clock stretching.
    593            *          This parameter can be: ENABLE or DISABLE.
    594            * @retval None
    595            */

   \                                 In section .text, align 2, keep-with-next
    596          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    597          {
    598            /* Check the parameters */
    599            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    600            assert_param(IS_FUNCTIONAL_STATE(NewState));
    601            if (NewState == DISABLE)
   \                     I2C_StretchClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD104             BNE.N    ??I2C_StretchClockCmd_0
    602            {
    603              /* Enable the selected I2C Clock stretching */
    604              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_StretchClockCmd_1
    605            }
    606            else
    607            {
    608              /* Disable the selected I2C Clock stretching */
    609              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
   \                     ??I2C_StretchClockCmd_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x727F      MOVW     R2,#+65407
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    610            }
    611          }
   \                     ??I2C_StretchClockCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    612          
    613          /**
    614            * @brief  Selects the specified I2C fast mode duty cycle.
    615            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    616            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    617            *          This parameter can be one of the following values:
    618            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    619            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    620            * @retval None
    621            */

   \                                 In section .text, align 2, keep-with-next
    622          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
    623          {
    624            /* Check the parameters */
    625            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    626            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    627            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
   \                     I2C_FastModeDutyCycleConfig: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000006   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
    628            {
    629              /* I2C fast mode Tlow/Thigh=2 */
    630              I2Cx->CCR &= I2C_DutyCycle_2;
   \   00000008   0x8B81             LDRH     R1,[R0, #+28]
   \   0000000A   0xF64B 0x72FF      MOVW     R2,#+49151
   \   0000000E   0x4011             ANDS     R1,R2,R1
   \   00000010   0x8381             STRH     R1,[R0, #+28]
   \   00000012   0xE003             B.N      ??I2C_FastModeDutyCycleConfig_1
    631            }
    632            else
    633            {
    634              /* I2C fast mode Tlow/Thigh=16/9 */
    635              I2Cx->CCR |= I2C_DutyCycle_16_9;
   \                     ??I2C_FastModeDutyCycleConfig_0: (+1)
   \   00000014   0x8B81             LDRH     R1,[R0, #+28]
   \   00000016   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \   0000001A   0x8381             STRH     R1,[R0, #+28]
    636            }
    637          }
   \                     ??I2C_FastModeDutyCycleConfig_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    638          
    639          /**
    640            * @brief  Selects the specified I2C NACK position in master receiver mode.
    641            * @note   This function is useful in I2C Master Receiver mode when the number
    642            *         of data to be received is equal to 2. In this case, this function 
    643            *         should be called (with parameter I2C_NACKPosition_Next) before data 
    644            *         reception starts,as described in the 2-byte reception procedure 
    645            *         recommended in Reference Manual in Section: Master receiver.                
    646            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    647            * @param  I2C_NACKPosition: specifies the NACK position. 
    648            *          This parameter can be one of the following values:
    649            *            @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
    650            *                                        received byte.  
    651            *            @arg I2C_NACKPosition_Current: indicates that current byte is the last 
    652            *                                           received byte.
    653            *            
    654            * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
    655            *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
    656            *          is intended to used in SMBUS mode. 
    657            *            
    658            * @retval None
    659            */

   \                                 In section .text, align 2, keep-with-next
    660          void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
    661          {
    662            /* Check the parameters */
    663            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    664            assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
    665            
    666            /* Check the input parameter */
    667            if (I2C_NACKPosition == I2C_NACKPosition_Next)
   \                     I2C_NACKPositionConfig: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF5B1 0x6F00      CMP      R1,#+2048
   \   00000006   0xD104             BNE.N    ??I2C_NACKPositionConfig_0
    668            {
    669              /* Next byte in shift register is the last received byte */
    670              I2Cx->CR1 |= I2C_NACKPosition_Next;
   \   00000008   0x8801             LDRH     R1,[R0, #+0]
   \   0000000A   0xF451 0x6100      ORRS     R1,R1,#0x800
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   \   00000010   0xE004             B.N      ??I2C_NACKPositionConfig_1
    671            }
    672            else
    673            {
    674              /* Current byte in shift register is the last received byte */
    675              I2Cx->CR1 &= I2C_NACKPosition_Current;
   \                     ??I2C_NACKPositionConfig_0: (+1)
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0xF24F 0x72FF      MOVW     R2,#+63487
   \   00000018   0x4011             ANDS     R1,R2,R1
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    676            }
    677          }
   \                     ??I2C_NACKPositionConfig_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    678          
    679          /**
    680            * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
    681            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    682            * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
    683            *          This parameter can be one of the following values:
    684            *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
    685            *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
    686            * @retval None
    687            */

   \                                 In section .text, align 2, keep-with-next
    688          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
    689          {
    690            /* Check the parameters */
    691            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    692            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    693            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
   \                     I2C_SMBusAlertConfig: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000006   0xD104             BNE.N    ??I2C_SMBusAlertConfig_0
    694            {
    695              /* Drive the SMBusAlert pin Low */
    696              I2Cx->CR1 |= I2C_SMBusAlert_Low;
   \   00000008   0x8801             LDRH     R1,[R0, #+0]
   \   0000000A   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   \   00000010   0xE004             B.N      ??I2C_SMBusAlertConfig_1
    697            }
    698            else
    699            {
    700              /* Drive the SMBusAlert pin High  */
    701              I2Cx->CR1 &= I2C_SMBusAlert_High;
   \                     ??I2C_SMBusAlertConfig_0: (+1)
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000018   0x4011             ANDS     R1,R2,R1
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    702            }
    703          }
   \                     ??I2C_SMBusAlertConfig_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    704          
    705          /**
    706            * @brief  Enables or disables the specified I2C ARP.
    707            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    708            * @param  NewState: new state of the I2Cx ARP. 
    709            *          This parameter can be: ENABLE or DISABLE.
    710            * @retval None
    711            */

   \                                 In section .text, align 2, keep-with-next
    712          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    713          {
    714            /* Check the parameters */
    715            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    716            assert_param(IS_FUNCTIONAL_STATE(NewState));
    717            if (NewState != DISABLE)
   \                     I2C_ARPCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_ARPCmd_0
    718            {
    719              /* Enable the selected I2C ARP */
    720              I2Cx->CR1 |= I2C_CR1_ENARP;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_ARPCmd_1
    721            }
    722            else
    723            {
    724              /* Disable the selected I2C ARP */
    725              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
   \                     ??I2C_ARPCmd_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x72EF      MOVW     R2,#+65519
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    726            }
    727          }
   \                     ??I2C_ARPCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    728          /**
    729            * @}
    730            */
    731          
    732          /** @defgroup I2C_Group2 Data transfers functions
    733           *  @brief   Data transfers functions 
    734           *
    735          @verbatim   
    736           ===============================================================================
    737                            ##### Data transfers functions #####
    738           ===============================================================================  
    739          
    740          @endverbatim
    741            * @{
    742            */
    743          
    744          /**
    745            * @brief  Sends a data byte through the I2Cx peripheral.
    746            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    747            * @param  Data: Byte to be transmitted..
    748            * @retval None
    749            */

   \                                 In section .text, align 2, keep-with-next
    750          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    751          {
    752            /* Check the parameters */
    753            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    754            /* Write in the DR register the data to be sent */
    755            I2Cx->DR = Data;
   \                     I2C_SendData: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x8201             STRH     R1,[R0, #+16]
    756          }
   \   00000004   0x4770             BX       LR               ;; return
    757          
    758          /**
    759            * @brief  Returns the most recent received data by the I2Cx peripheral.
    760            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    761            * @retval The value of the received data.
    762            */

   \                                 In section .text, align 2, keep-with-next
    763          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    764          {
    765            /* Check the parameters */
    766            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    767            /* Return the data in the DR register */
    768            return (uint8_t)I2Cx->DR;
   \                     I2C_ReceiveData: (+1)
   \   00000000   0x8A00             LDRH     R0,[R0, #+16]
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x4770             BX       LR               ;; return
    769          }
    770          
    771          /**
    772            * @}
    773            */
    774          
    775          /** @defgroup I2C_Group3 PEC management functions
    776           *  @brief   PEC management functions 
    777           *
    778          @verbatim   
    779           ===============================================================================
    780                            ##### PEC management functions #####
    781           ===============================================================================  
    782          
    783          @endverbatim
    784            * @{
    785            */
    786          
    787          /**
    788            * @brief  Enables or disables the specified I2C PEC transfer.
    789            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    790            * @param  NewState: new state of the I2C PEC transmission.
    791            *          This parameter can be: ENABLE or DISABLE.
    792            * @retval None
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    798            assert_param(IS_FUNCTIONAL_STATE(NewState));
    799            if (NewState != DISABLE)
   \                     I2C_TransmitPEC: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_TransmitPEC_0
    800            {
    801              /* Enable the selected I2C PEC transmission */
    802              I2Cx->CR1 |= I2C_CR1_PEC;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_TransmitPEC_1
    803            }
    804            else
    805            {
    806              /* Disable the selected I2C PEC transmission */
    807              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
   \                     ??I2C_TransmitPEC_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64E 0x72FF      MOVW     R2,#+61439
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    808            }
    809          }
   \                     ??I2C_TransmitPEC_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    810          
    811          /**
    812            * @brief  Selects the specified I2C PEC position.
    813            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    814            * @param  I2C_PECPosition: specifies the PEC position. 
    815            *          This parameter can be one of the following values:
    816            *            @arg I2C_PECPosition_Next: indicates that the next byte is PEC
    817            *            @arg I2C_PECPosition_Current: indicates that current byte is PEC
    818            *       
    819            * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
    820            *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
    821            *          is intended to used in I2C mode.
    822            *                
    823            * @retval None
    824            */

   \                                 In section .text, align 2, keep-with-next
    825          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
    826          {
    827            /* Check the parameters */
    828            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    829            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    830            if (I2C_PECPosition == I2C_PECPosition_Next)
   \                     I2C_PECPositionConfig: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF5B1 0x6F00      CMP      R1,#+2048
   \   00000006   0xD104             BNE.N    ??I2C_PECPositionConfig_0
    831            {
    832              /* Next byte in shift register is PEC */
    833              I2Cx->CR1 |= I2C_PECPosition_Next;
   \   00000008   0x8801             LDRH     R1,[R0, #+0]
   \   0000000A   0xF451 0x6100      ORRS     R1,R1,#0x800
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   \   00000010   0xE004             B.N      ??I2C_PECPositionConfig_1
    834            }
    835            else
    836            {
    837              /* Current byte in shift register is PEC */
    838              I2Cx->CR1 &= I2C_PECPosition_Current;
   \                     ??I2C_PECPositionConfig_0: (+1)
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0xF24F 0x72FF      MOVW     R2,#+63487
   \   00000018   0x4011             ANDS     R1,R2,R1
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    839            }
    840          }
   \                     ??I2C_PECPositionConfig_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    841          
    842          /**
    843            * @brief  Enables or disables the PEC value calculation of the transferred bytes.
    844            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    845            * @param  NewState: new state of the I2Cx PEC value calculation.
    846            *          This parameter can be: ENABLE or DISABLE.
    847            * @retval None
    848            */

   \                                 In section .text, align 2, keep-with-next
    849          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    850          {
    851            /* Check the parameters */
    852            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    853            assert_param(IS_FUNCTIONAL_STATE(NewState));
    854            if (NewState != DISABLE)
   \                     I2C_CalculatePEC: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_CalculatePEC_0
    855            {
    856              /* Enable the selected I2C PEC calculation */
    857              I2Cx->CR1 |= I2C_CR1_ENPEC;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??I2C_CalculatePEC_1
    858            }
    859            else
    860            {
    861              /* Disable the selected I2C PEC calculation */
    862              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
   \                     ??I2C_CalculatePEC_0: (+1)
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x72DF      MOVW     R2,#+65503
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    863            }
    864          }
   \                     ??I2C_CalculatePEC_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    865          
    866          /**
    867            * @brief  Returns the PEC value for the specified I2C.
    868            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    869            * @retval The PEC value.
    870            */

   \                                 In section .text, align 2, keep-with-next
    871          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    872          {
    873            /* Check the parameters */
    874            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    875            /* Return the selected I2C PEC value */
    876            return ((I2Cx->SR2) >> 8);
   \                     I2C_GetPEC: (+1)
   \   00000000   0x8B00             LDRH     R0,[R0, #+24]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x0A00             LSRS     R0,R0,#+8
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
    877          }
    878          
    879          /**
    880            * @}
    881            */
    882          
    883          /** @defgroup I2C_Group4 DMA transfers management functions
    884           *  @brief   DMA transfers management functions 
    885           *
    886          @verbatim   
    887           ===============================================================================
    888                          ##### DMA transfers management functions #####
    889           ===============================================================================  
    890            This section provides functions allowing to configure the I2C DMA channels 
    891            requests.
    892            
    893          @endverbatim
    894            * @{
    895            */
    896          
    897          /**
    898            * @brief  Enables or disables the specified I2C DMA requests.
    899            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    900            * @param  NewState: new state of the I2C DMA transfer.
    901            *          This parameter can be: ENABLE or DISABLE.
    902            * @retval None
    903            */

   \                                 In section .text, align 2, keep-with-next
    904          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    905          {
    906            /* Check the parameters */
    907            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    908            assert_param(IS_FUNCTIONAL_STATE(NewState));
    909            if (NewState != DISABLE)
   \                     I2C_DMACmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_DMACmd_0
    910            {
    911              /* Enable the selected I2C DMA requests */
    912              I2Cx->CR2 |= I2C_CR2_DMAEN;
   \   00000006   0x8881             LDRH     R1,[R0, #+4]
   \   00000008   0xF451 0x6100      ORRS     R1,R1,#0x800
   \   0000000C   0x8081             STRH     R1,[R0, #+4]
   \   0000000E   0xE004             B.N      ??I2C_DMACmd_1
    913            }
    914            else
    915            {
    916              /* Disable the selected I2C DMA requests */
    917              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
   \                     ??I2C_DMACmd_0: (+1)
   \   00000010   0x8881             LDRH     R1,[R0, #+4]
   \   00000012   0xF24F 0x72FF      MOVW     R2,#+63487
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8081             STRH     R1,[R0, #+4]
    918            }
    919          }
   \                     ??I2C_DMACmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    920          
    921          /**
    922            * @brief  Specifies that the next DMA transfer is the last one.
    923            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    924            * @param  NewState: new state of the I2C DMA last transfer.
    925            *          This parameter can be: ENABLE or DISABLE.
    926            * @retval None
    927            */

   \                                 In section .text, align 2, keep-with-next
    928          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    929          {
    930            /* Check the parameters */
    931            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    932            assert_param(IS_FUNCTIONAL_STATE(NewState));
    933            if (NewState != DISABLE)
   \                     I2C_DMALastTransferCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2C_DMALastTransferCmd_0
    934            {
    935              /* Next DMA transfer is the last transfer */
    936              I2Cx->CR2 |= I2C_CR2_LAST;
   \   00000006   0x8881             LDRH     R1,[R0, #+4]
   \   00000008   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   0000000C   0x8081             STRH     R1,[R0, #+4]
   \   0000000E   0xE004             B.N      ??I2C_DMALastTransferCmd_1
    937            }
    938            else
    939            {
    940              /* Next DMA transfer is not the last transfer */
    941              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
   \                     ??I2C_DMALastTransferCmd_0: (+1)
   \   00000010   0x8881             LDRH     R1,[R0, #+4]
   \   00000012   0xF64E 0x72FF      MOVW     R2,#+61439
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8081             STRH     R1,[R0, #+4]
    942            }
    943          }
   \                     ??I2C_DMALastTransferCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    944          
    945          /**
    946            * @}
    947            */
    948          
    949          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    950           *  @brief   Interrupts, events and flags management functions
    951           *
    952          @verbatim   
    953           ===============================================================================
    954                    ##### Interrupts, events and flags management functions #####
    955           ===============================================================================
    956              [..]
    957              This section provides functions allowing to configure the I2C Interrupts 
    958              sources and check or clear the flags or pending bits status.
    959              The user should identify which mode will be used in his application to manage 
    960              the communication: Polling mode, Interrupt mode or DMA mode. 
    961          
    962          
    963                          ##### I2C State Monitoring Functions #####                   
    964           =============================================================================== 
    965              [..]  
    966              This I2C driver provides three different ways for I2C state monitoring
    967              depending on the application requirements and constraints:
    968                   
    969             
    970               (#) Basic state monitoring (Using I2C_CheckEvent() function)
    971               
    972                  It compares the status registers (SR1 and SR2) content to a given event
    973                  (can be the combination of one or more flags).
    974                  It returns SUCCESS if the current status includes the given flags 
    975                  and returns ERROR if one or more flags are missing in the current status.
    976          
    977                    (++) When to use
    978                       (+++) This function is suitable for most applications as well as for startup 
    979                         activity since the events are fully described in the product reference 
    980                         manual (RM0090).
    981                       (+++) It is also suitable for users who need to define their own events.
    982          
    983                    (++) Limitations
    984                         If an error occurs (ie. error flags are set besides to the monitored 
    985                         flags), the I2C_CheckEvent() function may return SUCCESS despite 
    986                         the communication hold or corrupted real state. 
    987                         In this case, it is advised to use error interrupts to monitor 
    988                         the error events and handle them in the interrupt IRQ handler.
    989                   
    990               -@@- For error management, it is advised to use the following functions:
    991                  (+@@) I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    992                  (+@@) I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
    993                        Where x is the peripheral instance (I2C1, I2C2 ...)
    994                  (+@@) I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
    995                        I2Cx_ER_IRQHandler() function in order to determine which error occurred.
    996                  (+@@) I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
    997                        and/or I2C_GenerateStop() in order to clear the error flag and source 
    998                        and return to correct  communication status.
    999                       
   1000           
   1001               (#) Advanced state monitoring (Using the function I2C_GetLastEvent())
   1002          
   1003                  Using the function I2C_GetLastEvent() which returns the image of both status 
   1004                  registers in a single word (uint32_t) (Status Register 2 value is shifted left 
   1005                  by 16 bits and concatenated to Status Register 1).
   1006          
   1007                    (++) When to use
   1008                       (+++) This function is suitable for the same applications above but it 
   1009                         allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
   1010                         function.
   1011                       (+++) The returned value could be compared to events already defined in 
   1012                         the library (stm32f4xx_i2c.h) or to custom values defined by user.
   1013                         This function is suitable when multiple flags are monitored at the 
   1014                         same time.
   1015                       (+++) At the opposite of I2C_CheckEvent() function, this function allows 
   1016                         user to choose when an event is accepted (when all events flags are 
   1017                         set and no other flags are set or just when the needed flags are set 
   1018                         like I2C_CheckEvent() function.
   1019          
   1020                    (++) Limitations
   1021                       (+++) User may need to define his own events.
   1022                       (+++) Same remark concerning the error management is applicable for this 
   1023                         function if user decides to check only regular communication flags 
   1024                         (and ignores error flags).
   1025                
   1026           
   1027               (#) Flag-based state monitoring (Using the function I2C_GetFlagStatus())
   1028               
   1029                Using the function I2C_GetFlagStatus() which simply returns the status of 
   1030                one single flag (ie. I2C_FLAG_RXNE ...). 
   1031          
   1032                    (++) When to use
   1033                       (+++) This function could be used for specific applications or in debug 
   1034                         phase.
   1035                       (+++) It is suitable when only one flag checking is needed (most I2C 
   1036                         events are monitored through multiple flags).
   1037                    (++) Limitations: 
   1038                       (+++) When calling this function, the Status register is accessed. 
   1039                         Some flags are cleared when the status register is accessed. 
   1040                         So checking the status of one Flag, may clear other ones.
   1041                       (+++) Function may need to be called twice or more in order to monitor 
   1042                         one single event.
   1043           
   1044             For detailed description of Events, please refer to section I2C_Events in 
   1045             stm32f4xx_i2c.h file.
   1046                 
   1047          @endverbatim
   1048            * @{
   1049            */
   1050             
   1051          /**
   1052            * @brief  Reads the specified I2C register and returns its value.
   1053            * @param  I2C_Register: specifies the register to read.
   1054            *          This parameter can be one of the following values:
   1055            *            @arg I2C_Register_CR1:  CR1 register.
   1056            *            @arg I2C_Register_CR2:   CR2 register.
   1057            *            @arg I2C_Register_OAR1:  OAR1 register.
   1058            *            @arg I2C_Register_OAR2:  OAR2 register.
   1059            *            @arg I2C_Register_DR:    DR register.
   1060            *            @arg I2C_Register_SR1:   SR1 register.
   1061            *            @arg I2C_Register_SR2:   SR2 register.
   1062            *            @arg I2C_Register_CCR:   CCR register.
   1063            *            @arg I2C_Register_TRISE: TRISE register.
   1064            * @retval The value of the read register.
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
   1067          {
   \                     I2C_ReadRegister: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1068            __IO uint32_t tmp = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
   1069          
   1070            /* Check the parameters */
   1071            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1072            assert_param(IS_I2C_REGISTER(I2C_Register));
   1073          
   1074            tmp = (uint32_t) I2Cx;
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1075            tmp += I2C_Register;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   1076          
   1077            /* Return the selected register value */
   1078            return (*(__IO uint16_t *) tmp);
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0x8800             LDRH     R0,[R0, #+0]
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0x4770             BX       LR               ;; return
   1079          }
   1080          
   1081          /**
   1082            * @brief  Enables or disables the specified I2C interrupts.
   1083            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1084            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
   1085            *          This parameter can be any combination of the following values:
   1086            *            @arg I2C_IT_BUF: Buffer interrupt mask
   1087            *            @arg I2C_IT_EVT: Event interrupt mask
   1088            *            @arg I2C_IT_ERR: Error interrupt mask
   1089            * @param  NewState: new state of the specified I2C interrupts.
   1090            *          This parameter can be: ENABLE or DISABLE.
   1091            * @retval None
   1092            */

   \                                 In section .text, align 2, keep-with-next
   1093          void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
   1094          {
   1095            /* Check the parameters */
   1096            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1097            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1098            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
   1099            
   1100            if (NewState != DISABLE)
   \                     I2C_ITConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??I2C_ITConfig_0
   1101            {
   1102              /* Enable the selected I2C interrupts */
   1103              I2Cx->CR2 |= I2C_IT;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
   \   0000000C   0xE003             B.N      ??I2C_ITConfig_1
   1104            }
   1105            else
   1106            {
   1107              /* Disable the selected I2C interrupts */
   1108              I2Cx->CR2 &= (uint16_t)~I2C_IT;
   \                     ??I2C_ITConfig_0: (+1)
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
   \   00000010   0xEA32 0x0101      BICS     R1,R2,R1
   \   00000014   0x8081             STRH     R1,[R0, #+4]
   1109            }
   1110          }
   \                     ??I2C_ITConfig_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
   1111          
   1112          /*
   1113           ===============================================================================
   1114                                    1. Basic state monitoring                    
   1115           ===============================================================================  
   1116           */
   1117          
   1118          /**
   1119            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1120            *         as parameter.
   1121            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1122            * @param  I2C_EVENT: specifies the event to be checked. 
   1123            *          This parameter can be one of the following values:
   1124            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1125            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1126            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
   1127            *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
   1128            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1129            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1130            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
   1131            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1132            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1133            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
   1134            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1135            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1136            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1137            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1138            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
   1139            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1140            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1141            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1142            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1143            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1144            *     
   1145            * @note   For detailed description of Events, please refer to section I2C_Events
   1146            *         in stm32f4xx_i2c.h file.
   1147            *    
   1148            * @retval An ErrorStatus enumeration value:
   1149            *           - SUCCESS: Last event is equal to the I2C_EVENT
   1150            *           - ERROR: Last event is different from the I2C_EVENT
   1151            */

   \                                 In section .text, align 2, keep-with-next
   1152          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
   1153          {
   1154            uint32_t lastevent = 0;
   \                     I2C_CheckEvent: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1155            uint32_t flag1 = 0, flag2 = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1156            ErrorStatus status = ERROR;
   \   00000006   0x2200             MOVS     R2,#+0
   1157          
   1158            /* Check the parameters */
   1159            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1160            assert_param(IS_I2C_EVENT(I2C_EVENT));
   1161          
   1162            /* Read the I2Cx status register */
   1163            flag1 = I2Cx->SR1;
   \   00000008   0x8A82             LDRH     R2,[R0, #+20]
   1164            flag2 = I2Cx->SR2;
   \   0000000A   0x8B03             LDRH     R3,[R0, #+24]
   1165            flag2 = flag2 << 16;
   \   0000000C   0x041B             LSLS     R3,R3,#+16
   1166          
   1167            /* Get the last event value from I2C status register */
   1168            lastevent = (flag1 | flag2) & FLAG_MASK;
   \   0000000E   0xEA53 0x0002      ORRS     R0,R3,R2
   \   00000012   0xF020 0x427F      BIC      R2,R0,#0xFF000000
   1169          
   1170            /* Check whether the last event contains the I2C_EVENT */
   1171            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   \   00000016   0xEA11 0x0002      ANDS     R0,R1,R2
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??I2C_CheckEvent_0
   1172            {
   1173              /* SUCCESS: last event is equal to I2C_EVENT */
   1174              status = SUCCESS;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xE000             B.N      ??I2C_CheckEvent_1
   1175            }
   1176            else
   1177            {
   1178              /* ERROR: last event is different from I2C_EVENT */
   1179              status = ERROR;
   \                     ??I2C_CheckEvent_0: (+1)
   \   00000022   0x2200             MOVS     R2,#+0
   1180            }
   1181            /* Return status */
   1182            return status;
   \                     ??I2C_CheckEvent_1: (+1)
   \   00000024   0x0010             MOVS     R0,R2
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x4770             BX       LR               ;; return
   1183          }
   1184          
   1185          /*
   1186           ===============================================================================
   1187                                    2. Advanced state monitoring                   
   1188           ===============================================================================  
   1189           */
   1190          
   1191          /**
   1192            * @brief  Returns the last I2Cx Event.
   1193            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1194            *     
   1195            * @note   For detailed description of Events, please refer to section I2C_Events
   1196            *         in stm32f4xx_i2c.h file.
   1197            *    
   1198            * @retval The last event
   1199            */

   \                                 In section .text, align 2, keep-with-next
   1200          uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
   1201          {
   1202            uint32_t lastevent = 0;
   \                     I2C_GetLastEvent: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1203            uint32_t flag1 = 0, flag2 = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   1204          
   1205            /* Check the parameters */
   1206            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1207          
   1208            /* Read the I2Cx status register */
   1209            flag1 = I2Cx->SR1;
   \   00000006   0x8A81             LDRH     R1,[R0, #+20]
   1210            flag2 = I2Cx->SR2;
   \   00000008   0x8B02             LDRH     R2,[R0, #+24]
   1211            flag2 = flag2 << 16;
   \   0000000A   0x0412             LSLS     R2,R2,#+16
   1212          
   1213            /* Get the last event value from I2C status register */
   1214            lastevent = (flag1 | flag2) & FLAG_MASK;
   \   0000000C   0xEA52 0x0001      ORRS     R0,R2,R1
   \   00000010   0xF020 0x417F      BIC      R1,R0,#0xFF000000
   1215          
   1216            /* Return status */
   1217            return lastevent;
   \   00000014   0x0008             MOVS     R0,R1
   \   00000016   0x4770             BX       LR               ;; return
   1218          }
   1219          
   1220          /*
   1221           ===============================================================================
   1222                                    3. Flag-based state monitoring                   
   1223           ===============================================================================  
   1224           */
   1225          
   1226          /**
   1227            * @brief  Checks whether the specified I2C flag is set or not.
   1228            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1229            * @param  I2C_FLAG: specifies the flag to check. 
   1230            *          This parameter can be one of the following values:
   1231            *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1232            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1233            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1234            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1235            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1236            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1237            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1238            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1239            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1240            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1241            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1242            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1243            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1244            *            @arg I2C_FLAG_BERR: Bus error flag
   1245            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1246            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1247            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1248            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1249            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1250            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1251            *                                Address matched flag (Slave mode)"ENDAD"
   1252            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1253            * @retval The new state of I2C_FLAG (SET or RESET).
   1254            */

   \                                 In section .text, align 2, keep-with-next
   1255          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1256          {
   \                     I2C_GetFlagStatus: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   \   00000002   0x0002             MOVS     R2,R0
   1257            FlagStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
   1258            __IO uint32_t i2creg = 0, i2cxbase = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1259          
   1260            /* Check the parameters */
   1261            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1262            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1263          
   1264            /* Get the I2Cx peripheral base address */
   1265            i2cxbase = (uint32_t)I2Cx;
   \   0000000E   0x9200             STR      R2,[SP, #+0]
   1266            
   1267            /* Read flag register index */
   1268            i2creg = I2C_FLAG >> 28;
   \   00000010   0x0F08             LSRS     R0,R1,#+28
   \   00000012   0x9001             STR      R0,[SP, #+4]
   1269            
   1270            /* Get bit[23:0] of the flag */
   1271            I2C_FLAG &= FLAG_MASK;
   \   00000014   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   1272            
   1273            if(i2creg != 0)
   \   00000018   0x9801             LDR      R0,[SP, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??I2C_GetFlagStatus_0
   1274            {
   1275              /* Get the I2Cx SR1 register address */
   1276              i2cxbase += 0x14;
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x3014             ADDS     R0,R0,#+20
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xE003             B.N      ??I2C_GetFlagStatus_1
   1277            }
   1278            else
   1279            {
   1280              /* Flag in I2Cx SR2 Register */
   1281              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   \                     ??I2C_GetFlagStatus_0: (+1)
   \   00000026   0x0C09             LSRS     R1,R1,#+16
   1282              /* Get the I2Cx SR2 register address */
   1283              i2cxbase += 0x18;
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x3018             ADDS     R0,R0,#+24
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   1284            }
   1285            
   1286            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   \                     ??I2C_GetFlagStatus_1: (+1)
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD001             BEQ.N    ??I2C_GetFlagStatus_2
   1287            {
   1288              /* I2C_FLAG is set */
   1289              bitstatus = SET;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE000             B.N      ??I2C_GetFlagStatus_3
   1290            }
   1291            else
   1292            {
   1293              /* I2C_FLAG is reset */
   1294              bitstatus = RESET;
   \                     ??I2C_GetFlagStatus_2: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   1295            }
   1296            
   1297            /* Return the I2C_FLAG status */
   1298            return  bitstatus;
   \                     ??I2C_GetFlagStatus_3: (+1)
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xB002             ADD      SP,SP,#+8
   \   00000040   0x4770             BX       LR               ;; return
   1299          }
   1300          
   1301          /**
   1302            * @brief  Clears the I2Cx's pending flags.
   1303            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1304            * @param  I2C_FLAG: specifies the flag to clear. 
   1305            *          This parameter can be any combination of the following values:
   1306            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1307            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1308            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1309            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1310            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1311            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1312            *            @arg I2C_FLAG_BERR: Bus error flag
   1313            *   
   1314            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1315            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1316            *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1317            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1318            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1319            *          second byte of the address in DR register.
   1320            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1321            *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1322            *          read/write to I2C_DR register (I2C_SendData()).
   1323            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1324            *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1325            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1326            * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1327            *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1328            *          register (I2C_SendData()).
   1329            *  
   1330            * @retval None
   1331            */

   \                                 In section .text, align 2, keep-with-next
   1332          void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1333          {
   1334            uint32_t flagpos = 0;
   \                     I2C_ClearFlag: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1335            /* Check the parameters */
   1336            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1337            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1338            /* Get the I2C flag position */
   1339            flagpos = I2C_FLAG & FLAG_MASK;
   \   00000002   0xF021 0x427F      BIC      R2,R1,#0xFF000000
   1340            /* Clear the selected I2C flag */
   1341            I2Cx->SR1 = (uint16_t)~flagpos;
   \   00000006   0x43D1             MVNS     R1,R2
   \   00000008   0x8281             STRH     R1,[R0, #+20]
   1342          }
   \   0000000A   0x4770             BX       LR               ;; return
   1343          
   1344          /**
   1345            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1346            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1347            * @param  I2C_IT: specifies the interrupt source to check. 
   1348            *          This parameter can be one of the following values:
   1349            *            @arg I2C_IT_SMBALERT: SMBus Alert flag
   1350            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1351            *            @arg I2C_IT_PECERR: PEC error in reception flag
   1352            *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1353            *            @arg I2C_IT_AF: Acknowledge failure flag
   1354            *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1355            *            @arg I2C_IT_BERR: Bus error flag
   1356            *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1357            *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1358            *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1359            *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1360            *            @arg I2C_IT_BTF: Byte transfer finished flag
   1361            *            @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
   1362            *                              Address matched flag (Slave mode)"ENDAD"
   1363            *            @arg I2C_IT_SB: Start bit flag (Master mode)
   1364            * @retval The new state of I2C_IT (SET or RESET).
   1365            */

   \                                 In section .text, align 2, keep-with-next
   1366          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1367          {
   1368            ITStatus bitstatus = RESET;
   \                     I2C_GetITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1369            uint32_t enablestatus = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   1370          
   1371            /* Check the parameters */
   1372            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1373            assert_param(IS_I2C_GET_IT(I2C_IT));
   1374          
   1375            /* Check if the interrupt source is enabled or not */
   1376            enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
   \   00000004   0x8882             LDRH     R2,[R0, #+4]
   \   00000006   0xEA12 0x4211      ANDS     R2,R2,R1, LSR #+16
   \   0000000A   0xF412 0x62E0      ANDS     R2,R2,#0x700
   1377            
   1378            /* Get bit[23:0] of the flag */
   1379            I2C_IT &= FLAG_MASK;
   \   0000000E   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   1380          
   1381            /* Check the status of the specified I2C flag */
   1382            if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
   \   00000012   0x8A80             LDRH     R0,[R0, #+20]
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD003             BEQ.N    ??I2C_GetITStatus_0
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD001             BEQ.N    ??I2C_GetITStatus_0
   1383            {
   1384              /* I2C_IT is set */
   1385              bitstatus = SET;
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xE000             B.N      ??I2C_GetITStatus_1
   1386            }
   1387            else
   1388            {
   1389              /* I2C_IT is reset */
   1390              bitstatus = RESET;
   \                     ??I2C_GetITStatus_0: (+1)
   \   00000020   0x2200             MOVS     R2,#+0
   1391            }
   1392            /* Return the I2C_IT status */
   1393            return  bitstatus;
   \                     ??I2C_GetITStatus_1: (+1)
   \   00000022   0x0010             MOVS     R0,R2
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x4770             BX       LR               ;; return
   1394          }
   1395          
   1396          /**
   1397            * @brief  Clears the I2Cx's interrupt pending bits.
   1398            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1399            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
   1400            *          This parameter can be any combination of the following values:
   1401            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1402            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1403            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1404            *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1405            *            @arg I2C_IT_AF: Acknowledge failure interrupt
   1406            *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1407            *            @arg I2C_IT_BERR: Bus error interrupt
   1408            * 
   1409            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1410            *          to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1411            *          I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1412            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1413            *          operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
   1414            *          byte of the address in I2C_DR register.
   1415            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1416            *          operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
   1417            *          read/write to I2C_DR register (I2C_SendData()).
   1418            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1419            *          I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
   1420            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1421            * @note   SB (Start Bit) is cleared by software sequence: a read operation to 
   1422            *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1423            *          I2C_DR register (I2C_SendData()).
   1424            * @retval None
   1425            */

   \                                 In section .text, align 2, keep-with-next
   1426          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1427          {
   1428            uint32_t flagpos = 0;
   \                     I2C_ClearITPendingBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1429            /* Check the parameters */
   1430            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1431            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1432          
   1433            /* Get the I2C flag position */
   1434            flagpos = I2C_IT & FLAG_MASK;
   \   00000002   0xF021 0x427F      BIC      R2,R1,#0xFF000000
   1435          
   1436            /* Clear the selected I2C flag */
   1437            I2Cx->SR1 = (uint16_t)~flagpos;
   \   00000006   0x43D1             MVNS     R1,R2
   \   00000008   0x8281             STRH     R1,[R0, #+20]
   1438          }
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x000186A1         DC32     0x186a1
   1439          
   1440          /**
   1441            * @}
   1442            */
   1443          
   1444          /**
   1445            * @}
   1446            */ 
   1447          
   1448          /**
   1449            * @}
   1450            */ 
   1451          
   1452          /**
   1453            * @}
   1454            */ 
   1455          
   1456          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2C_ARPCmd
       0   I2C_AcknowledgeConfig
       0   I2C_AnalogFilterCmd
       0   I2C_CalculatePEC
       0   I2C_CheckEvent
       0   I2C_ClearFlag
       0   I2C_ClearITPendingBit
       0   I2C_Cmd
       0   I2C_DMACmd
       0   I2C_DMALastTransferCmd
       8   I2C_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   I2C_DigitalFilterConfig
       0   I2C_DualAddressCmd
       0   I2C_FastModeDutyCycleConfig
       0   I2C_GeneralCallCmd
       0   I2C_GenerateSTART
       0   I2C_GenerateSTOP
       8   I2C_GetFlagStatus
       0   I2C_GetITStatus
       0   I2C_GetLastEvent
       0   I2C_GetPEC
       0   I2C_ITConfig
      32   I2C_Init
        32   -> RCC_GetClocksFreq
       0   I2C_NACKPositionConfig
       0   I2C_OwnAddress2Config
       0   I2C_PECPositionConfig
       4   I2C_ReadRegister
       0   I2C_ReceiveData
       0   I2C_SMBusAlertConfig
       0   I2C_Send7bitAddress
       0   I2C_SendData
       0   I2C_SoftwareResetCmd
       0   I2C_StretchClockCmd
       0   I2C_StructInit
       0   I2C_TransmitPEC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
      28  I2C_ARPCmd
      28  I2C_AcknowledgeConfig
      28  I2C_AnalogFilterCmd
      28  I2C_CalculatePEC
      42  I2C_CheckEvent
      12  I2C_ClearFlag
      12  I2C_ClearITPendingBit
      28  I2C_Cmd
      28  I2C_DMACmd
      28  I2C_DMALastTransferCmd
      86  I2C_DeInit
      20  I2C_DigitalFilterConfig
      28  I2C_DualAddressCmd
      30  I2C_FastModeDutyCycleConfig
      28  I2C_GeneralCallCmd
      28  I2C_GenerateSTART
      28  I2C_GenerateSTOP
      66  I2C_GetFlagStatus
      40  I2C_GetITStatus
      24  I2C_GetLastEvent
      10  I2C_GetPEC
      24  I2C_ITConfig
     192  I2C_Init
      30  I2C_NACKPositionConfig
      22  I2C_OwnAddress2Config
      30  I2C_PECPositionConfig
      24  I2C_ReadRegister
       6  I2C_ReceiveData
      30  I2C_SMBusAlertConfig
      22  I2C_Send7bitAddress
       6  I2C_SendData
      26  I2C_SoftwareResetCmd
      28  I2C_StretchClockCmd
      32  I2C_StructInit
      28  I2C_TransmitPEC

 
 1 174 bytes in section .text
 
 1 174 bytes of CODE memory

Errors: none
Warnings: none
