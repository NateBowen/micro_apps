###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       27/Mar/2017  18:42:57
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_gpio.c
#    Command line =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_gpio.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\List
#        -o
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\List\stm32f4xx_gpio.lst
#    Object file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\Obj\stm32f4xx_gpio.o
#
###############################################################################

C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the GPIO peripheral:           
      9            *           + Initialization and Configuration
     10            *           + GPIO Read and Write
     11            *           + GPIO Alternate functions configuration
     12            * 
     13          @verbatim  
     14           ===============================================================================
     15                                ##### How to use this driver #####
     16           ===============================================================================       
     17           [..]             
     18             (#) Enable the GPIO AHB clock using the following function
     19                 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     20                         
     21             (#) Configure the GPIO pin(s) using GPIO_Init()
     22                 Four possible configuration are available for each pin:
     23                 (++) Input: Floating, Pull-up, Pull-down.
     24                 (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)
     25                      Open Drain (Pull-up, Pull-down or no Pull). In output mode, the speed 
     26                      is configurable: 2 MHz, 25 MHz, 50 MHz or 100 MHz.
     27                 (++) Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull) Open 
     28                      Drain (Pull-up, Pull-down or no Pull).
     29                 (++) Analog: required mode when a pin is to be used as ADC channel or DAC 
     30                      output.
     31             
     32             (#) Peripherals alternate function:
     33                 (++) For ADC and DAC, configure the desired pin in analog mode using 
     34                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AN;
     35                      (+++) For other peripherals (TIM, USART...):
     36                      (+++) Connect the pin to the desired peripherals' Alternate 
     37                               Function (AF) using GPIO_PinAFConfig() function
     38                      (+++) Configure the desired pin in alternate function mode using
     39                               GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     40                      (+++) Select the type, pull-up/pull-down and output speed via 
     41                               GPIO_PuPd, GPIO_OType and GPIO_Speed members
     42                      (+++) Call GPIO_Init() function
     43                    
     44             (#) To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()
     45                      
     46             (#) To set/reset the level of a pin configured in output mode use 
     47                 GPIO_SetBits()/GPIO_ResetBits()
     48                           
     49             (#) During and just after reset, the alternate functions are not 
     50                 active and the GPIO pins are configured in input floating mode (except JTAG
     51                 pins).
     52            
     53             (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     54                 (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     55                 priority over the GPIO function.
     56            
     57             (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     58                 general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     59                 The HSE has priority over the GPIO function.
     60                         
     61          @endverbatim        
     62            *
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     67            *
     68            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     69            * You may not use this file except in compliance with the License.
     70            * You may obtain a copy of the License at:
     71            *
     72            *        http://www.st.com/software_license_agreement_liberty_v2
     73            *
     74            * Unless required by applicable law or agreed to in writing, software 
     75            * distributed under the License is distributed on an "AS IS" BASIS, 
     76            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     77            * See the License for the specific language governing permissions and
     78            * limitations under the License.
     79            *
     80            ******************************************************************************
     81            */
     82          
     83          /* Includes ------------------------------------------------------------------*/
     84          #include "stm32f4xx_gpio.h"
     85          #include "stm32f4xx_rcc.h"
     86          
     87          /** @addtogroup STM32F4xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup GPIO 
     92            * @brief GPIO driver modules
     93            * @{
     94            */ 
     95          
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /** @defgroup GPIO_Private_Functions
    104            * @{
    105            */ 
    106          
    107          /** @defgroup GPIO_Group1 Initialization and Configuration
    108           *  @brief   Initialization and Configuration
    109           *
    110          @verbatim   
    111           ===============================================================================
    112                           ##### Initialization and Configuration #####
    113           ===============================================================================  
    114          
    115          @endverbatim
    116            * @{
    117            */
    118          
    119          /**
    120            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    121            * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
    122            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    123            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    124            * @retval None
    125            */

   \                                 In section .text, align 2, keep-with-next
    126          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
    127          {
   \                     GPIO_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    128            /* Check the parameters */
    129            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    130          
    131            if (GPIOx == GPIOA)
   \   00000002   0x....             LDR.N    R1,??DataTable0  ;; 0x40020000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD108             BNE.N    ??GPIO_DeInit_0
    132            {
    133              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    134              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   00000018   0xE060             B.N      ??GPIO_DeInit_1
    135            }
    136            else if (GPIOx == GPIOB)
   \                     ??GPIO_DeInit_0: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40020400
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD108             BNE.N    ??GPIO_DeInit_2
    137            {
    138              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    139              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   00000030   0xE054             B.N      ??GPIO_DeInit_1
    140            }
    141            else if (GPIOx == GPIOC)
   \                     ??GPIO_DeInit_2: (+1)
   \   00000032   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40020800
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD108             BNE.N    ??GPIO_DeInit_3
    142            {
    143              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    144              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   00000048   0xE048             B.N      ??GPIO_DeInit_1
    145            }
    146            else if (GPIOx == GPIOD)
   \                     ??GPIO_DeInit_3: (+1)
   \   0000004A   0x....             LDR.N    R1,??DataTable0_3  ;; 0x40020c00
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD108             BNE.N    ??GPIO_DeInit_4
    147            {
    148              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x2008             MOVS     R0,#+8
   \   00000054   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    149              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x2008             MOVS     R0,#+8
   \   0000005C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   00000060   0xE03C             B.N      ??GPIO_DeInit_1
    150            }
    151            else if (GPIOx == GPIOE)
   \                     ??GPIO_DeInit_4: (+1)
   \   00000062   0x....             LDR.N    R1,??DataTable0_4  ;; 0x40021000
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD108             BNE.N    ??GPIO_DeInit_5
    152            {
    153              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2010             MOVS     R0,#+16
   \   0000006C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    154              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   00000078   0xE030             B.N      ??GPIO_DeInit_1
    155            }
    156            else if (GPIOx == GPIOF)
   \                     ??GPIO_DeInit_5: (+1)
   \   0000007A   0x....             LDR.N    R1,??DataTable0_5  ;; 0x40021400
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD108             BNE.N    ??GPIO_DeInit_6
    157            {
    158              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x2020             MOVS     R0,#+32
   \   00000084   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    159              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   00000090   0xE024             B.N      ??GPIO_DeInit_1
    160            }
    161            else if (GPIOx == GPIOG)
   \                     ??GPIO_DeInit_6: (+1)
   \   00000092   0x....             LDR.N    R1,??DataTable0_6  ;; 0x40021800
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD108             BNE.N    ??GPIO_DeInit_7
    162            {
    163              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x2040             MOVS     R0,#+64
   \   0000009C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    164              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x2040             MOVS     R0,#+64
   \   000000A4   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   000000A8   0xE018             B.N      ??GPIO_DeInit_1
    165            }
    166            else if (GPIOx == GPIOH)
   \                     ??GPIO_DeInit_7: (+1)
   \   000000AA   0x....             LDR.N    R1,??DataTable0_7  ;; 0x40021c00
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xD108             BNE.N    ??GPIO_DeInit_8
    167            {
    168              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0x2080             MOVS     R0,#+128
   \   000000B4   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    169              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x2080             MOVS     R0,#+128
   \   000000BC   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
   \   000000C0   0xE00C             B.N      ??GPIO_DeInit_1
    170            }
    171          
    172          #if defined (STM32F40XX) || defined (STM32F427X)
    173            else
    174            {
    175              if (GPIOx == GPIOI)
   \                     ??GPIO_DeInit_8: (+1)
   \   000000C2   0x....             LDR.N    R1,??DataTable0_8  ;; 0x40022000
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD109             BNE.N    ??GPIO_DeInit_1
    176              {
    177                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0xF44F 0x7080      MOV      R0,#+256
   \   000000CE   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    178                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0xF44F 0x7080      MOV      R0,#+256
   \   000000D8   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    179              }
    180            }
    181          #endif /* STM32F40XX || STM32F427X */
    182          
    183          #if defined (STM32F429X)
    184            else if (GPIOx == GPIOI)
    185            {
    186              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
    187              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    188            }
    189            else if (GPIOx == GPIOJ)
    190            {
    191              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
    192              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
    193            }
    194            else
    195            {
    196              if (GPIOx == GPIOK)
    197              {
    198                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
    199                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    200              }
    201            }
    202          #endif /* STM32F429X */
    203          }
   \                     ??GPIO_DeInit_1: (+1)
   \   000000DC   0xBD01             POP      {R0,PC}          ;; return
    204          
    205          /**
    206            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_InitStruct.
    207            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    208            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    209            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
    210            *         the configuration information for the specified GPIO peripheral.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    214          {
   \                     GPIO_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    215            uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2400             MOVS     R4,#+0
    216          
    217            /* Check the parameters */
    218            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    219            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
    220            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    221            assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
    222          
    223            /* ------------------------- Configure the port pins ---------------- */
    224            /*-- GPIO Mode Configuration --*/
    225            for (pinpos = 0x00; pinpos < 0x10; pinpos++)
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xE047             B.N      ??GPIO_Init_0
    226            {
    227              pos = ((uint32_t)0x01) << pinpos;
   \                     ??GPIO_Init_1: (+1)
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4093             LSLS     R3,R3,R2
    228              /* Get the port pins position */
    229              currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x401C             ANDS     R4,R3,R4
    230          
    231              if (currentpin == pos)
   \   00000014   0x429C             CMP      R4,R3
   \   00000016   0xD140             BNE.N    ??GPIO_Init_2
    232              {
    233                GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
   \   00000018   0x6803             LDR      R3,[R0, #+0]
   \   0000001A   0x2403             MOVS     R4,#+3
   \   0000001C   0x0015             MOVS     R5,R2
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x006D             LSLS     R5,R5,#+1
   \   00000022   0x40AC             LSLS     R4,R4,R5
   \   00000024   0x43A3             BICS     R3,R3,R4
   \   00000026   0x6003             STR      R3,[R0, #+0]
    234                GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
   \   00000028   0x6803             LDR      R3,[R0, #+0]
   \   0000002A   0x790C             LDRB     R4,[R1, #+4]
   \   0000002C   0x0015             MOVS     R5,R2
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x006D             LSLS     R5,R5,#+1
   \   00000032   0x40AC             LSLS     R4,R4,R5
   \   00000034   0x4323             ORRS     R3,R4,R3
   \   00000036   0x6003             STR      R3,[R0, #+0]
    235          
    236                if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
   \   00000038   0x790B             LDRB     R3,[R1, #+4]
   \   0000003A   0x2B01             CMP      R3,#+1
   \   0000003C   0xD002             BEQ.N    ??GPIO_Init_3
   \   0000003E   0x790B             LDRB     R3,[R1, #+4]
   \   00000040   0x2B02             CMP      R3,#+2
   \   00000042   0xD11A             BNE.N    ??GPIO_Init_4
    237                {
    238                  /* Check Speed mode parameters */
    239                  assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    240          
    241                  /* Speed mode configuration */
    242                  GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
   \                     ??GPIO_Init_3: (+1)
   \   00000044   0x6883             LDR      R3,[R0, #+8]
   \   00000046   0x2403             MOVS     R4,#+3
   \   00000048   0x0015             MOVS     R5,R2
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x006D             LSLS     R5,R5,#+1
   \   0000004E   0x40AC             LSLS     R4,R4,R5
   \   00000050   0x43A3             BICS     R3,R3,R4
   \   00000052   0x6083             STR      R3,[R0, #+8]
    243                  GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
   \   00000054   0x6883             LDR      R3,[R0, #+8]
   \   00000056   0x794C             LDRB     R4,[R1, #+5]
   \   00000058   0x0015             MOVS     R5,R2
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x006D             LSLS     R5,R5,#+1
   \   0000005E   0x40AC             LSLS     R4,R4,R5
   \   00000060   0x4323             ORRS     R3,R4,R3
   \   00000062   0x6083             STR      R3,[R0, #+8]
    244          
    245                  /* Check Output mode parameters */
    246                  assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
    247          
    248                  /* Output mode configuration*/
    249                  GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
   \   00000064   0x6843             LDR      R3,[R0, #+4]
   \   00000066   0x2401             MOVS     R4,#+1
   \   00000068   0x4094             LSLS     R4,R4,R2
   \   0000006A   0x43A3             BICS     R3,R3,R4
   \   0000006C   0x6043             STR      R3,[R0, #+4]
    250                  GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
   \   0000006E   0x6843             LDR      R3,[R0, #+4]
   \   00000070   0x798C             LDRB     R4,[R1, #+6]
   \   00000072   0x4094             LSLS     R4,R4,R2
   \   00000074   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000076   0x4323             ORRS     R3,R4,R3
   \   00000078   0x6043             STR      R3,[R0, #+4]
    251                }
    252          
    253                /* Pull-up Pull down resistor configuration*/
    254                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
   \                     ??GPIO_Init_4: (+1)
   \   0000007A   0x68C3             LDR      R3,[R0, #+12]
   \   0000007C   0x2403             MOVS     R4,#+3
   \   0000007E   0x0015             MOVS     R5,R2
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x006D             LSLS     R5,R5,#+1
   \   00000084   0x40AC             LSLS     R4,R4,R5
   \   00000086   0x43A3             BICS     R3,R3,R4
   \   00000088   0x60C3             STR      R3,[R0, #+12]
    255                GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
   \   0000008A   0x68C3             LDR      R3,[R0, #+12]
   \   0000008C   0x79CC             LDRB     R4,[R1, #+7]
   \   0000008E   0x0015             MOVS     R5,R2
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x006D             LSLS     R5,R5,#+1
   \   00000094   0x40AC             LSLS     R4,R4,R5
   \   00000096   0x4323             ORRS     R3,R4,R3
   \   00000098   0x60C3             STR      R3,[R0, #+12]
    256              }
    257            }
   \                     ??GPIO_Init_2: (+1)
   \   0000009A   0x1C52             ADDS     R2,R2,#+1
   \                     ??GPIO_Init_0: (+1)
   \   0000009C   0x2A10             CMP      R2,#+16
   \   0000009E   0xD3B5             BCC.N    ??GPIO_Init_1
    258          }
   \   000000A0   0xBC30             POP      {R4,R5}
   \   000000A2   0x4770             BX       LR               ;; return
    259          
    260          /**
    261            * @brief  Fills each GPIO_InitStruct member with its default value.
    262            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
    263            * @retval None
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    266          {
    267            /* Reset GPIO init structure parameters values */
    268            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit: (+1)
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x6001             STR      R1,[R0, #+0]
    269            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    270            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7141             STRB     R1,[R0, #+5]
    271            GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7181             STRB     R1,[R0, #+6]
    272            GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x71C1             STRB     R1,[R0, #+7]
    273          }
   \   00000016   0x4770             BX       LR               ;; return
    274          
    275          /**
    276            * @brief  Locks GPIO Pins configuration registers.
    277            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    278            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    279            * @note   The configuration of the locked GPIO pins can no longer be modified
    280            *         until the next reset.
    281            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    282            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    283            * @param  GPIO_Pin: specifies the port bit to be locked.
    284            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    285            * @retval None
    286            */

   \                                 In section .text, align 2, keep-with-next
    287          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    288          {
   \                     GPIO_PinLockConfig: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    289            __IO uint32_t tmp = 0x00010000;
   \   00000002   0xF45F 0x3280      MOVS     R2,#+65536
   \   00000006   0x9200             STR      R2,[SP, #+0]
    290          
    291            /* Check the parameters */
    292            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    293            assert_param(IS_GPIO_PIN(GPIO_Pin));
    294          
    295            tmp |= GPIO_Pin;
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x9200             STR      R2,[SP, #+0]
    296            /* Set LCKK bit */
    297            GPIOx->LCKR = tmp;
   \   00000010   0x9A00             LDR      R2,[SP, #+0]
   \   00000012   0x61C2             STR      R2,[R0, #+28]
    298            /* Reset LCKK bit */
    299            GPIOx->LCKR =  GPIO_Pin;
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    300            /* Set LCKK bit */
    301            GPIOx->LCKR = tmp;
   \   00000018   0x9900             LDR      R1,[SP, #+0]
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
    302            /* Read LCKK bit*/
    303            tmp = GPIOx->LCKR;
   \   0000001C   0x69C1             LDR      R1,[R0, #+28]
   \   0000001E   0x9100             STR      R1,[SP, #+0]
    304            /* Read LCKK bit*/
    305            tmp = GPIOx->LCKR;
   \   00000020   0x69C0             LDR      R0,[R0, #+28]
   \   00000022   0x9000             STR      R0,[SP, #+0]
    306          }
   \   00000024   0xB001             ADD      SP,SP,#+4
   \   00000026   0x4770             BX       LR               ;; return
    307          
    308          /**
    309            * @}
    310            */
    311          
    312          /** @defgroup GPIO_Group2 GPIO Read and Write
    313           *  @brief   GPIO Read and Write
    314           *
    315          @verbatim   
    316           ===============================================================================
    317                                   ##### GPIO Read and Write #####
    318           ===============================================================================  
    319          
    320          @endverbatim
    321            * @{
    322            */
    323          
    324          /**
    325            * @brief  Reads the specified input port pin.
    326            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    327            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    328            * @param  GPIO_Pin: specifies the port bit to read.
    329            *         This parameter can be GPIO_Pin_x where x can be (0..15).
    330            * @retval The input port pin value.
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    333          {
    334            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadInputDataBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    335          
    336            /* Check the parameters */
    337            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    338            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    339          
    340            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD001             BEQ.N    ??GPIO_ReadInputDataBit_0
    341            {
    342              bitstatus = (uint8_t)Bit_SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xE000             B.N      ??GPIO_ReadInputDataBit_1
    343            }
    344            else
    345            {
    346              bitstatus = (uint8_t)Bit_RESET;
   \                     ??GPIO_ReadInputDataBit_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
    347            }
    348            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_1: (+1)
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
    349          }
    350          
    351          /**
    352            * @brief  Reads the specified GPIO input data port.
    353            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    354            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    355            * @retval GPIO input data port value.
    356            */

   \                                 In section .text, align 2, keep-with-next
    357          uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    358          {
    359            /* Check the parameters */
    360            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    361          
    362            return ((uint16_t)GPIOx->IDR);
   \                     GPIO_ReadInputData: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    363          }
    364          
    365          /**
    366            * @brief  Reads the specified output data port bit.
    367            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    368            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    369            * @param  GPIO_Pin: specifies the port bit to read.
    370            *          This parameter can be GPIO_Pin_x where x can be (0..15).
    371            * @retval The output port pin value.
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    374          {
    375            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadOutputDataBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    376          
    377            /* Check the parameters */
    378            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    379            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    380          
    381            if (((GPIOx->ODR) & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD001             BEQ.N    ??GPIO_ReadOutputDataBit_0
    382            {
    383              bitstatus = (uint8_t)Bit_SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xE000             B.N      ??GPIO_ReadOutputDataBit_1
    384            }
    385            else
    386            {
    387              bitstatus = (uint8_t)Bit_RESET;
   \                     ??GPIO_ReadOutputDataBit_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
    388            }
    389            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_1: (+1)
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
    390          }
    391          
    392          /**
    393            * @brief  Reads the specified GPIO output data port.
    394            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    395            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    396            * @retval GPIO output data port value.
    397            */

   \                                 In section .text, align 2, keep-with-next
    398          uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    399          {
    400            /* Check the parameters */
    401            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    402          
    403            return ((uint16_t)GPIOx->ODR);
   \                     GPIO_ReadOutputData: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    404          }
    405          
    406          /**
    407            * @brief  Sets the selected data port bits.
    408            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    409            *         accesses. In this way, there is no risk of an IRQ occurring between
    410            *         the read and the modify access.
    411            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    412            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    413            * @param  GPIO_Pin: specifies the port bits to be written.
    414            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    415            * @retval None
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    421            assert_param(IS_GPIO_PIN(GPIO_Pin));
    422          
    423            GPIOx->BSRRL = GPIO_Pin;
   \                     GPIO_SetBits: (+1)
   \   00000000   0x8301             STRH     R1,[R0, #+24]
    424          }
   \   00000002   0x4770             BX       LR               ;; return
    425          
    426          /**
    427            * @brief  Clears the selected data port bits.
    428            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    429            *         accesses. In this way, there is no risk of an IRQ occurring between
    430            *         the read and the modify access.
    431            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    432            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    433            * @param  GPIO_Pin: specifies the port bits to be written.
    434            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    435            * @retval None
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    438          {
    439            /* Check the parameters */
    440            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    441            assert_param(IS_GPIO_PIN(GPIO_Pin));
    442          
    443            GPIOx->BSRRH = GPIO_Pin;
   \                     GPIO_ResetBits: (+1)
   \   00000000   0x8341             STRH     R1,[R0, #+26]
    444          }
   \   00000002   0x4770             BX       LR               ;; return
    445          
    446          /**
    447            * @brief  Sets or clears the selected data port bit.
    448            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    449            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    450            * @param  GPIO_Pin: specifies the port bit to be written.
    451            *          This parameter can be one of GPIO_Pin_x where x can be (0..15).
    452            * @param  BitVal: specifies the value to be written to the selected bit.
    453            *          This parameter can be one of the BitAction enum values:
    454            *            @arg Bit_RESET: to clear the port pin
    455            *            @arg Bit_SET: to set the port pin
    456            * @retval None
    457            */

   \                                 In section .text, align 2, keep-with-next
    458          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
    459          {
    460            /* Check the parameters */
    461            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    462            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    463            assert_param(IS_GPIO_BIT_ACTION(BitVal));
    464          
    465            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD001             BEQ.N    ??GPIO_WriteBit_0
    466            {
    467              GPIOx->BSRRL = GPIO_Pin;
   \   00000006   0x8301             STRH     R1,[R0, #+24]
   \   00000008   0xE000             B.N      ??GPIO_WriteBit_1
    468            }
    469            else
    470            {
    471              GPIOx->BSRRH = GPIO_Pin ;
   \                     ??GPIO_WriteBit_0: (+1)
   \   0000000A   0x8341             STRH     R1,[R0, #+26]
    472            }
    473          }
   \                     ??GPIO_WriteBit_1: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    474          
    475          /**
    476            * @brief  Writes data to the specified GPIO data port.
    477            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    478            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    479            * @param  PortVal: specifies the value to be written to the port output data register.
    480            * @retval None
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    483          {
    484            /* Check the parameters */
    485            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    486          
    487            GPIOx->ODR = PortVal;
   \                     GPIO_Write: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6141             STR      R1,[R0, #+20]
    488          }
   \   00000004   0x4770             BX       LR               ;; return
    489          
    490          /**
    491            * @brief  Toggles the specified GPIO pins..
    492            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    493            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    494            * @param  GPIO_Pin: Specifies the pins to be toggled.
    495            * @retval None
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    501          
    502            GPIOx->ODR ^= GPIO_Pin;
   \                     GPIO_ToggleBits: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x4051             EORS     R1,R1,R2
   \   00000006   0x6141             STR      R1,[R0, #+20]
    503          }
   \   00000008   0x4770             BX       LR               ;; return
    504          
    505          /**
    506            * @}
    507            */
    508          
    509          /** @defgroup GPIO_Group3 GPIO Alternate functions configuration function
    510           *  @brief   GPIO Alternate functions configuration function
    511           *
    512          @verbatim   
    513           ===============================================================================
    514                     ##### GPIO Alternate functions configuration function #####
    515           ===============================================================================  
    516          
    517          @endverbatim
    518            * @{
    519            */
    520          
    521          /**
    522            * @brief  Changes the mapping of the specified pin.
    523            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    524            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices. 
    525            * @param  GPIO_PinSource: specifies the pin for the Alternate function.
    526            *         This parameter can be GPIO_PinSourcex where x can be (0..15).
    527            * @param  GPIO_AFSelection: selects the pin to used as Alternate function.
    528            *          This parameter can be one of the following values:
    529            *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) 
    530            *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) 
    531            *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) 
    532            *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) 
    533            *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)
    534            *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1
    535            *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1
    536            *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2
    537            *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2
    538            *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2
    539            *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3
    540            *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3
    541            *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3
    542            *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3
    543            *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4
    544            *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4
    545            *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4
    546            *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5
    547            *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5
    548            *            @arg GPIO_AF_SPI4: Connect SPI4 pins to AF5 
    549            *            @arg GPIO_AF_SPI5: Connect SPI5 pins to AF5 
    550            *            @arg GPIO_AF_SPI6: Connect SPI6 pins to AF5
    551            *            @arg GPIO_AF_SAI1: Connect SAI1 pins to AF6 for STM32F429X device        
    552            *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6
    553            *            @arg GPIO_AF_I2S3ext: Connect I2S3ext pins to AF7
    554            *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7
    555            *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7
    556            *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7
    557            *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8
    558            *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8
    559            *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8
    560            *            @arg GPIO_AF_UART7: Connect UART7 pins to AF8
    561            *            @arg GPIO_AF_UART8: Connect UART8 pins to AF8
    562            *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9
    563            *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9
    564            *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9
    565            *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9
    566            *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9
    567            *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10
    568            *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10
    569            *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11
    570            *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12 
    571            *            @arg GPIO_AF_FMC: Connect FMC pins to AF12 for STM32F429X device   
    572            *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12
    573            *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12
    574            *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
    575            *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429X device  
    576            *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
    577            * @retval None
    578            */

   \                                 In section .text, align 2, keep-with-next
    579          void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
    580          {
   \                     GPIO_PinAFConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    581            uint32_t temp = 0x00;
   \   00000002   0x2300             MOVS     R3,#+0
    582            uint32_t temp_2 = 0x00;
   \   00000004   0x2300             MOVS     R3,#+0
    583            
    584            /* Check the parameters */
    585            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    586            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    587            assert_param(IS_GPIO_AF(GPIO_AF));
    588            
    589            temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0xF011 0x0307      ANDS     R3,R1,#0x7
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x009B             LSLS     R3,R3,#+2
   \   00000010   0xFA12 0xF303      LSLS     R3,R2,R3
    590            GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x10CA             ASRS     R2,R1,#+3
   \   00000018   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x10CC             ASRS     R4,R1,#+3
   \   00000020   0xEB00 0x0484      ADD      R4,R0,R4, LSL #+2
   \   00000024   0x6A24             LDR      R4,[R4, #+32]
   \   00000026   0x250F             MOVS     R5,#+15
   \   00000028   0xF011 0x0607      ANDS     R6,R1,#0x7
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x00B6             LSLS     R6,R6,#+2
   \   00000030   0x40B5             LSLS     R5,R5,R6
   \   00000032   0x43AC             BICS     R4,R4,R5
   \   00000034   0x6214             STR      R4,[R2, #+32]
    591            temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
   \   00000036   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000038   0x10CA             ASRS     R2,R1,#+3
   \   0000003A   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \   0000003E   0x6A12             LDR      R2,[R2, #+32]
   \   00000040   0x4313             ORRS     R3,R3,R2
    592            GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
   \   00000042   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000044   0x10C9             ASRS     R1,R1,#+3
   \   00000046   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000004A   0x6203             STR      R3,[R0, #+32]
    593          }
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40022000         DC32     0x40022000
    594          
    595          /**
    596            * @}
    597            */ 
    598          
    599          /**
    600            * @}
    601            */
    602          
    603          /**
    604            * @}
    605            */ 
    606          
    607          /**
    608            * @}
    609            */ 
    610          
    611          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_DeInit
         8   -> RCC_AHB1PeriphResetCmd
       8   GPIO_Init
      12   GPIO_PinAFConfig
       4   GPIO_PinLockConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_ToggleBits
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
     222  GPIO_DeInit
     164  GPIO_Init
      80  GPIO_PinAFConfig
      40  GPIO_PinLockConfig
       6  GPIO_ReadInputData
      22  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      22  GPIO_ReadOutputDataBit
       4  GPIO_ResetBits
       4  GPIO_SetBits
      24  GPIO_StructInit
      10  GPIO_ToggleBits
       6  GPIO_Write
      14  GPIO_WriteBit

 
 660 bytes in section .text
 
 660 bytes of CODE memory

Errors: none
Warnings: none
