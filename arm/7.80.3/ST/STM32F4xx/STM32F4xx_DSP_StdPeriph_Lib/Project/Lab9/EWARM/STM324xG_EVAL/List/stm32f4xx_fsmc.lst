###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.3.12102/W32 for ARM       27/Mar/2017  18:42:57
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c
#    Command line =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -D USE_STM324xG_EVAL -lC
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\List
#        -o
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\List\stm32f4xx_fsmc.lst
#    Object file  =  
#        C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Project\Lab9\EWARM\STM324xG_EVAL\Obj\stm32f4xx_fsmc.o
#
###############################################################################

C:\Users\ecelab\Desktop\micro_apps\arm\7.80.3\ST\STM32F4xx\STM32F4xx_DSP_StdPeriph_Lib\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0RC2
      6            * @date    20-February-2013
      7           * @brief    This file provides firmware functions to manage the following 
      8            *          functionalities of the FSMC peripheral:           
      9            *           + Interface with SRAM, PSRAM, NOR and OneNAND memories
     10            *           + Interface with NAND memories
     11            *           + Interface with 16-bit PC Card compatible memories  
     12            *           + Interrupts and flags management   
     13            *           
     14            ******************************************************************************
     15            * @attention
     16            *
     17            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     18            *
     19            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     20            * You may not use this file except in compliance with the License.
     21            * You may obtain a copy of the License at:
     22            *
     23            *        http://www.st.com/software_license_agreement_liberty_v2
     24            *
     25            * Unless required by applicable law or agreed to in writing, software 
     26            * distributed under the License is distributed on an "AS IS" BASIS, 
     27            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28            * See the License for the specific language governing permissions and
     29            * limitations under the License.
     30            *
     31            ******************************************************************************
     32            */
     33          
     34          /* Includes ------------------------------------------------------------------*/
     35          #include "stm32f4xx_fsmc.h"
     36          #include "stm32f4xx_rcc.h"
     37          
     38          /** @addtogroup STM32F4xx_StdPeriph_Driver
     39            * @{
     40            */
     41          
     42          /** @defgroup FSMC 
     43            * @brief FSMC driver modules
     44            * @{
     45            */ 
     46          
     47          /* Private typedef -----------------------------------------------------------*/
     48          /* Private define ------------------------------------------------------------*/
     49          
     50          /* --------------------- FSMC registers bit mask ---------------------------- */
     51          /* FSMC BCRx Mask */
     52          #define BCR_MBKEN_SET          ((uint32_t)0x00000001)
     53          #define BCR_MBKEN_RESET        ((uint32_t)0x000FFFFE)
     54          #define BCR_FACCEN_SET         ((uint32_t)0x00000040)
     55          
     56          /* FSMC PCRx Mask */
     57          #define PCR_PBKEN_SET          ((uint32_t)0x00000004)
     58          #define PCR_PBKEN_RESET        ((uint32_t)0x000FFFFB)
     59          #define PCR_ECCEN_SET          ((uint32_t)0x00000040)
     60          #define PCR_ECCEN_RESET        ((uint32_t)0x000FFFBF)
     61          #define PCR_MEMORYTYPE_NAND    ((uint32_t)0x00000008)
     62          
     63          /* Private macro -------------------------------------------------------------*/
     64          /* Private variables ---------------------------------------------------------*/
     65          /* Private function prototypes -----------------------------------------------*/
     66          /* Private functions ---------------------------------------------------------*/
     67          
     68          /** @defgroup FSMC_Private_Functions
     69            * @{
     70            */
     71          
     72          /** @defgroup FSMC_Group1 NOR/SRAM Controller functions
     73           *  @brief   NOR/SRAM Controller functions 
     74           *
     75          @verbatim   
     76           ===============================================================================
     77                              ##### NOR and SRAM Controller functions #####
     78           ===============================================================================  
     79          
     80           [..] The following sequence should be followed to configure the FSMC to interface
     81                with SRAM, PSRAM, NOR or OneNAND memory connected to the NOR/SRAM Bank:
     82           
     83             (#) Enable the clock for the FSMC and associated GPIOs using the following functions:
     84                    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
     85                    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     86          
     87             (#) FSMC pins configuration 
     88                 (++) Connect the involved FSMC pins to AF12 using the following function 
     89                      GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
     90                 (++) Configure these FSMC pins in alternate function mode by calling the function
     91                      GPIO_Init();    
     92                 
     93             (#) Declare a FSMC_NORSRAMInitTypeDef structure, for example:
     94                    FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
     95                and fill the FSMC_NORSRAMInitStructure variable with the allowed values of
     96                the structure member.
     97                
     98             (#) Initialize the NOR/SRAM Controller by calling the function
     99                    FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
    100          
    101             (#) Then enable the NOR/SRAM Bank, for example:
    102                    FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);  
    103          
    104             (#) At this stage you can read/write from/to the memory connected to the NOR/SRAM Bank. 
    105             
    106          @endverbatim
    107            * @{
    108            */
    109          
    110          /**
    111            * @brief  De-initializes the FSMC NOR/SRAM Banks registers to their default 
    112            *   reset values.
    113            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    114            *          This parameter can be one of the following values:
    115            *            @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    116            *            @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    117            *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    118            *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    119            * @retval None
    120            */

   \                                 In section .text, align 2, keep-with-next
    121          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    122          {
    123            /* Check the parameter */
    124            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    125            
    126            /* FSMC_Bank1_NORSRAM1 */
    127            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \                     FSMC_NORSRAMDeInit: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD106             BNE.N    ??FSMC_NORSRAMDeInit_0
    128            {
    129              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
   \   00000004   0xF243 0x01DB      MOVW     R1,#+12507
   \   00000008   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   0000000C   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000010   0xE005             B.N      ??FSMC_NORSRAMDeInit_1
    130            }
    131            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    132            else
    133            {   
    134              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
   \                     ??FSMC_NORSRAMDeInit_0: (+1)
   \   00000012   0xF243 0x01D2      MOVW     R1,#+12498
   \   00000016   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   0000001A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    135            }
    136            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMDeInit_1: (+1)
   \   0000001E   0xF07F 0x4170      MVNS     R1,#-268435456
   \   00000022   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   00000026   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \   0000002A   0x6051             STR      R1,[R2, #+4]
    137            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \   0000002C   0xF07F 0x4170      MVNS     R1,#-268435456
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   00000034   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    138          }
   \   00000038   0x4770             BX       LR               ;; return
    139          
    140          /**
    141            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    142            *         parameters in the FSMC_NORSRAMInitStruct.
    143            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef structure
    144            *         that contains the configuration information for the FSMC NOR/SRAM 
    145            *         specified Banks.                       
    146            * @retval None
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    149          { 
    150            /* Check the parameters */
    151            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    152            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    153            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    154            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    155            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    156            assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
    157            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    158            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    159            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    160            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    161            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    162            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    163            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
    164            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    165            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    166            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    167            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    168            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    169            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    170            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
    171            
    172            /* Bank1 NOR/SRAM control register configuration */ 
    173            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    174                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    175                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    176                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    177                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    178                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    179                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    180                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    181                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    182                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    183                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    184                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    185                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \                     FSMC_NORSRAMInit: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x4311             ORRS     R1,R2,R1
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0x4311             ORRS     R1,R2,R1
   \   0000000A   0x6902             LDR      R2,[R0, #+16]
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   \   00000010   0x4311             ORRS     R1,R2,R1
   \   00000012   0x6982             LDR      R2,[R0, #+24]
   \   00000014   0x4311             ORRS     R1,R2,R1
   \   00000016   0x69C2             LDR      R2,[R0, #+28]
   \   00000018   0x4311             ORRS     R1,R2,R1
   \   0000001A   0x6A02             LDR      R2,[R0, #+32]
   \   0000001C   0x4311             ORRS     R1,R2,R1
   \   0000001E   0x6A42             LDR      R2,[R0, #+36]
   \   00000020   0x4311             ORRS     R1,R2,R1
   \   00000022   0x6A82             LDR      R2,[R0, #+40]
   \   00000024   0x4311             ORRS     R1,R2,R1
   \   00000026   0x6AC2             LDR      R2,[R0, #+44]
   \   00000028   0x4311             ORRS     R1,R2,R1
   \   0000002A   0x6B02             LDR      R2,[R0, #+48]
   \   0000002C   0x4311             ORRS     R1,R2,R1
   \   0000002E   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   00000032   0x6803             LDR      R3,[R0, #+0]
   \   00000034   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
    186            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \   00000038   0x6881             LDR      R1,[R0, #+8]
   \   0000003A   0x2908             CMP      R1,#+8
   \   0000003C   0xD10B             BNE.N    ??FSMC_NORSRAMInit_0
    187            {
    188              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
   \   0000003E   0xF05F 0x4120      MOVS     R1,#-1610612736
   \   00000042   0x6802             LDR      R2,[R0, #+0]
   \   00000044   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   00000048   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000004C   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   00000050   0x6803             LDR      R3,[R0, #+0]
   \   00000052   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
    189            }
    190            /* Bank1 NOR/SRAM timing register configuration */
    191            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    192                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    193                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    194                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    195                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    196                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    197                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    198                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_0: (+1)
   \   00000056   0x6B41             LDR      R1,[R0, #+52]
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x6B42             LDR      R2,[R0, #+52]
   \   0000005C   0x6852             LDR      R2,[R2, #+4]
   \   0000005E   0xEA51 0x1102      ORRS     R1,R1,R2, LSL #+4
   \   00000062   0x6B42             LDR      R2,[R0, #+52]
   \   00000064   0x6892             LDR      R2,[R2, #+8]
   \   00000066   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   0000006A   0x6B42             LDR      R2,[R0, #+52]
   \   0000006C   0x68D2             LDR      R2,[R2, #+12]
   \   0000006E   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000072   0x6B42             LDR      R2,[R0, #+52]
   \   00000074   0x6912             LDR      R2,[R2, #+16]
   \   00000076   0xEA51 0x5102      ORRS     R1,R1,R2, LSL #+20
   \   0000007A   0x6B42             LDR      R2,[R0, #+52]
   \   0000007C   0x6952             LDR      R2,[R2, #+20]
   \   0000007E   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   00000082   0x6B42             LDR      R2,[R0, #+52]
   \   00000084   0x6992             LDR      R2,[R2, #+24]
   \   00000086   0x4311             ORRS     R1,R2,R1
   \   00000088   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   0000008C   0x6803             LDR      R3,[R0, #+0]
   \   0000008E   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \   00000092   0x6051             STR      R1,[R2, #+4]
    199                      
    200              
    201            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    202            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \   00000094   0x6AC1             LDR      R1,[R0, #+44]
   \   00000096   0xF5B1 0x4F80      CMP      R1,#+16384
   \   0000009A   0xD11A             BNE.N    ??FSMC_NORSRAMInit_1
    203            {
    204              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    205              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    206              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    207              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    208              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    209              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    210              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    211                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    212                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    213                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    214                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    215                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    216                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \   0000009C   0x6B81             LDR      R1,[R0, #+56]
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0x6B82             LDR      R2,[R0, #+56]
   \   000000A2   0x6852             LDR      R2,[R2, #+4]
   \   000000A4   0xEA51 0x1102      ORRS     R1,R1,R2, LSL #+4
   \   000000A8   0x6B82             LDR      R2,[R0, #+56]
   \   000000AA   0x6892             LDR      R2,[R2, #+8]
   \   000000AC   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000B0   0x6B82             LDR      R2,[R0, #+56]
   \   000000B2   0x6912             LDR      R2,[R2, #+16]
   \   000000B4   0xEA51 0x5102      ORRS     R1,R1,R2, LSL #+20
   \   000000B8   0x6B82             LDR      R2,[R0, #+56]
   \   000000BA   0x6952             LDR      R2,[R2, #+20]
   \   000000BC   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   000000C0   0x6B82             LDR      R2,[R0, #+56]
   \   000000C2   0x6992             LDR      R2,[R2, #+24]
   \   000000C4   0x4311             ORRS     R1,R2,R1
   \   000000C6   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   000000D0   0xE006             B.N      ??FSMC_NORSRAMInit_2
    217            }
    218            else
    219            {
    220              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_1: (+1)
   \   000000D2   0xF07F 0x4170      MVNS     R1,#-268435456
   \   000000D6   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    221            }
    222          }
   \                     ??FSMC_NORSRAMInit_2: (+1)
   \   000000E0   0x4770             BX       LR               ;; return
    223          
    224          /**
    225            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    226            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
    227            *         which will be initialized.
    228            * @retval None
    229            */

   \                                 In section .text, align 2, keep-with-next
    230          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    231          {  
    232            /* Reset NOR/SRAM Init structure parameters values */
    233            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \                     FSMC_NORSRAMStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    234            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x6041             STR      R1,[R0, #+4]
    235            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    236            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    237            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    238            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    239            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    240            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    241            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6201             STR      R1,[R0, #+32]
    242            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \   00000024   0xF44F 0x5180      MOV      R1,#+4096
   \   00000028   0x6241             STR      R1,[R0, #+36]
    243            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \   0000002A   0xF44F 0x5100      MOV      R1,#+8192
   \   0000002E   0x6281             STR      R1,[R0, #+40]
    244            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x62C1             STR      R1,[R0, #+44]
    245            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6301             STR      R1,[R0, #+48]
    246            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000038   0x210F             MOVS     R1,#+15
   \   0000003A   0x6B42             LDR      R2,[R0, #+52]
   \   0000003C   0x6011             STR      R1,[R2, #+0]
    247            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   0000003E   0x210F             MOVS     R1,#+15
   \   00000040   0x6B42             LDR      R2,[R0, #+52]
   \   00000042   0x6051             STR      R1,[R2, #+4]
    248            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   00000044   0x21FF             MOVS     R1,#+255
   \   00000046   0x6B42             LDR      R2,[R0, #+52]
   \   00000048   0x6091             STR      R1,[R2, #+8]
    249            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   0000004A   0x210F             MOVS     R1,#+15
   \   0000004C   0x6B42             LDR      R2,[R0, #+52]
   \   0000004E   0x60D1             STR      R1,[R2, #+12]
    250            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   00000050   0x210F             MOVS     R1,#+15
   \   00000052   0x6B42             LDR      R2,[R0, #+52]
   \   00000054   0x6111             STR      R1,[R2, #+16]
    251            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000056   0x210F             MOVS     R1,#+15
   \   00000058   0x6B42             LDR      R2,[R0, #+52]
   \   0000005A   0x6151             STR      R1,[R2, #+20]
    252            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6B42             LDR      R2,[R0, #+52]
   \   00000060   0x6191             STR      R1,[R2, #+24]
    253            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000062   0x210F             MOVS     R1,#+15
   \   00000064   0x6B82             LDR      R2,[R0, #+56]
   \   00000066   0x6011             STR      R1,[R2, #+0]
    254            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   00000068   0x210F             MOVS     R1,#+15
   \   0000006A   0x6B82             LDR      R2,[R0, #+56]
   \   0000006C   0x6051             STR      R1,[R2, #+4]
    255            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   0000006E   0x21FF             MOVS     R1,#+255
   \   00000070   0x6B82             LDR      R2,[R0, #+56]
   \   00000072   0x6091             STR      R1,[R2, #+8]
    256            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   00000074   0x210F             MOVS     R1,#+15
   \   00000076   0x6B82             LDR      R2,[R0, #+56]
   \   00000078   0x60D1             STR      R1,[R2, #+12]
    257            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   0000007A   0x210F             MOVS     R1,#+15
   \   0000007C   0x6B82             LDR      R2,[R0, #+56]
   \   0000007E   0x6111             STR      R1,[R2, #+16]
    258            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000080   0x210F             MOVS     R1,#+15
   \   00000082   0x6B82             LDR      R2,[R0, #+56]
   \   00000084   0x6151             STR      R1,[R2, #+20]
    259            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6B80             LDR      R0,[R0, #+56]
   \   0000008A   0x6181             STR      R1,[R0, #+24]
    260          }
   \   0000008C   0x4770             BX       LR               ;; return
    261          
    262          /**
    263            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    264            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    265            *          This parameter can be one of the following values:
    266            *            @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    267            *            @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    268            *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    269            *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    270            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    271            * @retval None
    272            */

   \                                 In section .text, align 2, keep-with-next
    273          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    274          {
    275            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    276            assert_param(IS_FUNCTIONAL_STATE(NewState));
    277            
    278            if (NewState != DISABLE)
   \                     FSMC_NORSRAMCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00A             BEQ.N    ??FSMC_NORSRAMCmd_0
    279            {
    280              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    281              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
   \   00000006   0xF05F 0x4120      MOVS     R1,#-1610612736
   \   0000000A   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000000E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000012   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   00000016   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   0000001A   0xE00A             B.N      ??FSMC_NORSRAMCmd_1
    282            }
    283            else
    284            {
    285              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    286              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
   \                     ??FSMC_NORSRAMCmd_0: (+1)
   \   0000001C   0xF05F 0x4120      MOVS     R1,#-1610612736
   \   00000020   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0xffffe
   \   00000028   0x4011             ANDS     R1,R2,R1
   \   0000002A   0xF05F 0x4220      MOVS     R2,#-1610612736
   \   0000002E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    287            }
    288          }
   \                     ??FSMC_NORSRAMCmd_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    289          /**
    290            * @}
    291            */
    292          
    293          /** @defgroup FSMC_Group2 NAND Controller functions
    294           *  @brief   NAND Controller functions 
    295           *
    296          @verbatim   
    297           ===============================================================================
    298                              ##### NAND Controller functions #####
    299           ===============================================================================  
    300          
    301           [..]  The following sequence should be followed to configure the FSMC to interface 
    302                 with 8-bit or 16-bit NAND memory connected to the NAND Bank:
    303           
    304            (#) Enable the clock for the FSMC and associated GPIOs using the following functions:
    305                (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    306                (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    307          
    308            (#) FSMC pins configuration 
    309                (++) Connect the involved FSMC pins to AF12 using the following function 
    310                     GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
    311                (++) Configure these FSMC pins in alternate function mode by calling the function
    312                     GPIO_Init();    
    313                 
    314            (#) Declare a FSMC_NANDInitTypeDef structure, for example:
    315                FSMC_NANDInitTypeDef  FSMC_NANDInitStructure;
    316                and fill the FSMC_NANDInitStructure variable with the allowed values of
    317                the structure member.
    318                
    319            (#) Initialize the NAND Controller by calling the function
    320                FSMC_NANDInit(&FSMC_NANDInitStructure); 
    321          
    322            (#) Then enable the NAND Bank, for example:
    323                FSMC_NANDCmd(FSMC_Bank3_NAND, ENABLE);  
    324          
    325            (#) At this stage you can read/write from/to the memory connected to the NAND Bank. 
    326             
    327           [..]
    328            (@) To enable the Error Correction Code (ECC), you have to use the function
    329                FSMC_NANDECCCmd(FSMC_Bank3_NAND, ENABLE);  
    330           [..]
    331            (@) and to get the current ECC value you have to use the function
    332                ECCval = FSMC_GetECC(FSMC_Bank3_NAND); 
    333          
    334          @endverbatim
    335            * @{
    336            */
    337            
    338          /**
    339            * @brief  De-initializes the FSMC NAND Banks registers to their default reset values.
    340            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    341            *          This parameter can be one of the following values:
    342            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    343            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    344            * @retval None
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    347          {
    348            /* Check the parameter */
    349            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    350            
    351            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_NANDDeInit: (+1)
   \   00000000   0x2810             CMP      R0,#+16
   \   00000002   0xD112             BNE.N    ??FSMC_NANDDeInit_0
    352            {
    353              /* Set the FSMC_Bank2 registers to their reset values */
    354              FSMC_Bank2->PCR2 = 0x00000018;
   \   00000004   0x2018             MOVS     R0,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xa0000060
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    355              FSMC_Bank2->SR2 = 0x00000040;
   \   0000000C   0x2040             MOVS     R0,#+64
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xa0000064
   \   00000012   0x6008             STR      R0,[R1, #+0]
    356              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \   00000014   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0xa0000068
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    357              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \   0000001E   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa000006c
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0xE011             B.N      ??FSMC_NANDDeInit_1
    358            }
    359            /* FSMC_Bank3_NAND */  
    360            else
    361            {
    362              /* Set the FSMC_Bank3 registers to their reset values */
    363              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_0: (+1)
   \   0000002A   0x2018             MOVS     R0,#+24
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0xa0000080
   \   00000030   0x6008             STR      R0,[R1, #+0]
    364              FSMC_Bank3->SR3 = 0x00000040;
   \   00000032   0x2040             MOVS     R0,#+64
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_7  ;; 0xa0000084
   \   00000038   0x6008             STR      R0,[R1, #+0]
    365              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \   0000003A   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable15_8  ;; 0xa0000088
   \   00000042   0x6008             STR      R0,[R1, #+0]
    366              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \   00000044   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable15_9  ;; 0xa000008c
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    367            }  
    368          }
   \                     ??FSMC_NANDDeInit_1: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
    369          
    370          /**
    371            * @brief  Initializes the FSMC NAND Banks according to the specified parameters
    372            *         in the FSMC_NANDInitStruct.
    373            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
    374            *         contains the configuration information for the FSMC NAND specified Banks.                       
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    378          {
   \                     FSMC_NANDInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    379            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
    380              
    381            /* Check the parameters */
    382            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    383            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    384            assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    385            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    386            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    387            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    388            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    389            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    390            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    391            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    392            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    393            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    394            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    395            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    396            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    397            
    398            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    399            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    400                      PCR_MEMORYTYPE_NAND |
    401                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    402                      FSMC_NANDInitStruct->FSMC_ECC |
    403                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    404                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    405                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0x6882             LDR      R2,[R0, #+8]
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0x68C2             LDR      R2,[R0, #+12]
   \   00000010   0x4311             ORRS     R1,R2,R1
   \   00000012   0x6902             LDR      R2,[R0, #+16]
   \   00000014   0x4311             ORRS     R1,R2,R1
   \   00000016   0x6942             LDR      R2,[R0, #+20]
   \   00000018   0xEA51 0x2142      ORRS     R1,R1,R2, LSL #+9
   \   0000001C   0x6982             LDR      R2,[R0, #+24]
   \   0000001E   0xEA51 0x3142      ORRS     R1,R1,R2, LSL #+13
   \   00000022   0xF051 0x0108      ORRS     R1,R1,#0x8
    406                      
    407            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    408            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    409                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    410                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    411                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   00000026   0x69C2             LDR      R2,[R0, #+28]
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x69C3             LDR      R3,[R0, #+28]
   \   0000002C   0x685B             LDR      R3,[R3, #+4]
   \   0000002E   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   00000032   0x69C3             LDR      R3,[R0, #+28]
   \   00000034   0x689B             LDR      R3,[R3, #+8]
   \   00000036   0xEA52 0x4203      ORRS     R2,R2,R3, LSL #+16
   \   0000003A   0x69C3             LDR      R3,[R0, #+28]
   \   0000003C   0x68DB             LDR      R3,[R3, #+12]
   \   0000003E   0xEA52 0x6203      ORRS     R2,R2,R3, LSL #+24
    412                      
    413            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    414            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    415                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    416                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    417                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \   00000042   0x6A03             LDR      R3,[R0, #+32]
   \   00000044   0x681B             LDR      R3,[R3, #+0]
   \   00000046   0x6A04             LDR      R4,[R0, #+32]
   \   00000048   0x6864             LDR      R4,[R4, #+4]
   \   0000004A   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   0000004E   0x6A04             LDR      R4,[R0, #+32]
   \   00000050   0x68A4             LDR      R4,[R4, #+8]
   \   00000052   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \   00000056   0x6A04             LDR      R4,[R0, #+32]
   \   00000058   0x68E4             LDR      R4,[R4, #+12]
   \   0000005A   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
    418            
    419            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x2810             CMP      R0,#+16
   \   00000062   0xD109             BNE.N    ??FSMC_NANDInit_0
    420            {
    421              /* FSMC_Bank2_NAND registers configuration */
    422              FSMC_Bank2->PCR2 = tmppcr;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0xa0000060
   \   00000068   0x6001             STR      R1,[R0, #+0]
    423              FSMC_Bank2->PMEM2 = tmppmem;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0xa0000068
   \   0000006E   0x6002             STR      R2,[R0, #+0]
    424              FSMC_Bank2->PATT2 = tmppatt;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0xa000006c
   \   00000074   0x6003             STR      R3,[R0, #+0]
   \   00000076   0xE008             B.N      ??FSMC_NANDInit_1
    425            }
    426            else
    427            {
    428              /* FSMC_Bank3_NAND registers configuration */
    429              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_0: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0xa0000080
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    430              FSMC_Bank3->PMEM3 = tmppmem;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable15_8  ;; 0xa0000088
   \   00000082   0x6002             STR      R2,[R0, #+0]
    431              FSMC_Bank3->PATT3 = tmppatt;
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable15_9  ;; 0xa000008c
   \   00000088   0x6003             STR      R3,[R0, #+0]
    432            }
    433          }
   \                     ??FSMC_NANDInit_1: (+1)
   \   0000008A   0xBC10             POP      {R4}
   \   0000008C   0x4770             BX       LR               ;; return
    434          
    435          
    436          /**
    437            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    438            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef structure which
    439            *         will be initialized.
    440            * @retval None
    441            */

   \                                 In section .text, align 2, keep-with-next
    442          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    443          { 
    444            /* Reset NAND Init structure parameters values */
    445            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit: (+1)
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0x6001             STR      R1,[R0, #+0]
    446            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    447            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    448            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    449            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    450            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    451            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    452            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000001C   0x21FC             MOVS     R1,#+252
   \   0000001E   0x69C2             LDR      R2,[R0, #+28]
   \   00000020   0x6011             STR      R1,[R2, #+0]
    453            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000022   0x21FC             MOVS     R1,#+252
   \   00000024   0x69C2             LDR      R2,[R0, #+28]
   \   00000026   0x6051             STR      R1,[R2, #+4]
    454            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000028   0x21FC             MOVS     R1,#+252
   \   0000002A   0x69C2             LDR      R2,[R0, #+28]
   \   0000002C   0x6091             STR      R1,[R2, #+8]
    455            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000002E   0x21FC             MOVS     R1,#+252
   \   00000030   0x69C2             LDR      R2,[R0, #+28]
   \   00000032   0x60D1             STR      R1,[R2, #+12]
    456            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000034   0x21FC             MOVS     R1,#+252
   \   00000036   0x6A02             LDR      R2,[R0, #+32]
   \   00000038   0x6011             STR      R1,[R2, #+0]
    457            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000003A   0x21FC             MOVS     R1,#+252
   \   0000003C   0x6A02             LDR      R2,[R0, #+32]
   \   0000003E   0x6051             STR      R1,[R2, #+4]
    458            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000040   0x21FC             MOVS     R1,#+252
   \   00000042   0x6A02             LDR      R2,[R0, #+32]
   \   00000044   0x6091             STR      R1,[R2, #+8]
    459            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
   \   00000046   0x21FC             MOVS     R1,#+252
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0x60C1             STR      R1,[R0, #+12]
    460          }
   \   0000004C   0x4770             BX       LR               ;; return
    461          
    462          /**
    463            * @brief  Enables or disables the specified NAND Memory Bank.
    464            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    465            *          This parameter can be one of the following values:
    466            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    467            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    468            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    469            * @retval None
    470            */

   \                                 In section .text, align 2, keep-with-next
    471          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    472          {
    473            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    474            assert_param(IS_FUNCTIONAL_STATE(NewState));
    475            
    476            if (NewState != DISABLE)
   \                     FSMC_NANDCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00F             BEQ.N    ??FSMC_NANDCmd_0
    477            {
    478              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    479              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD106             BNE.N    ??FSMC_NANDCmd_1
    480              {
    481                FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000060
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000012   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000060
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xE015             B.N      ??FSMC_NANDCmd_2
    482              }
    483              else
    484              {
    485                FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
   \                     ??FSMC_NANDCmd_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000080
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000020   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000080
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE00E             B.N      ??FSMC_NANDCmd_2
    486              }
    487            }
    488            else
    489            {
    490              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    491              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_0: (+1)
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD106             BNE.N    ??FSMC_NANDCmd_3
    492              {
    493                FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
   \   0000002A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000060
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable15_10  ;; 0xffffb
   \   00000030   0x4008             ANDS     R0,R1,R0
   \   00000032   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000060
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE005             B.N      ??FSMC_NANDCmd_2
    494              }
    495              else
    496              {
    497                FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
   \                     ??FSMC_NANDCmd_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000080
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x....             LDR.N    R1,??DataTable15_10  ;; 0xffffb
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000080
   \   00000042   0x6008             STR      R0,[R1, #+0]
    498              }
    499            }
    500          }
   \                     ??FSMC_NANDCmd_2: (+1)
   \   00000044   0x4770             BX       LR               ;; return
    501          /**
    502            * @brief  Enables or disables the FSMC NAND ECC feature.
    503            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    504            *          This parameter can be one of the following values:
    505            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    506            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    507            * @param  NewState: new state of the FSMC NAND ECC feature.  
    508            *          This parameter can be: ENABLE or DISABLE.
    509            * @retval None
    510            */

   \                                 In section .text, align 2, keep-with-next
    511          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    512          {
    513            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    514            assert_param(IS_FUNCTIONAL_STATE(NewState));
    515            
    516            if (NewState != DISABLE)
   \                     FSMC_NANDECCCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00F             BEQ.N    ??FSMC_NANDECCCmd_0
    517            {
    518              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    519              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD106             BNE.N    ??FSMC_NANDECCCmd_1
    520              {
    521                FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000060
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000012   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000060
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xE015             B.N      ??FSMC_NANDECCCmd_2
    522              }
    523              else
    524              {
    525                FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
   \                     ??FSMC_NANDECCCmd_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000080
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000020   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000080
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE00E             B.N      ??FSMC_NANDECCCmd_2
    526              }
    527            }
    528            else
    529            {
    530              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    531              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_0: (+1)
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD106             BNE.N    ??FSMC_NANDECCCmd_3
    532              {
    533                FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
   \   0000002A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xa0000060
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable15_11  ;; 0xfffbf
   \   00000030   0x4008             ANDS     R0,R1,R0
   \   00000032   0x....             LDR.N    R1,??DataTable15_2  ;; 0xa0000060
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE005             B.N      ??FSMC_NANDECCCmd_2
    534              }
    535              else
    536              {
    537                FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
   \                     ??FSMC_NANDECCCmd_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable15_6  ;; 0xa0000080
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x....             LDR.N    R1,??DataTable15_11  ;; 0xfffbf
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x....             LDR.N    R1,??DataTable15_6  ;; 0xa0000080
   \   00000042   0x6008             STR      R0,[R1, #+0]
    538              }
    539            }
    540          }
   \                     ??FSMC_NANDECCCmd_2: (+1)
   \   00000044   0x4770             BX       LR               ;; return
    541          
    542          /**
    543            * @brief  Returns the error correction code register value.
    544            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    545            *          This parameter can be one of the following values:
    546            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    547            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    548            * @retval The Error Correction Code (ECC) value.
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    551          {
    552            uint32_t eccval = 0x00000000;
   \                     FSMC_GetECC: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    553            
    554            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000002   0x2810             CMP      R0,#+16
   \   00000004   0xD102             BNE.N    ??FSMC_GetECC_0
    555            {
    556              /* Get the ECCR2 register value */
    557              eccval = FSMC_Bank2->ECCR2;
   \   00000006   0x....             LDR.N    R0,??DataTable15_12  ;; 0xa0000074
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xE001             B.N      ??FSMC_GetECC_1
    558            }
    559            else
    560            {
    561              /* Get the ECCR3 register value */
    562              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable15_13  ;; 0xa0000094
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
    563            }
    564            /* Return the error correction code value */
    565            return(eccval);
   \                     ??FSMC_GetECC_1: (+1)
   \   00000010   0x0008             MOVS     R0,R1
   \   00000012   0x4770             BX       LR               ;; return
    566          }
    567          /**
    568            * @}
    569            */
    570          
    571          /** @defgroup FSMC_Group3 PCCARD Controller functions
    572           *  @brief   PCCARD Controller functions 
    573           *
    574          @verbatim   
    575           ===============================================================================
    576                              ##### PCCARD Controller functions #####
    577           ===============================================================================  
    578          
    579           [..]  he following sequence should be followed to configure the FSMC to interface 
    580                 with 16-bit PC Card compatible memory connected to the PCCARD Bank:
    581           
    582            (#)  Enable the clock for the FSMC and associated GPIOs using the following functions:
    583                 (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
    584                 (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    585          
    586            (#) FSMC pins configuration 
    587                 (++) Connect the involved FSMC pins to AF12 using the following function 
    588                      GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
    589                 (++) Configure these FSMC pins in alternate function mode by calling the function
    590                      GPIO_Init();    
    591                 
    592            (#) Declare a FSMC_PCCARDInitTypeDef structure, for example:
    593                FSMC_PCCARDInitTypeDef  FSMC_PCCARDInitStructure;
    594                and fill the FSMC_PCCARDInitStructure variable with the allowed values of
    595                the structure member.
    596                
    597            (#) Initialize the PCCARD Controller by calling the function
    598                FSMC_PCCARDInit(&FSMC_PCCARDInitStructure); 
    599          
    600            (#) Then enable the PCCARD Bank:
    601                FSMC_PCCARDCmd(ENABLE);  
    602          
    603            (#) At this stage you can read/write from/to the memory connected to the PCCARD Bank. 
    604           
    605          @endverbatim
    606            * @{
    607            */
    608          
    609          /**
    610            * @brief  De-initializes the FSMC PCCARD Bank registers to their default reset values.
    611            * @param  None                       
    612            * @retval None
    613            */

   \                                 In section .text, align 2, keep-with-next
    614          void FSMC_PCCARDDeInit(void)
    615          {
    616            /* Set the FSMC_Bank4 registers to their reset values */
    617            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit: (+1)
   \   00000000   0x2018             MOVS     R0,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a0
   \   00000004   0x6008             STR      R0,[R1, #+0]
    618            FSMC_Bank4->SR4 = 0x00000000;	
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable15_15  ;; 0xa00000a4
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    619            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \   0000000C   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000010   0x....             LDR.N    R1,??DataTable15_16  ;; 0xa00000a8
   \   00000012   0x6008             STR      R0,[R1, #+0]
    620            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \   00000014   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000018   0x....             LDR.N    R1,??DataTable15_17  ;; 0xa00000ac
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    621            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \   0000001C   0xF05F 0x30FC      MOVS     R0,#-50529028
   \   00000020   0x....             LDR.N    R1,??DataTable15_18  ;; 0xa00000b0
   \   00000022   0x6008             STR      R0,[R1, #+0]
    622          }
   \   00000024   0x4770             BX       LR               ;; return
    623          
    624          /**
    625            * @brief  Initializes the FSMC PCCARD Bank according to the specified parameters
    626            *         in the FSMC_PCCARDInitStruct.
    627            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
    628            *         that contains the configuration information for the FSMC PCCARD Bank.                       
    629            * @retval None
    630            */

   \                                 In section .text, align 2, keep-with-next
    631          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    632          {
    633            /* Check the parameters */
    634            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    635            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    636            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    637           
    638            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    639            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    640            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    641            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    642            
    643            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    644            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    645            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    646            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    647            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    648            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    649            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    650            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    651            
    652            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    653            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    654                               FSMC_MemoryDataWidth_16b |  
    655                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    656                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \                     FSMC_PCCARDInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0xEA51 0x2142      ORRS     R1,R1,R2, LSL #+9
   \   00000008   0x6882             LDR      R2,[R0, #+8]
   \   0000000A   0xEA51 0x3142      ORRS     R1,R1,R2, LSL #+13
   \   0000000E   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000012   0x....             LDR.N    R2,??DataTable15_14  ;; 0xa00000a0
   \   00000014   0x6011             STR      R1,[R2, #+0]
    657                      
    658            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    659            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    660                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    661                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    662                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   00000016   0x68C1             LDR      R1,[R0, #+12]
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x68C2             LDR      R2,[R0, #+12]
   \   0000001C   0x6852             LDR      R2,[R2, #+4]
   \   0000001E   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000022   0x68C2             LDR      R2,[R0, #+12]
   \   00000024   0x6892             LDR      R2,[R2, #+8]
   \   00000026   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   0000002A   0x68C2             LDR      R2,[R0, #+12]
   \   0000002C   0x68D2             LDR      R2,[R2, #+12]
   \   0000002E   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   00000032   0x....             LDR.N    R2,??DataTable15_16  ;; 0xa00000a8
   \   00000034   0x6011             STR      R1,[R2, #+0]
    663                      
    664            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    665            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    666                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    667                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    668                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x6902             LDR      R2,[R0, #+16]
   \   0000003C   0x6852             LDR      R2,[R2, #+4]
   \   0000003E   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000042   0x6902             LDR      R2,[R0, #+16]
   \   00000044   0x6892             LDR      R2,[R2, #+8]
   \   00000046   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   0000004A   0x6902             LDR      R2,[R0, #+16]
   \   0000004C   0x68D2             LDR      R2,[R2, #+12]
   \   0000004E   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   00000052   0x....             LDR.N    R2,??DataTable15_17  ;; 0xa00000ac
   \   00000054   0x6011             STR      R1,[R2, #+0]
    669                      
    670            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    671            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    672                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    673                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    674                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \   00000056   0x6941             LDR      R1,[R0, #+20]
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x6942             LDR      R2,[R0, #+20]
   \   0000005C   0x6852             LDR      R2,[R2, #+4]
   \   0000005E   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000062   0x6942             LDR      R2,[R0, #+20]
   \   00000064   0x6892             LDR      R2,[R2, #+8]
   \   00000066   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   0000006A   0x6940             LDR      R0,[R0, #+20]
   \   0000006C   0x68C0             LDR      R0,[R0, #+12]
   \   0000006E   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000072   0x....             LDR.N    R1,??DataTable15_18  ;; 0xa00000b0
   \   00000074   0x6008             STR      R0,[R1, #+0]
    675          }
   \   00000076   0x4770             BX       LR               ;; return
    676          
    677          /**
    678            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    679            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef structure
    680            *         which will be initialized.
    681            * @retval None
    682            */

   \                                 In section .text, align 2, keep-with-next
    683          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    684          {
    685            /* Reset PCCARD Init structure parameters values */
    686            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    687            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    688            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    689            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000000C   0x21FC             MOVS     R1,#+252
   \   0000000E   0x68C2             LDR      R2,[R0, #+12]
   \   00000010   0x6011             STR      R1,[R2, #+0]
    690            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000012   0x21FC             MOVS     R1,#+252
   \   00000014   0x68C2             LDR      R2,[R0, #+12]
   \   00000016   0x6051             STR      R1,[R2, #+4]
    691            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000018   0x21FC             MOVS     R1,#+252
   \   0000001A   0x68C2             LDR      R2,[R0, #+12]
   \   0000001C   0x6091             STR      R1,[R2, #+8]
    692            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000001E   0x21FC             MOVS     R1,#+252
   \   00000020   0x68C2             LDR      R2,[R0, #+12]
   \   00000022   0x60D1             STR      R1,[R2, #+12]
    693            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000024   0x21FC             MOVS     R1,#+252
   \   00000026   0x6902             LDR      R2,[R0, #+16]
   \   00000028   0x6011             STR      R1,[R2, #+0]
    694            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000002A   0x21FC             MOVS     R1,#+252
   \   0000002C   0x6902             LDR      R2,[R0, #+16]
   \   0000002E   0x6051             STR      R1,[R2, #+4]
    695            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000030   0x21FC             MOVS     R1,#+252
   \   00000032   0x6902             LDR      R2,[R0, #+16]
   \   00000034   0x6091             STR      R1,[R2, #+8]
    696            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \   00000036   0x21FC             MOVS     R1,#+252
   \   00000038   0x6902             LDR      R2,[R0, #+16]
   \   0000003A   0x60D1             STR      R1,[R2, #+12]
    697            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000003C   0x21FC             MOVS     R1,#+252
   \   0000003E   0x6942             LDR      R2,[R0, #+20]
   \   00000040   0x6011             STR      R1,[R2, #+0]
    698            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000042   0x21FC             MOVS     R1,#+252
   \   00000044   0x6942             LDR      R2,[R0, #+20]
   \   00000046   0x6051             STR      R1,[R2, #+4]
    699            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000048   0x21FC             MOVS     R1,#+252
   \   0000004A   0x6942             LDR      R2,[R0, #+20]
   \   0000004C   0x6091             STR      R1,[R2, #+8]
    700            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000004E   0x21FC             MOVS     R1,#+252
   \   00000050   0x6940             LDR      R0,[R0, #+20]
   \   00000052   0x60C1             STR      R1,[R0, #+12]
    701          }
   \   00000054   0x4770             BX       LR               ;; return
    702          
    703          /**
    704            * @brief  Enables or disables the PCCARD Memory Bank.
    705            * @param  NewState: new state of the PCCARD Memory Bank.  
    706            *          This parameter can be: ENABLE or DISABLE.
    707            * @retval None
    708            */

   \                                 In section .text, align 2, keep-with-next
    709          void FSMC_PCCARDCmd(FunctionalState NewState)
    710          {
    711            assert_param(IS_FUNCTIONAL_STATE(NewState));
    712            
    713            if (NewState != DISABLE)
   \                     FSMC_PCCARDCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??FSMC_PCCARDCmd_0
    714            {
    715              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    716              FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
   \   00000006   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a0
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000E   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a0
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0xE005             B.N      ??FSMC_PCCARDCmd_1
    717            }
    718            else
    719            {
    720              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    721              FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
   \                     ??FSMC_PCCARDCmd_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable15_14  ;; 0xa00000a0
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable15_10  ;; 0xffffb
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x....             LDR.N    R1,??DataTable15_14  ;; 0xa00000a0
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    722            }
    723          }
   \                     ??FSMC_PCCARDCmd_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    724          /**
    725            * @}
    726            */
    727          
    728          /** @defgroup FSMC_Group4  Interrupts and flags management functions
    729           *  @brief    Interrupts and flags management functions
    730           *
    731          @verbatim   
    732           ===============================================================================
    733                       ##### Interrupts and flags management functions #####
    734           ===============================================================================   
    735          
    736          @endverbatim
    737            * @{
    738            */
    739          
    740          /**
    741            * @brief  Enables or disables the specified FSMC interrupts.
    742            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    743            *          This parameter can be one of the following values:
    744            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    745            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    746            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    747            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    748            *          This parameter can be any combination of the following values:
    749            *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    750            *            @arg FSMC_IT_Level: Level edge detection interrupt.
    751            *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    752            * @param  NewState: new state of the specified FSMC interrupts.
    753            *          This parameter can be: ENABLE or DISABLE.
    754            * @retval None
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    757          {
    758            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    759            assert_param(IS_FSMC_IT(FSMC_IT));	
    760            assert_param(IS_FUNCTIONAL_STATE(NewState));
    761            
    762            if (NewState != DISABLE)
   \                     FSMC_ITConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD016             BEQ.N    ??FSMC_ITConfig_0
    763            {
    764              /* Enable the selected FSMC_Bank2 interrupts */
    765              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD105             BNE.N    ??FSMC_ITConfig_1
    766              {
    767                FSMC_Bank2->SR2 |= FSMC_IT;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_3  ;; 0xa0000064
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x....             LDR.N    R1,??DataTable15_3  ;; 0xa0000064
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0xE024             B.N      ??FSMC_ITConfig_2
    768              }
    769              /* Enable the selected FSMC_Bank3 interrupts */
    770              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_1: (+1)
   \   00000016   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000001A   0xD105             BNE.N    ??FSMC_ITConfig_3
    771              {
    772                FSMC_Bank3->SR3 |= FSMC_IT;
   \   0000001C   0x....             LDR.N    R0,??DataTable15_7  ;; 0xa0000084
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4308             ORRS     R0,R1,R0
   \   00000022   0x....             LDR.N    R1,??DataTable15_7  ;; 0xa0000084
   \   00000024   0x6008             STR      R0,[R1, #+0]
   \   00000026   0xE01B             B.N      ??FSMC_ITConfig_2
    773              }
    774              /* Enable the selected FSMC_Bank4 interrupts */
    775              else
    776              {
    777                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_3: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable15_15  ;; 0xa00000a4
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x4308             ORRS     R0,R1,R0
   \   0000002E   0x....             LDR.N    R1,??DataTable15_15  ;; 0xa00000a4
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE015             B.N      ??FSMC_ITConfig_2
    778              }
    779            }
    780            else
    781            {
    782              /* Disable the selected FSMC_Bank2 interrupts */
    783              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_0: (+1)
   \   00000034   0x2810             CMP      R0,#+16
   \   00000036   0xD105             BNE.N    ??FSMC_ITConfig_4
    784              {
    785                
    786                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable15_3  ;; 0xa0000064
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4388             BICS     R0,R0,R1
   \   0000003E   0x....             LDR.N    R1,??DataTable15_3  ;; 0xa0000064
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE00D             B.N      ??FSMC_ITConfig_2
    787              }
    788              /* Disable the selected FSMC_Bank3 interrupts */
    789              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_4: (+1)
   \   00000044   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000048   0xD105             BNE.N    ??FSMC_ITConfig_5
    790              {
    791                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
   \   0000004A   0x....             LDR.N    R0,??DataTable15_7  ;; 0xa0000084
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x4388             BICS     R0,R0,R1
   \   00000050   0x....             LDR.N    R1,??DataTable15_7  ;; 0xa0000084
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xE004             B.N      ??FSMC_ITConfig_2
    792              }
    793              /* Disable the selected FSMC_Bank4 interrupts */
    794              else
    795              {
    796                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
   \                     ??FSMC_ITConfig_5: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable15_15  ;; 0xa00000a4
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x4388             BICS     R0,R0,R1
   \   0000005C   0x....             LDR.N    R1,??DataTable15_15  ;; 0xa00000a4
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    797              }
    798            }
    799          }
   \                     ??FSMC_ITConfig_2: (+1)
   \   00000060   0x4770             BX       LR               ;; return
    800          
    801          /**
    802            * @brief  Checks whether the specified FSMC flag is set or not.
    803            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    804            *          This parameter can be one of the following values:
    805            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    806            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    807            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    808            * @param  FSMC_FLAG: specifies the flag to check.
    809            *          This parameter can be one of the following values:
    810            *            @arg FSMC_FLAG_RisingEdge: Rising edge detection Flag.
    811            *            @arg FSMC_FLAG_Level: Level detection Flag.
    812            *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
    813            *            @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    814            * @retval The new state of FSMC_FLAG (SET or RESET).
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    817          {
    818            FlagStatus bitstatus = RESET;
   \                     FSMC_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    819            uint32_t tmpsr = 0x00000000;
   \   00000002   0x2200             MOVS     R2,#+0
    820            
    821            /* Check the parameters */
    822            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    823            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    824            
    825            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000004   0x2810             CMP      R0,#+16
   \   00000006   0xD102             BNE.N    ??FSMC_GetFlagStatus_0
    826            {
    827              tmpsr = FSMC_Bank2->SR2;
   \   00000008   0x....             LDR.N    R0,??DataTable15_3  ;; 0xa0000064
   \   0000000A   0x6802             LDR      R2,[R0, #+0]
   \   0000000C   0xE007             B.N      ??FSMC_GetFlagStatus_1
    828            }  
    829            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetFlagStatus_0: (+1)
   \   0000000E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000012   0xD102             BNE.N    ??FSMC_GetFlagStatus_2
    830            {
    831              tmpsr = FSMC_Bank3->SR3;
   \   00000014   0x....             LDR.N    R0,??DataTable15_7  ;; 0xa0000084
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0xE001             B.N      ??FSMC_GetFlagStatus_1
    832            }
    833            /* FSMC_Bank4_PCCARD*/
    834            else
    835            {
    836              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetFlagStatus_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable15_15  ;; 0xa00000a4
   \   0000001C   0x6802             LDR      R2,[R0, #+0]
    837            } 
    838            
    839            /* Get the flag status */
    840            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
   \                     ??FSMC_GetFlagStatus_1: (+1)
   \   0000001E   0x420A             TST      R2,R1
   \   00000020   0xD001             BEQ.N    ??FSMC_GetFlagStatus_3
    841            {
    842              bitstatus = SET;
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xE000             B.N      ??FSMC_GetFlagStatus_4
    843            }
    844            else
    845            {
    846              bitstatus = RESET;
   \                     ??FSMC_GetFlagStatus_3: (+1)
   \   00000026   0x2200             MOVS     R2,#+0
    847            }
    848            /* Return the flag status */
    849            return bitstatus;
   \                     ??FSMC_GetFlagStatus_4: (+1)
   \   00000028   0x0010             MOVS     R0,R2
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x4770             BX       LR               ;; return
    850          }
    851          
    852          /**
    853            * @brief  Clears the FSMC's pending flags.
    854            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    855            *          This parameter can be one of the following values:
    856            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    857            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    858            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    859            * @param  FSMC_FLAG: specifies the flag to clear.
    860            *          This parameter can be any combination of the following values:
    861            *            @arg FSMC_FLAG_RisingEdge: Rising edge detection Flag.
    862            *            @arg FSMC_FLAG_Level: Level detection Flag.
    863            *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
    864            * @retval None
    865            */

   \                                 In section .text, align 2, keep-with-next
    866          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    867          {
    868           /* Check the parameters */
    869            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    870            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    871              
    872            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearFlag: (+1)
   \   00000000   0x2810             CMP      R0,#+16
   \   00000002   0xD105             BNE.N    ??FSMC_ClearFlag_0
    873            {
    874              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \   00000004   0x....             LDR.N    R0,??DataTable15_3  ;; 0xa0000064
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4388             BICS     R0,R0,R1
   \   0000000A   0x....             LDR.N    R1,??DataTable15_3  ;; 0xa0000064
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0xE00D             B.N      ??FSMC_ClearFlag_1
    875            }  
    876            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_0: (+1)
   \   00000010   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000014   0xD105             BNE.N    ??FSMC_ClearFlag_2
    877            {
    878              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \   00000016   0x....             LDR.N    R0,??DataTable15_7  ;; 0xa0000084
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4388             BICS     R0,R0,R1
   \   0000001C   0x....             LDR.N    R1,??DataTable15_7  ;; 0xa0000084
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   \   00000020   0xE004             B.N      ??FSMC_ClearFlag_1
    879            }
    880            /* FSMC_Bank4_PCCARD*/
    881            else
    882            {
    883              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_2: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable15_15  ;; 0xa00000a4
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x4388             BICS     R0,R0,R1
   \   00000028   0x....             LDR.N    R1,??DataTable15_15  ;; 0xa00000a4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    884            }
    885          }
   \                     ??FSMC_ClearFlag_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    886          
    887          /**
    888            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    889            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    890            *          This parameter can be one of the following values:
    891            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    892            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    893            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    894            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    895            *          This parameter can be one of the following values:
    896            *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    897            *            @arg FSMC_IT_Level: Level edge detection interrupt.
    898            *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    899            * @retval The new state of FSMC_IT (SET or RESET).
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    902          {
    903            ITStatus bitstatus = RESET;
   \                     FSMC_GetITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    904            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2200             MOVS     R2,#+0
    905            
    906            /* Check the parameters */
    907            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    908            assert_param(IS_FSMC_GET_IT(FSMC_IT));
    909            
    910            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000008   0x2810             CMP      R0,#+16
   \   0000000A   0xD102             BNE.N    ??FSMC_GetITStatus_0
    911            {
    912              tmpsr = FSMC_Bank2->SR2;
   \   0000000C   0x....             LDR.N    R0,??DataTable15_3  ;; 0xa0000064
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0xE007             B.N      ??FSMC_GetITStatus_1
    913            }  
    914            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetITStatus_0: (+1)
   \   00000012   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000016   0xD102             BNE.N    ??FSMC_GetITStatus_2
    915            {
    916              tmpsr = FSMC_Bank3->SR3;
   \   00000018   0x....             LDR.N    R0,??DataTable15_7  ;; 0xa0000084
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0xE001             B.N      ??FSMC_GetITStatus_1
    917            }
    918            /* FSMC_Bank4_PCCARD*/
    919            else
    920            {
    921              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetITStatus_2: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable15_15  ;; 0xa00000a4
   \   00000020   0x6802             LDR      R2,[R0, #+0]
    922            } 
    923            
    924            itstatus = tmpsr & FSMC_IT;
   \                     ??FSMC_GetITStatus_1: (+1)
   \   00000022   0xEA11 0x0302      ANDS     R3,R1,R2
    925            
    926            itenable = tmpsr & (FSMC_IT >> 3);
   \   00000026   0xEA12 0x02D1      ANDS     R2,R2,R1, LSR #+3
    927            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD003             BEQ.N    ??FSMC_GetITStatus_3
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD001             BEQ.N    ??FSMC_GetITStatus_3
    928            {
    929              bitstatus = SET;
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0xE000             B.N      ??FSMC_GetITStatus_4
    930            }
    931            else
    932            {
    933              bitstatus = RESET;
   \                     ??FSMC_GetITStatus_3: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
    934            }
    935            return bitstatus; 
   \                     ??FSMC_GetITStatus_4: (+1)
   \   00000038   0x0010             MOVS     R0,R2
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x4770             BX       LR               ;; return
    936          }
    937          
    938          /**
    939            * @brief  Clears the FSMC's interrupt pending bits.
    940            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    941            *          This parameter can be one of the following values:
    942            *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    943            *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    944            *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    945            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    946            *          This parameter can be any combination of the following values:
    947            *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    948            *            @arg FSMC_IT_Level: Level edge detection interrupt.
    949            *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    950            * @retval None
    951            */

   \                                 In section .text, align 2, keep-with-next
    952          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    953          {
    954            /* Check the parameters */
    955            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    956            assert_param(IS_FSMC_IT(FSMC_IT));
    957              
    958            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearITPendingBit: (+1)
   \   00000000   0x2810             CMP      R0,#+16
   \   00000002   0xD106             BNE.N    ??FSMC_ClearITPendingBit_0
    959            {
    960              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \   00000004   0x....             LDR.N    R0,??DataTable15_3  ;; 0xa0000064
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xEA30 0x00D1      BICS     R0,R0,R1, LSR #+3
   \   0000000C   0x....             LDR.N    R1,??DataTable15_3  ;; 0xa0000064
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE00F             B.N      ??FSMC_ClearITPendingBit_1
    961            }  
    962            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_0: (+1)
   \   00000012   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000016   0xD106             BNE.N    ??FSMC_ClearITPendingBit_2
    963            {
    964              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \   00000018   0x....             LDR.N    R0,??DataTable15_7  ;; 0xa0000084
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xEA30 0x00D1      BICS     R0,R0,R1, LSR #+3
   \   00000020   0x....             LDR.N    R1,??DataTable15_7  ;; 0xa0000084
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE005             B.N      ??FSMC_ClearITPendingBit_1
    965            }
    966            /* FSMC_Bank4_PCCARD*/
    967            else
    968            {
    969              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_2: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable15_15  ;; 0xa00000a4
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xEA30 0x00D1      BICS     R0,R0,R1, LSR #+3
   \   0000002E   0x....             LDR.N    R1,??DataTable15_15  ;; 0xa00000a4
   \   00000030   0x6008             STR      R0,[R1, #+0]
    970            }
    971          }
   \                     ??FSMC_ClearITPendingBit_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xA0000104         DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x000FFFFE         DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xA0000060         DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0xA0000064         DC32     0xa0000064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0xA0000068         DC32     0xa0000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0xA000006C         DC32     0xa000006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0xA0000080         DC32     0xa0000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0xA0000084         DC32     0xa0000084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0xA0000088         DC32     0xa0000088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0xA000008C         DC32     0xa000008c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x000FFFFB         DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x000FFFBF         DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0xA0000074         DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0xA0000094         DC32     0xa0000094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0xA00000A0         DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0xA00000A4         DC32     0xa00000a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0xA00000A8         DC32     0xa00000a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0xA00000AC         DC32     0xa00000ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0xA00000B0         DC32     0xa00000b0
    972          
    973          /**
    974            * @}
    975            */ 
    976          
    977          /**
    978            * @}
    979            */ 
    980          
    981          /**
    982            * @}
    983            */
    984          
    985          /**
    986            * @}
    987            */
    988          
    989          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FSMC_ClearFlag
       0   FSMC_ClearITPendingBit
       0   FSMC_GetECC
       0   FSMC_GetFlagStatus
       0   FSMC_GetITStatus
       0   FSMC_ITConfig
       0   FSMC_NANDCmd
       0   FSMC_NANDDeInit
       0   FSMC_NANDECCCmd
       4   FSMC_NANDInit
       0   FSMC_NANDStructInit
       0   FSMC_NORSRAMCmd
       0   FSMC_NORSRAMDeInit
       0   FSMC_NORSRAMInit
       0   FSMC_NORSRAMStructInit
       0   FSMC_PCCARDCmd
       0   FSMC_PCCARDDeInit
       0   FSMC_PCCARDInit
       0   FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      46  FSMC_ClearFlag
      52  FSMC_ClearITPendingBit
      20  FSMC_GetECC
      46  FSMC_GetFlagStatus
      62  FSMC_GetITStatus
      98  FSMC_ITConfig
      70  FSMC_NANDCmd
      80  FSMC_NANDDeInit
      70  FSMC_NANDECCCmd
     142  FSMC_NANDInit
      78  FSMC_NANDStructInit
      52  FSMC_NORSRAMCmd
      58  FSMC_NORSRAMDeInit
     226  FSMC_NORSRAMInit
     142  FSMC_NORSRAMStructInit
      34  FSMC_PCCARDCmd
      38  FSMC_PCCARDDeInit
     120  FSMC_PCCARDInit
      86  FSMC_PCCARDStructInit

 
 1 596 bytes in section .text
 
 1 596 bytes of CODE memory

Errors: none
Warnings: none
